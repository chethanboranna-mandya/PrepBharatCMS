<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to Json Converter</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- JSZip library for creating ZIP files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    
    <!-- Firebase Configuration -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import {
            getStorage,
            ref,
            uploadBytesResumable,
            getDownloadURL,
            deleteObject,
            listAll,
            list,
            getBytes
        } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-storage.js";
        import {
            getAuth,
            signInAnonymously,
            onAuthStateChanged
        } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

        // Load Firebase config - try from google-services.json if available, otherwise use hardcoded config
        let firebaseConfig = {
            apiKey: "AIzaSyDkRSU7sVKQXmQo4C-imX0aSeHXHhlH59E",
            authDomain: "prepbharat.firebaseapp.com",
            projectId: "prepbharat",
            storageBucket: "prepbharat.firebasestorage.app",
            messagingSenderId: "593555148862",
            appId: "1:593555148862:web:d627edfe32a17c71a5c16f",
            measurementId: "G-7QGE8KDDTF"
        };
        
        // Try to load from google-services.json if available (for consistency with Android)
        // Note: google-services.json typically has Android/iOS config, but we can extract project info
        async function loadFirebaseConfigFromGoogleServices() {
            try {
                const response = await fetch('/google-services.json');
                if (response.ok) {
                    const googleServices = await response.json();
                    // Extract project info from google-services.json
                    if (googleServices.project_info) {
                        const projectInfo = googleServices.project_info;
                        
                        // Update config with project info from google-services.json
                        // Keep web-specific values (apiKey, appId) from hardcoded config
                        firebaseConfig = {
                            apiKey: firebaseConfig.apiKey, // Keep web API key
                            authDomain: `${projectInfo.project_id}.firebaseapp.com`,
                            projectId: projectInfo.project_id,
                            storageBucket: projectInfo.storage_bucket || `${projectInfo.project_id}.appspot.com`,
                            messagingSenderId: projectInfo.project_number,
                            appId: firebaseConfig.appId, // Keep web app ID
                            measurementId: firebaseConfig.measurementId
                        };
                        
                        console.log('‚úÖ Loaded Firebase project info from google-services.json');
                        console.log('   Project ID:', firebaseConfig.projectId);
                        console.log('   Storage Bucket:', firebaseConfig.storageBucket);
                        return true;
                    }
                }
            } catch (error) {
                console.log('‚ÑπÔ∏è google-services.json not found or not accessible, using hardcoded config');
            }
            return false;
        }
        
        // Initialize Firebase immediately (will try to load from google-services.json if available)
        const app = initializeApp(firebaseConfig);
        const storage = getStorage(app);
        const auth = getAuth(app);
        
        // Authenticate anonymously to get access token (required for Storage API)
        let authToken = null;
        signInAnonymously(auth)
            .then((userCredential) => {
                console.log('‚úÖ Firebase anonymous authentication successful');
                return userCredential.user.getIdToken();
            })
            .then((token) => {
                authToken = token;
                console.log('‚úÖ Firebase access token obtained');
            })
            .catch((error) => {
                console.error('‚ùå Firebase authentication error:', error);
            });

        // Make firebase functions available globally
        window.firebaseStorage = {
            storage,
            ref,
            deleteObject,
            uploadBytesResumable,
            getDownloadURL,
            listAll,
            list,
            getBytes,
            auth,
            getAuthToken: () => authToken
        };
        
        // Try to load config from google-services.json in background (for future use)
        loadFirebaseConfigFromGoogleServices().then(loaded => {
            if (loaded) {
                console.log('‚ÑπÔ∏è Config loaded from google-services.json (will use on next page load)');
            }
        });

        // Helper function to get tutorial ID - make it globally available
        window.getTutorialIdForUpload = function(subject) {
            const suffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
            const tutorialIdField = document.getElementById(`tutorialId${suffix}`);
            return tutorialIdField ? tutorialIdField.value : 'tutorial';
        };

        // Firebase upload function with progress tracking
        window.uploadImageToFirebase = function(file, subject, year, index, suffix, onProgress, customFileName = null) {
            return new Promise((resolve, reject) => {
                let fileName;
                if (customFileName) {
                    fileName = customFileName;
                } else {
                    fileName = `${subject.toLowerCase()}_${year}_${index + 1}${suffix}`;
                }
                
                // Get board name for folder structure - always use main board field for consistency
                const boardField = document.getElementById('board');
                let boardName = 'Board'; // Default fallback
                
                if (boardField && boardField.value) {
                    boardName = boardField.value.replace(/\s+/g, '_');
                } else {
                    // Fallback: try to read from any visible board field
                    const visibleBoardField = document.querySelector('#board:not([style*="display: none"])');
                    if (visibleBoardField && visibleBoardField.value) {
                        boardName = visibleBoardField.value.replace(/\s+/g, '_');
                    }
                    console.warn(`‚ö†Ô∏è Board field not found or empty, using default "Board". Current folder: ${boardName}_${subject.toLowerCase()}`);
                }
                
                console.log(`üìÅ Uploading to folder: ${boardName}_${subject.toLowerCase()} (Board field value: "${boardField?.value || 'NOT FOUND'}")`);
                
                // Create folder path: Board_Subject (e.g., JEE_Main_Physics)
                const folderName = `${boardName}_${subject.toLowerCase()}`;
                
                const storageRef = ref(storage, `questions/${folderName}/${year}/${fileName}`);
                const uploadTask = uploadBytesResumable(storageRef, file);

                uploadTask.on(
                    "state_changed",
                    (snapshot) => {
                        const percent = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                        if (onProgress) onProgress(Math.round(percent));
                    },
                    (error) => reject(error),
                    () => {
                        getDownloadURL(uploadTask.snapshot.ref).then(resolve).catch(reject);
                    }
                );
            });
        };
        
        // Extract bitmap image from img element and upload to Firebase
        window.extractAndUploadImageFromView = function(imgElement, subject, year, questionNumber, imageIndex, suffix = '', onProgress = null) {
            return new Promise((resolve, reject) => {
                try {
                    // Check if image is already a Firebase URL
                    const currentSrc = imgElement.src;
                    if (currentSrc && currentSrc.includes('firebasestorage.googleapis.com')) {
                        resolve(currentSrc); // Already uploaded, return existing URL
                        return;
                    }
                    
                    // Check if image is loaded
                    if (!imgElement.complete || imgElement.naturalHeight === 0) {
                        // Wait for image to load
                        imgElement.onload = function() {
                            proceedWithExtraction();
                        };
                        imgElement.onerror = function() {
                            reject(new Error('Failed to load image'));
                        };
                    } else {
                        proceedWithExtraction();
                    }
                    
                    function proceedWithExtraction() {
                        // Create canvas
                        const canvas = document.createElement('canvas');
                        canvas.width = imgElement.naturalWidth || imgElement.width;
                        canvas.height = imgElement.naturalHeight || imgElement.height;
                        
                        // Draw image to canvas
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(imgElement, 0, 0);
                        
                        // Convert canvas to blob
                        canvas.toBlob((blob) => {
                            if (!blob) {
                                reject(new Error('Failed to extract image data'));
                                return;
                            }
                            
                            // Generate custom filename
                            const tutorialId = getTutorialIdForUpload(subject);
                            const customFileName = `${tutorialId}_Q${questionNumber}_image${imageIndex}${suffix ? '_' + suffix : ''}`;
                            
                            // Upload to Firebase
                            uploadImageToFirebase(blob, subject, year, questionNumber - 1, suffix, onProgress, customFileName)
                                .then(url => {
                                    // Update img src to Firebase URL
                                    imgElement.src = url;
                                    
                                    // Show checkmark indicator
                                    showUploadCheckmark(imgElement);
                                    
                                    resolve(url);
                                })
                                .catch(reject);
                        }, 'image/png'); // Use PNG format to preserve quality
                    }
                } catch (error) {
                    reject(error);
                }
            });
        };
        
        // Show checkmark indicator on image element
        function showUploadCheckmark(imgElement) {
            // Remove existing indicators if any
            const existingCheckmark = imgElement.parentElement?.querySelector('.upload-checkmark');
            if (existingCheckmark) {
                existingCheckmark.remove();
            }
            const existingError = imgElement.parentElement?.querySelector('.upload-error');
            if (existingError) {
                existingError.remove();
            }
            
            // Create checkmark indicator
            const checkmark = document.createElement('div');
            checkmark.className = 'upload-checkmark';
            checkmark.innerHTML = '‚úÖ';
            checkmark.title = 'Uploaded to Firebase';
            
            // Position checkmark (top-right corner of image parent)
            const imgParent = imgElement.parentElement;
            if (imgParent) {
                if (imgParent.style.position !== 'relative' && imgParent.style.position !== 'absolute') {
                    imgParent.style.position = 'relative';
                }
                imgParent.appendChild(checkmark);
            }
        };
        
        // Show error indicator on image element
        function showUploadError(imgElement, errorMessage = 'Upload failed') {
            // Remove existing indicators if any
            const existingCheckmark = imgElement.parentElement?.querySelector('.upload-checkmark');
            if (existingCheckmark) {
                existingCheckmark.remove();
            }
            const existingError = imgElement.parentElement?.querySelector('.upload-error');
            if (existingError) {
                existingError.remove();
            }
            
            // Create error indicator
            const errorIndicator = document.createElement('div');
            errorIndicator.className = 'upload-error';
            errorIndicator.innerHTML = '‚ùå';
            errorIndicator.title = errorMessage || 'Upload failed';
            
            // Position error indicator (top-right corner of image parent)
            const imgParent = imgElement.parentElement;
            if (imgParent) {
                if (imgParent.style.position !== 'relative' && imgParent.style.position !== 'absolute') {
                    imgParent.style.position = 'relative';
                }
                imgParent.appendChild(errorIndicator);
            }
        };
        
        // Check if image is from Firebase and show checkmark or error
        window.checkAndMarkUploadedImage = function(imgElement) {
            if (!imgElement || !imgElement.src) return;
            
            const imgParent = imgElement.parentElement;
            if (!imgParent) return;
            
            // Check if it's a Firebase URL
            if (imgElement.src && imgElement.src.includes('firebasestorage.googleapis.com')) {
                showUploadCheckmark(imgElement);
                return;
            }
            
            // Check if this image has uploadFailed flag (check in question object)
            // Try to find question number to check question object
            let questionNumber = null;
            let container = imgParent;
            for (let i = 0; i < 5 && container && !questionNumber; i++) {
                if (container.id) {
                    const match = container.id.match(/(?:question|solution|text)[_-]*(?:content|rows|images)[_-]*(\d+)/i) ||
                                container.id.match(/question[_-]?(\d+)/i);
                    if (match) {
                        questionNumber = parseInt(match[1]);
                        break;
                    }
                }
                container = container.parentElement;
            }
            
            // Check if this image failed to upload
            if (questionNumber) {
                const question = allQuestions.find(q => q.number === questionNumber);
                if (question) {
                    // Check solutionTextImages, textImages, and optionImages for this image
                    const allImages = [
                        ...(question.solutionTextImages || []),
                        ...(question.textImages || []),
                        ...(question.optionImages?.flat() || [])
                    ];
                    
                    const imageObj = allImages.find(img => img && img.image === imgElement.src);
                    if (imageObj && imageObj.uploadFailed) {
                        showUploadError(imgElement, imageObj.uploadError || 'Upload failed - CORS restrictions');
                        return;
                    }
                }
            }
            
            // Don't show upload button during automatic upload
            if (isAutoUploading) {
                return;
            }
            
            // Only show upload button if we found a question number and not during auto upload
            if (questionNumber && !isAutoUploading) {
                showUploadButton(imgElement, questionNumber, null);
            }
        };
        
        // Show upload button on image element (if not uploaded to Firebase)
        function showUploadButton(imgElement, questionNumber = null, imageIndex = null) {
            // Don't show button if already uploaded or button exists
            if (imgElement.src && imgElement.src.includes('firebasestorage.googleapis.com')) {
                showUploadCheckmark(imgElement);
                return;
            }
            
            // Don't show button if question number is not available
            if (!questionNumber || isNaN(questionNumber)) {
                console.warn('Cannot show upload button: question number not available for image:', imgElement.src);
                return;
            }
            
            const imgParent = imgElement.parentElement;
            if (!imgParent) return;
            
            // Remove existing upload button if any
            const existingBtn = imgParent.querySelector('.upload-image-btn');
            if (existingBtn) return; // Already has button
            
            // Remove existing checkmark if any
            const existingCheckmark = imgParent.querySelector('.upload-checkmark');
            if (existingCheckmark) return; // Already uploaded
            
            // Ensure parent has relative positioning
            if (imgParent.style.position !== 'relative' && imgParent.style.position !== 'absolute') {
                imgParent.style.position = 'relative';
            }
            
            // Create upload button
            const uploadBtn = document.createElement('button');
            uploadBtn.className = 'upload-image-btn';
            uploadBtn.innerHTML = '‚¨Ü';
            uploadBtn.title = 'Upload to Firebase';
            uploadBtn.onclick = function(e) {
                e.stopPropagation();
                uploadImageFromView(imgElement, questionNumber, imageIndex);
            };
            
            imgParent.appendChild(uploadBtn);
        };
        
        // Upload image from view with automatic subject/year detection
        function uploadImageFromView(imgElement, questionNumber = null, imageIndex = null) {
            if (!imgElement) return;
            
            // Get question number from nearest parent or parameter
            if (!questionNumber) {
                // 1. Try data-question attribute
                const dataQuestion = imgElement.closest('[data-question]');
                if (dataQuestion) {
                    questionNumber = parseInt(dataQuestion.getAttribute('data-question'));
                }
                
                // 2. Try container IDs (like solution-content-rows-10)
                if (!questionNumber) {
                    let container = imgElement.parentElement;
                    for (let i = 0; i < 5 && container && !questionNumber; i++) {
                        if (container.id) {
                            const match = container.id.match(/(?:question|solution|text)[_-]*(?:content|rows|images)[_-]*(\d+)/i) ||
                                        container.id.match(/question[_-]?(\d+)/i);
                            if (match) {
                                questionNumber = parseInt(match[1]);
                                break;
                            }
                        }
                        container = container.parentElement;
                    }
                }
                
                // 3. Try question element in DOM hierarchy
                if (!questionNumber) {
                    const questionElement = imgElement.closest('[id*="question"], .question-container, [data-question-number]');
                    if (questionElement) {
                        if (questionElement.id) {
                            const match = questionElement.id.match(/question[_-]?(\d+)/i);
                            if (match) questionNumber = parseInt(match[1]);
                        }
                        if (!questionNumber && questionElement.getAttribute) {
                            questionNumber = parseInt(questionElement.getAttribute('data-question-number'));
                        }
                    }
                }
            }
            
            if (!questionNumber || isNaN(questionNumber)) {
                console.warn('Could not determine question number for image:', imgElement.src);
                // Only show alert if user manually clicked upload button
                const uploadBtn = imgElement.parentElement?.querySelector('.upload-image-btn');
                if (uploadBtn && uploadBtn.onclick) {
                    alert('Could not determine question number. Please specify.');
                }
                return;
            }
            
            // Get subject
            const currentSubject = getCurrentSubject ? getCurrentSubject() : 'Mathematics';
            const year = '2025';
            const suffix = '';
            
            // Show uploading indicator
            const uploadBtn = imgElement.parentElement.querySelector('.upload-image-btn');
            if (uploadBtn) {
                uploadBtn.innerHTML = '‚è≥';
                uploadBtn.style.pointerEvents = 'none';
            }
            
            // Extract and upload
            extractAndUploadImageFromView(imgElement, currentSubject, year, questionNumber, imageIndex || 0, suffix, (percent) => {
                if (uploadBtn) {
                    uploadBtn.innerHTML = `${percent}%`;
                }
            })
            .then(url => {
                console.log('Image uploaded to Firebase:', url);
                // Button will be replaced by checkmark
                if (uploadBtn) {
                    uploadBtn.remove();
                }
                
                // Update question object if questionNumber is available
                const question = allQuestions.find(q => q.number === questionNumber);
                if (question) {
                    // Update the image URL in the appropriate array
                    // This depends on where the image is (question text, options, solution)
                    // You may need to identify which type it is from context
                }
            })
            .catch(error => {
                console.error('Upload failed:', error);
                if (uploadBtn) {
                    uploadBtn.innerHTML = '‚ùå';
                    uploadBtn.title = 'Upload failed. Click to retry.';
                    uploadBtn.style.pointerEvents = 'auto';
                }
                alert('Failed to upload image: ' + error.message);
            });
        };
        
        // Scan all images on page and add upload buttons or checkmarks
        window.scanAndMarkImages = function(container = null) {
            const scope = container || document;
            const images = scope.querySelectorAll('img[src]:not([src=""])');
            
            images.forEach((img, index) => {
                // Skip if already has upload button or checkmark
                const imgParent = img.parentElement;
                if (!imgParent) return;
                
                if (imgParent.querySelector('.upload-checkmark') || imgParent.querySelector('.upload-image-btn')) {
                    return; // Already marked
                }
                
                // Check if it's a Firebase URL
                if (img.src && img.src.includes('firebasestorage.googleapis.com')) {
                    showUploadCheckmark(img);
                } else if (img.src && !img.src.startsWith('data:')) {
                    // Not a data URL and not Firebase - try to find question number from context
                    let questionNumber = null;
                    
                    // Try to find question number from various contexts
                    // 1. From closest element with data-question attribute
                    const dataQuestion = img.closest('[data-question]');
                    if (dataQuestion) {
                        questionNumber = parseInt(dataQuestion.getAttribute('data-question'));
                    }
                    
                    // 2. From container IDs (like solution-content-rows-10)
                    if (!questionNumber) {
                        let container = imgParent;
                        for (let i = 0; i < 5 && container && !questionNumber; i++) {
                            if (container.id) {
                                const match = container.id.match(/(?:question|solution|text)[_-]*(?:content|rows|images)[_-]*(\d+)/i) ||
                                            container.id.match(/question[_-]?(\d+)/i);
                                if (match) {
                                    questionNumber = parseInt(match[1]);
                                    break;
                                }
                            }
                            container = container.parentElement;
                        }
                    }
                    
                    // 3. From question element in DOM hierarchy
                    if (!questionNumber) {
                        const questionElement = img.closest('[id*="question"], .question-container, [data-question-number]');
                        if (questionElement) {
                            if (questionElement.id) {
                                const match = questionElement.id.match(/question[_-]?(\d+)/i);
                                if (match) questionNumber = parseInt(match[1]);
                            }
                            if (!questionNumber && questionElement.getAttribute) {
                                questionNumber = parseInt(questionElement.getAttribute('data-question-number'));
                            }
                        }
                    }
                    
                    // Only show upload button if we found a question number and not during auto upload
                    // Otherwise, just show checkmark if it's Firebase URL (already handled above)
                    if (questionNumber && !isAutoUploading) {
                        showUploadButton(img, questionNumber, index);
                    }
                }
            });
        };
        
        // Flag to track if automatic upload is in progress
        let isAutoUploading = false;
        
        // Flag to prevent automatic preview switch after upload (make it globally accessible)
        window.skipAutoPreviewSwitch = false;
        
        // Flag to track if we're in single question view mode (prevents populateInlineEditFields from overwriting)
        let isSingleQuestionViewMode = false;
        
        // Upload all extracted images from questions to Firebase
        window.uploadAllExtractedImages = async function uploadAllExtractedImages() {
            console.log('üöÄ uploadAllExtractedImages() called');
            
            if (!allQuestions || allQuestions.length === 0) {
                console.warn('‚ö†Ô∏è No questions to process images for');
                return;
            }
            
            console.log(`üìã Found ${allQuestions.length} questions`);
            
            // Set flag to prevent showing upload buttons during automatic upload
            isAutoUploading = true;
            
            // Get year from form (default to 2025)
            const yearField = document.getElementById('year');
            const year = yearField ? yearField.value || '2025' : '2025';
            let totalImages = 0;
            let uploadedImages = 0;
            
            // Count total images to upload
            allQuestions.forEach((question, qIdx) => {
                const qNum = question.number || question.questionNumber || question.questionIndex;
                let qImageCount = 0;
                
                if (question.textImages) {
                    qImageCount += question.textImages.length;
                    console.log(`  Q${qNum}: Found ${question.textImages.length} text image(s)`);
                }
                if (question.solutionTextImages) {
                    qImageCount += question.solutionTextImages.length;
                    console.log(`  Q${qNum}: Found ${question.solutionTextImages.length} solution image(s)`);
                }
                if (question.optionImages) {
                    question.optionImages.forEach((optImgs, optIdx) => {
                        if (optImgs && optImgs.length > 0) {
                            qImageCount += optImgs.length;
                            console.log(`  Q${qNum}: Found ${optImgs.length} option ${optIdx} image(s)`);
                        }
                    });
                }
                
                totalImages += qImageCount;
                if (qImageCount > 0) {
                    console.log(`  Q${qNum}: Total ${qImageCount} image(s) for this question`);
                }
            });
            
            console.log(`üìä Total images found across all questions: ${totalImages}`);
            
            if (totalImages === 0) {
                console.warn('‚ö†Ô∏è No images to upload - no images were extracted from the .md file');
                isAutoUploading = false;
                return;
            }
            
            console.log(`üîÑ ========== Starting automatic upload of ${totalImages} images to Firebase ==========`);
            
            // Flag to track if upload should be cancelled
            let isUploadCancelled = false;
            
            // Show notification with progress bar
            const notification = document.createElement('div');
            notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #2563eb; color: white; padding: 15px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.1); min-width: 300px;';
            
            // Header with close button
            const header = document.createElement('div');
            header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;';
            
            // Main text
            const mainText = document.createElement('div');
            mainText.style.cssText = 'font-size: 14px; font-weight: 500; flex: 1;';
            mainText.textContent = `üì§ Uploading ${totalImages} images to Firebase...`;
            header.appendChild(mainText);
            
            // Close button
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '‚úï';
            closeButton.style.cssText = 'background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; font-size: 16px; line-height: 1; padding: 0; margin-left: 10px; display: flex; align-items: center; justify-content: center; transition: background 0.2s;';
            closeButton.title = 'Cancel upload';
            closeButton.onmouseover = () => closeButton.style.background = 'rgba(255, 255, 255, 0.3)';
            closeButton.onmouseout = () => closeButton.style.background = 'rgba(255, 255, 255, 0.2)';
            closeButton.onclick = () => {
                isUploadCancelled = true;
                console.log('‚ùå Upload cancelled by user');
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
                isAutoUploading = false;
            };
            header.appendChild(closeButton);
            notification.appendChild(header);
            
            // Progress bar container
            const progressBarContainer = document.createElement('div');
            progressBarContainer.style.cssText = 'width: 100%; height: 6px; background: white; border-radius: 3px; overflow: hidden;';
            
            const progressBar = document.createElement('div');
            progressBar.style.cssText = 'height: 100%; background: #10b981; width: 0%; transition: width 0.3s ease; border-radius: 3px;';
            progressBarContainer.appendChild(progressBar);
            notification.appendChild(progressBarContainer);
            
            // Progress text
            const progressText = document.createElement('div');
            progressText.style.cssText = 'font-size: 12px; margin-top: 6px; opacity: 0.9; text-align: center;';
            progressText.textContent = `0 / ${totalImages}`;
            notification.appendChild(progressText);
            
            document.body.appendChild(notification);
            
            // Function to update progress
            const updateProgress = (current) => {
                if (isUploadCancelled) return;
                const percentage = totalImages > 0 ? (current / totalImages) * 100 : 0;
                progressBar.style.width = `${percentage}%`;
                progressText.textContent = `${current} / ${totalImages}`;
            };
            
            // Process all questions
            for (const question of allQuestions) {
                // Check if upload was cancelled
                if (isUploadCancelled) {
                    console.log('‚èπÔ∏è Upload cancelled - stopping processing');
                    break;
                }
                
                const questionNumber = question.number || question.questionNumber || question.questionIndex;
                
                // Skip if question number is invalid
                if (!questionNumber || questionNumber === 'undefined' || questionNumber === 'null') {
                    console.warn('‚ö†Ô∏è Skipping question with invalid number:', question);
                    continue;
                }
                
                // Get the subject for this question
                const questionSubject = question.subject || 
                                      (question.questionDetails && question.questionDetails[0]?.metadata?.subject) ||
                                      'Mathematics';
                // Capitalize first letter to match expected format
                const subjectForUpload = questionSubject.charAt(0).toUpperCase() + questionSubject.slice(1).toLowerCase();
                
                console.log(`üì§ Processing Q${questionNumber} (Subject: ${subjectForUpload})...`);
                
                // Upload text images
                if (question.textImages && Array.isArray(question.textImages)) {
                    for (let idx = 0; idx < question.textImages.length; idx++) {
                        if (isUploadCancelled) break;
                        
                        const imgObj = question.textImages[idx];
                        if (!imgObj || !imgObj.image) continue;
                        
                        const imageUrl = imgObj.image;
                        
                        // Skip if already a Firebase URL
                        if (imageUrl && imageUrl.includes('firebasestorage.googleapis.com')) {
                            uploadedImages++;
                            updateProgress(uploadedImages);
                            continue;
                        }
                        
                        try {
                            console.log(`  ‚Ü≥ Uploading question text image ${idx} for Q${questionNumber}...`);
                            const newUrl = await uploadImageFromUrl(imageUrl, subjectForUpload, year, questionNumber, idx, '', 'question');
                            if (isUploadCancelled) break;
                            imgObj.image = newUrl;
                            uploadedImages++;
                            updateProgress(uploadedImages);
                            console.log(`  ‚úÖ Uploaded question text image ${idx} for Q${questionNumber}: ${newUrl.substring(0, 60)}...`);
                        } catch (error) {
                            if (isUploadCancelled) break;
                            console.error(`  ‚ùå Failed to upload question text image ${idx} for Q${questionNumber}:`, error);
                            // Keep original URL if upload fails - image will still be displayed
                            // Mark as failed for UI indication
                            imgObj.uploadFailed = true;
                            imgObj.uploadError = error.message || 'Upload failed';
                        }
                    }
                }
                
                // Upload solution images
                if (question.solutionTextImages && Array.isArray(question.solutionTextImages)) {
                    for (let idx = 0; idx < question.solutionTextImages.length; idx++) {
                        if (isUploadCancelled) break;
                        
                        const imgObj = question.solutionTextImages[idx];
                        if (!imgObj || !imgObj.image) continue;
                        
                        const imageUrl = imgObj.image;
                        
                        // Skip if already a Firebase URL
                        if (imageUrl && imageUrl.includes('firebasestorage.googleapis.com')) {
                            uploadedImages++;
                            updateProgress(uploadedImages);
                            continue;
                        }
                        
                        try {
                            console.log(`  ‚Ü≥ Uploading solution image ${idx} for Q${questionNumber}...`);
                            const newUrl = await uploadImageFromUrl(imageUrl, subjectForUpload, year, questionNumber, idx, '', 'solution');
                            if (isUploadCancelled) break;
                            imgObj.image = newUrl;
                            uploadedImages++;
                            updateProgress(uploadedImages);
                            console.log(`  ‚úÖ Uploaded solution image ${idx} for Q${questionNumber}: ${newUrl.substring(0, 60)}...`);
                        } catch (error) {
                            if (isUploadCancelled) break;
                            console.error(`  ‚ùå Failed to upload solution image ${idx} for Q${questionNumber}:`, error);
                            // Keep original URL if upload fails - image will still be displayed
                            // Mark as failed for UI indication
                            imgObj.uploadFailed = true;
                            imgObj.uploadError = error.message || 'Upload failed';
                        }
                    }
                }
                
                // Upload option images
                if (question.optionImages && Array.isArray(question.optionImages)) {
                    for (let optIdx = 0; optIdx < question.optionImages.length; optIdx++) {
                        if (isUploadCancelled) break;
                        
                        const optImgs = question.optionImages[optIdx];
                        if (!optImgs || !Array.isArray(optImgs)) continue;
                        
                        for (let idx = 0; idx < optImgs.length; idx++) {
                            if (isUploadCancelled) break;
                            
                            const imgObj = optImgs[idx];
                            if (!imgObj || !imgObj.image) continue;
                            
                            const imageUrl = imgObj.image;
                            
                            // Skip if already a Firebase URL
                            if (imageUrl && imageUrl.includes('firebasestorage.googleapis.com')) {
                                uploadedImages++;
                                updateProgress(uploadedImages);
                                continue;
                            }
                            
                            try {
                                const newUrl = await uploadImageFromUrl(imageUrl, subjectForUpload, year, questionNumber, idx, `opt${optIdx}`, 'option');
                                if (isUploadCancelled) break;
                                imgObj.image = newUrl;
                                uploadedImages++;
                                updateProgress(uploadedImages);
                                console.log(`  ‚úÖ Uploaded option ${optIdx} image ${idx} for Q${questionNumber}`);
                            } catch (error) {
                                if (isUploadCancelled) break;
                                console.error(`  ‚ùå Failed to upload option ${optIdx} image ${idx} for Q${questionNumber}:`, error);
                                // Keep original URL if upload fails
                                imgObj.uploadFailed = true;
                                imgObj.uploadError = error.message || 'Upload failed';
                            }
                        }
                    }
                }
            }
            
            // Check if upload was cancelled
            if (isUploadCancelled) {
                console.log(`‚èπÔ∏è ========== Upload cancelled - ${uploadedImages}/${totalImages} images uploaded before cancellation ==========`);
                // Notification already removed by close button handler
            } else {
                console.log(`‚úÖ ========== Uploaded ${uploadedImages}/${totalImages} images to Firebase ==========`);
                
                // Update notification - final state
                if (notification && notification.parentNode) {
                    updateProgress(uploadedImages); // Final update
                    notification.style.background = uploadedImages === totalImages ? '#10b981' : '#f59e0b';
                    
                    // Update the main text
                    if (mainText) {
                        mainText.textContent = uploadedImages === totalImages 
                            ? `‚úÖ Successfully uploaded ${uploadedImages} images to Firebase!`
                            : `‚ö†Ô∏è Uploaded ${uploadedImages}/${totalImages} images (some may have failed)`;
                    }
                    
                    // Hide close button on completion
                    if (closeButton) {
                        closeButton.style.display = 'none';
                    }
                    
                    // Remove notification after 5 seconds
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 5000);
                }
            }
            
            // Clear flag - automatic upload is complete or cancelled
            isAutoUploading = false;
            
            // Refresh display and scan for checkmarks
            setTimeout(() => {
                console.log('üîÑ Refreshing display with Firebase URLs...');
                displayQuestions(); // Refresh to show Firebase URLs
                
                // Function to add checkmarks to all Firebase images
                const addCheckmarksToFirebaseImages = () => {
                    console.log('üîç Scanning for Firebase images to add checkmarks...');
                    const images = document.querySelectorAll('img[src]');
                    let checkmarkCount = 0;
                    let firebaseImageCount = 0;
                    
                    images.forEach((img, idx) => {
                        if (img.src && img.src.includes('firebasestorage.googleapis.com')) {
                            firebaseImageCount++;
                            // Only add checkmarks for Firebase URLs
                            try {
                                checkAndMarkUploadedImage(img);
                                checkmarkCount++;
                                console.log(`  ‚úÖ Added checkmark to image ${idx + 1}: ${img.src.substring(0, 50)}...`);
                            } catch (error) {
                                console.error(`  ‚ùå Failed to add checkmark to image ${idx + 1}:`, error);
                            }
                        }
                    });
                    
                    console.log(`‚úÖ Found ${firebaseImageCount} Firebase images, added checkmarks to ${checkmarkCount} images`);
                    return firebaseImageCount;
                };
                
                // Wait for images to load, then add checkmarks
                const waitForImagesAndAddCheckmarks = (attempts = 0, maxAttempts = 10) => {
                    const images = document.querySelectorAll('img[src]');
                    const firebaseImages = Array.from(images).filter(img => 
                        img.src && img.src.includes('firebasestorage.googleapis.com')
                    );
                    
                    if (firebaseImages.length === 0 && attempts < maxAttempts) {
                        console.log(`‚è≥ Waiting for Firebase images to load... (attempt ${attempts + 1}/${maxAttempts})`);
                        setTimeout(() => waitForImagesAndAddCheckmarks(attempts + 1, maxAttempts), 500);
                        return;
                    }
                    
                    // All images loaded or max attempts reached
                    const firebaseCount = addCheckmarksToFirebaseImages();
                    
                    if (firebaseCount === 0 && attempts < maxAttempts) {
                        console.log(`‚è≥ No Firebase images found yet, retrying... (attempt ${attempts + 1}/${maxAttempts})`);
                        setTimeout(() => waitForImagesAndAddCheckmarks(attempts + 1, maxAttempts), 1000);
                    } else {
                        // Final scan for any missed checkmarks
                        setTimeout(() => {
                            console.log('üîç Final scan for checkmarks...');
                            scanAndMarkImages();
                        }, 1000);
                    }
                };
                
                // Start checking after a short delay
                setTimeout(() => waitForImagesAndAddCheckmarks(), 500);
            }, 500);
        };
        
        // Temporary cache for image blobs using IndexedDB
        const imageCacheDB = 'imageCacheDB';
        const imageCacheStore = 'imageCache';
        
        async function openImageCache() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(imageCacheDB, 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(imageCacheStore)) {
                        db.createObjectStore(imageCacheStore);
                    }
                };
            });
        }
        
        async function saveImageToCache(imageUrl, blob) {
            try {
                const db = await openImageCache();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([imageCacheStore], 'readwrite');
                    const store = transaction.objectStore(imageCacheStore);
                    const request = store.put(blob, imageUrl);
                    request.onsuccess = () => {
                        console.log(`üíæ Saved image to cache: ${imageUrl.substring(0, 50)}...`);
                        resolve();
                    };
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.warn(`‚ö†Ô∏è Failed to save to cache:`, error);
                // Don't fail if cache fails
            }
        }
        
        async function getImageFromCache(imageUrl) {
            try {
                const db = await openImageCache();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([imageCacheStore], 'readonly');
                    const store = transaction.objectStore(imageCacheStore);
                    const request = store.get(imageUrl);
                    request.onsuccess = () => {
                        if (request.result) {
                            console.log(`üìÇ Found image in cache: ${imageUrl.substring(0, 50)}...`);
                            resolve(request.result);
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.warn(`‚ö†Ô∏è Failed to read from cache:`, error);
                return null;
            }
        }
        
        async function deleteImageFromCache(imageUrl) {
            try {
                const db = await openImageCache();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([imageCacheStore], 'readwrite');
                    const store = transaction.objectStore(imageCacheStore);
                    const request = store.delete(imageUrl);
                    request.onsuccess = () => {
                        console.log(`üóëÔ∏è Deleted image from cache: ${imageUrl.substring(0, 50)}...`);
                        resolve();
                    };
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.warn(`‚ö†Ô∏è Failed to delete from cache:`, error);
                // Don't fail if cache deletion fails
            }
        }
        
        // Upload image from URL to Firebase using displayed image extraction
        async function uploadImageFromUrl(imageUrl, subject, year, questionNumber, imageIndex, suffix = '', type = 'question') {
            return new Promise(async (resolve, reject) => {
                // Skip if already Firebase URL
                if (imageUrl && imageUrl.includes('firebasestorage.googleapis.com')) {
                    resolve(imageUrl);
                    return;
                }
                
                console.log(`üñºÔ∏è Processing image: ${imageUrl.substring(0, 80)}...`);
                
                // Step 1: Check cache first
                const cachedBlob = await getImageFromCache(imageUrl);
                if (cachedBlob) {
                    console.log(`üìÇ Using cached blob for upload...`);
                    try {
                        const tutorialId = getTutorialIdForUpload(subject);
                        const typeSuffix = type === 'question' ? 'img' : type === 'solution' ? 'sol' : 'opt';
                        const customFileName = `${tutorialId}_Q${questionNumber}_${typeSuffix}${imageIndex}${suffix ? '_' + suffix : ''}`;
                        
                        const firebaseUrl = await uploadImageToFirebase(cachedBlob, subject, year, questionNumber - 1, suffix, null, customFileName);
                        console.log(`‚úÖ Uploaded from cache: ${firebaseUrl}`);
                        
                        // Step 5: Delete from cache after successful upload
                        await deleteImageFromCache(imageUrl);
                        
                        resolve(firebaseUrl);
                        return;
                    } catch (error) {
                        console.error(`‚ùå Failed to upload from cache:`, error);
                        // Fall through to fetch fresh
                    }
                }
                
                // Step 2: Render image in DOM first
                console.log(`üñºÔ∏è Rendering image in DOM for extraction: ${imageUrl.substring(0, 50)}...`);
                const img = new Image();
                img.crossOrigin = 'anonymous'; // Try CORS, but may not work for all images
                
                // Create a container to hold the image
                const imageContainer = document.createElement('div');
                imageContainer.style.position = 'absolute';
                imageContainer.style.left = '-9999px';
                imageContainer.style.top = '-9999px';
                imageContainer.style.width = '1px';
                imageContainer.style.height = '1px';
                imageContainer.style.overflow = 'hidden';
                imageContainer.appendChild(img);
                document.body.appendChild(imageContainer);
                
                const loadTimeout = setTimeout(() => {
                    img.onload = null;
                    img.onerror = null;
                    if (imageContainer.parentNode) {
                        imageContainer.parentNode.removeChild(imageContainer);
                    }
                    reject(new Error(`Image load timeout: ${imageUrl.substring(0, 50)}...`));
                }, 30000);
                
                img.onload = async function() {
                    clearTimeout(loadTimeout);
                    console.log(`‚úÖ Image rendered in DOM, extracting bitmap...`);
                    
                    // Step 3: Extract bitmap - try canvas first, fall back to CORS proxy
                    let blob = null;
                    
                    // Try canvas extraction
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.drawImage(img, 0, 0);
                        
                        // Check if canvas is tainted
                        try {
                            ctx.getImageData(0, 0, 1, 1);
                            
                            // Not tainted - extract blob
                            blob = await new Promise((resolveCanvas, rejectCanvas) => {
                                canvas.toBlob((blobResult) => {
                                    if (blobResult) {
                                        console.log(`üì¶ Extracted bitmap from rendered view (${(blobResult.size / 1024).toFixed(2)} KB)`);
                                        resolveCanvas(blobResult);
                                    } else {
                                        rejectCanvas(new Error('Canvas toBlob returned null'));
                                    }
                                }, 'image/png');
                            });
                        } catch (taintedError) {
                            // Canvas is tainted - use CORS proxy
                            console.warn(`‚ö†Ô∏è Canvas is tainted, using CORS proxy...`);
                            blob = null;
                        }
                    } catch (canvasError) {
                        console.warn(`‚ö†Ô∏è Canvas extraction failed:`, canvasError);
                        blob = null;
                    }
                    
                    // Clean up image container
                    if (imageContainer.parentNode) {
                        imageContainer.parentNode.removeChild(imageContainer);
                    }
                    
                    // If canvas extraction failed, use CORS proxy
                    if (!blob) {
                        console.log(`üåê Fetching via CORS proxy...`);
                        blob = await fetchImageViaProxy(imageUrl);
                    }
                    
                    if (!blob) {
                        reject(new Error(`Failed to extract image bitmap: ${imageUrl.substring(0, 50)}...`));
                        return;
                    }
                    
                    // Step 4: Save to cache
                    await saveImageToCache(imageUrl, blob);
                    
                    // Step 5: Upload to Firebase
                    try {
                        const tutorialId = getTutorialIdForUpload(subject);
                        const typeSuffix = type === 'question' ? 'img' : type === 'solution' ? 'sol' : 'opt';
                        const customFileName = `${tutorialId}_Q${questionNumber}_${typeSuffix}${imageIndex}${suffix ? '_' + suffix : ''}`;
                        
                        const firebaseUrl = await uploadImageToFirebase(blob, subject, year, questionNumber - 1, suffix, null, customFileName);
                        console.log(`‚úÖ Successfully uploaded ${type} image for Q${questionNumber}: ${firebaseUrl}`);
                        
                        // Step 6: Delete from cache after successful upload
                        await deleteImageFromCache(imageUrl);
                        
                        resolve(firebaseUrl);
                    } catch (uploadError) {
                        console.error(`‚ùå Failed to upload to Firebase:`, uploadError);
                        // Keep blob in cache for retry
                        reject(uploadError);
                    }
                };
                
                img.onerror = function(error) {
                    clearTimeout(loadTimeout);
                    if (imageContainer.parentNode) {
                        imageContainer.parentNode.removeChild(imageContainer);
                    }
                    console.warn(`‚ö†Ô∏è Image failed to load in DOM: ${imageUrl.substring(0, 50)}...`);
                    
                    // Try CORS proxy as fallback
                    fetchImageViaProxy(imageUrl)
                        .then(async (blob) => {
                            if (!blob) {
                                reject(new Error(`Failed to fetch image: ${imageUrl.substring(0, 50)}...`));
                                return;
                            }
                            
                            // Save to cache
                            await saveImageToCache(imageUrl, blob);
                            
                            // Upload
                            const tutorialId = getTutorialIdForUpload(subject);
                            const typeSuffix = type === 'question' ? 'img' : type === 'solution' ? 'sol' : 'opt';
                            const customFileName = `${tutorialId}_Q${questionNumber}_${typeSuffix}${imageIndex}${suffix ? '_' + suffix : ''}`;
                            
                            const firebaseUrl = await uploadImageToFirebase(blob, subject, year, questionNumber - 1, suffix, null, customFileName);
                            console.log(`‚úÖ Successfully uploaded ${type} image for Q${questionNumber} (via proxy): ${firebaseUrl}`);
                            
                            // Delete from cache
                            await deleteImageFromCache(imageUrl);
                            
                            resolve(firebaseUrl);
                        })
                        .catch(proxyError => {
                            reject(new Error(`Failed to fetch image via proxy: ${proxyError.message}`));
                        });
                };
                
                // Start loading image
                img.src = imageUrl;
                
                // Helper function to fetch image via CORS proxy
                async function fetchImageViaProxy(url) {
                    const corsProxies = [
                        `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
                        `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
                        `https://corsproxy.io/?${encodeURIComponent(url)}`
                    ];
                    
                    for (let i = 0; i < corsProxies.length; i++) {
                        try {
                            console.log(`üîó Trying proxy ${i + 1}/${corsProxies.length}...`);
                            const response = await fetch(corsProxies[i], {
                                method: 'GET',
                                mode: 'cors'
                            });
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const blob = await response.blob();
                            console.log(`üì¶ Fetched image via CORS proxy (${(blob.size / 1024).toFixed(2)} KB)`);
                            return blob;
                        } catch (error) {
                            console.warn(`‚ö†Ô∏è Proxy ${i + 1} failed:`, error);
                            if (i === corsProxies.length - 1) {
                                throw new Error(`All CORS proxies failed: ${error.message}`);
                            }
                            // Wait before trying next proxy
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                    }
                    
                    return null;
                }
            });
        };
    </script>
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --secondary-color: #64748b;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --background-color: #f8fafc;
            --surface-color: #ffffff;
            --border-color: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        .sidebar {
            width: 100%;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%);
            color: white;
            padding: 24px;
            box-shadow: var(--shadow-md);
            position: relative;
            z-index: 1000;
            box-sizing: border-box;
            height: fit-content;
            display: inline-block;
        }
        
        /* Custom scrollbar for sidebar */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .header-upload-row {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px 0;
            justify-content: space-between;
        }
        
        .title-upload-container {
            width: 300px;
            min-width: 300px;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding-right: 20px;
        }
        
        .summary-section {
            flex: 1;
            min-width: 0;
            padding-left: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .horizontal-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
            margin: 10px 0;
        }
        
        .sidebar-header {
            text-align: center;
        }
        
        .sidebar-header h1 {
            margin: 0;
            font-size: 22px;
            font-weight: 700;
            letter-spacing: -0.02em;
            line-height: 1.2;
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .sidebar-header p {
            margin: 6px 0 0 0;
            font-size: 13px;
            opacity: 0.85;
            font-weight: 500;
            letter-spacing: 0.01em;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .sidebar-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: flex-start;
        }
        
        .sidebar-section {
            flex: 1;
            min-width: 200px;
        }
        
        .markdown-converter-section {
            background: transparent;
        }
        
        .upload-section {
            background: rgba(255, 255, 255, 0.12);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(24px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            width: 100%;
            transition: all 0.3s ease;
        }
        
        .upload-section:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15), 0 2px 6px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .upload-section h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #ffffff;
            letter-spacing: 0.01em;
        }
        
        .upload-section p {
            margin: 0 0 12px 0;
            font-size: 12px;
            opacity: 0.85;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 400;
        }
        
        .main-content {
            flex: 1;
            padding: 32px;
            background: var(--background-color);
            min-height: auto;
            max-width: 100%;
            overflow-x: hidden;
            box-sizing: border-box;
        }
        
        
        /* Responsive design */
        @media (max-width: 768px) {
            .header-upload-row {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }
            
            .title-upload-container {
                width: 100%;
                min-width: auto;
                max-width: none;
                border-right: none;
                padding-right: 0;
            }
            
            .summary-section {
                padding-left: 0;
                gap: 10px;
            }
            
            .stats-summary {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }
            
            .sidebar-header {
            text-align: center;
            }
            
            .summary-section {
                min-width: auto;
            }
            
            .upload-section {
                min-width: auto;
            }
            
            .sidebar-content {
                flex-direction: column;
            }
            
            .sidebar-section {
                min-width: 100%;
            }
            
            .subject-tabs-sidebar {
                flex-direction: column;
            }
        }
        
        .file-input {
            display: none;
        }
        
        .upload-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
            margin-top: 8px;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3), 0 1px 3px rgba(0, 0, 0, 0.1);
            letter-spacing: 0.02em;
            text-transform: none;
        }
        
        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            background: linear-gradient(135deg, #059669 0%, var(--success-color) 100%);
        }
        
        .upload-btn:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }
        
        
        .sidebar-subjects {
            margin-top: 0;
        }
        
        .subject-tabs-sidebar {
            display: flex;
            flex-direction: row;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .subject-tab-sidebar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            text-align: left;
            width: 100%;
        }
        
        .subject-tab-sidebar:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transform: translateX(5px);
        }
        
        .subject-tab-sidebar.active {
            background: rgba(79, 172, 254, 0.2);
            color: #4facfe;
            border-color: rgba(79, 172, 254, 0.3);
            border-left: 3px solid #4facfe;
        }
        
        .subject-tab-sidebar span:first-child {
            font-size: 16px;
        }
        
        .question-count {
            background: rgba(79, 172, 254, 0.2);
            color: #4facfe;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: auto;
        }
        
        .sidebar-stats {
            padding: 0;
        }
        
        .sidebar-stats h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #ffffff;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            letter-spacing: 0.01em;
        }
        
        .stats-summary {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        
        .stat-label {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .stat-number {
            background: rgba(79, 172, 254, 0.2);
            color: #4facfe;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            min-width: 20px;
            text-align: center;
        }
        
        .sidebar-download {
            margin-top: 0;
        }
        
        .download-buttons {
            display: flex;
            flex-direction: row;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .download-btn, .download-all-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            text-align: center;
            flex: 1;
            min-width: 0;
            justify-content: center;
        }
        
        .download-btn:hover {
            background: rgba(79, 172, 254, 0.1);
            color: #4facfe;
            border-color: rgba(79, 172, 254, 0.3);
            transform: translateY(-2px);
        }
        
        .download-all-btn {
            background: rgba(39, 174, 96, 0.1);
            border-color: rgba(39, 174, 96, 0.2);
            color: #27ae60;
        }
        
        .download-all-btn:hover {
            background: rgba(39, 174, 96, 0.2);
            border-color: rgba(39, 174, 96, 0.4);
            color: #2ecc71;
            transform: translateY(-2px);
        }
        
        .download-icon {
            font-size: 14px;
        }
        
        
        
        .questions-container {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            min-height: auto;
            box-sizing: border-box;
            max-width: 100%;
        }
        
        .questions-grid {
            flex: 1;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        
        .questions-list {
            display: grid;
            grid-template-columns: 150px 2fr 1fr;
            gap: 24px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: visible;
            background: var(--surface-color);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            padding: 24px;
        }
        
        .question-list-sidebar {
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 20px;
            max-height: 70vh;
            overflow-y: auto;
            width: 150px;
            min-width: 150px;
            max-width: 150px;
            box-sizing: border-box;
            box-shadow: var(--shadow-sm);
        }
        
        .question-list-sidebar h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 16px;
            font-weight: 600;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
        }
        
        .question-item {
            display: block;
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 8px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            color: var(--text-primary);
            box-shadow: var(--shadow-sm);
        }
        
        .question-item:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .question-item.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            box-shadow: var(--shadow-md);
        }
        
        .question-item-container {
            margin-bottom: 8px;
        }
        
        .question-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .question-expand-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            padding: 0;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .question-expand-btn:hover {
            background: var(--surface-hover);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }
        
        .question-actions-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            margin-top: 0;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
        }
        
        .question-actions-container.expanded {
            max-height: 100px;
            opacity: 1;
            margin-top: 4px;
        }
        
        .question-action-btn {
            flex: 1;
            padding: 4px 8px;
            font-size: 11px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .question-action-btn.add-btn {
            background: #10b981;
            color: white;
        }
        
        .question-action-btn.add-btn:hover {
            background: #059669;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
        }
        
        .question-action-btn.delete-btn {
            background: #ef4444;
            color: white;
        }
        
        .question-action-btn.delete-btn:hover {
            background: #dc2626;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
        }
        
        .question-action-btn:active {
            transform: translateY(0);
        }
        
        .question-item.manual-edit-needed {
            background: #dc3545 !important;
            border-color: #dc3545 !important;
            color: white !important;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
        }
        
        .question-item.manual-edit-needed:hover {
            background: #c82333 !important;
            border-color: #c82333 !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }
        
        /* Insert question button styling */
        .insert-question-btn {
            display: block;
            width: 100%;
            padding: 8px 16px;
            margin: 4px 0;
            background: #10b981;
            border: 2px dashed #059669;
            border-radius: var(--radius-sm);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            color: white;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
        }
        
        .insert-question-btn:hover {
            background: #059669;
            border-color: #047857;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.4);
        }
        
        .insert-question-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
        }
        
        /* Firebase Directory Selector */
        .firebase-directory-selector {
            background: transparent;
            border: none;
            border-radius: var(--radius-md);
            padding: 16px;
            margin-bottom: 20px;
            box-shadow: none;
        }
        
        .hamburger-menu {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1001;
            padding: 12px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
        }
        
        .hamburger-btn {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: 8px 12px;
            cursor: pointer;
            font-size: 18px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
        }
        
        .hamburger-btn:hover {
            background: var(--surface-hover);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }
        
        .hamburger-btn.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }
        
        .firebase-directory-selector h3 {
            margin: 0 0 12px 0;
            color: white;
            font-size: 16px;
            font-weight: 600;
        }
        
        .year-panel-toggle-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }
        
        .year-panel-toggle-btn:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        .year-panel-toggle-btn.active {
            background: var(--primary-hover);
            box-shadow: var(--shadow-md);
        }
        
        .selection-banner {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            border-radius: var(--radius-md);
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 16px;
            box-shadow: var(--shadow-md);
        }
        
        .selection-banner.show {
            display: flex;
        }
        
        .selection-banner-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        
        .selection-banner-label {
            font-weight: 600;
            opacity: 0.9;
        }
        
        .selection-banner-value {
            font-weight: 500;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: var(--radius-sm);
        }
        
        .selection-banner-divider {
            width: 1px;
            height: 24px;
            background: rgba(255, 255, 255, 0.3);
        }
        
        .selection-banner-close-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 4px 8px;
            border-radius: 50%;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: 8px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            flex-shrink: 0;
        }
        
        .selection-banner-close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }
        
        .selection-banner-close-btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }
        
        /* Progress Bar */
        .firebase-progress-bar {
            height: 4px;
            background: var(--border-color);
            margin: 0 0 20px 0;
            border-radius: 2px;
            overflow: hidden;
            display: none;
            position: relative;
        }
        
        .main-content > .firebase-progress-bar {
            margin-bottom: 0;
        }
        
        .firebase-progress-bar.show {
            display: block;
        }
        
        .firebase-progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 50%, #667eea 100%);
            background-size: 200% 100%;
            width: 0%;
            border-radius: 2px;
            animation: progressAnimation 1.5s ease-in-out infinite;
            transition: width 0.3s ease;
        }
        
        @keyframes progressAnimation {
            0% {
                background-position: 200% 0;
            }
            100% {
                background-position: -200% 0;
            }
        }
        
        .firebase-progress-bar-indeterminate {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 50%, #667eea 100%);
            background-size: 200% 100%;
            width: 30%;
            border-radius: 2px;
            animation: indeterminateProgress 1.5s ease-in-out infinite;
        }
        
        @keyframes indeterminateProgress {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(400%);
            }
        }
        
        .directory-select-row {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .directory-select-row select {
            width: 200px;
            min-width: 200px;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            background: var(--background-color);
            color: var(--text-primary);
            font-size: 14px;
            cursor: pointer;
        }
        
        .directory-select-row button {
            padding: 10px 20px;
            background: #059669;
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .directory-select-row button:hover {
            background: #047857;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        .directory-select-row button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }
        
        #selectYearBtn:hover {
            background: #047857;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        /* Sliding Year Panel */
        .year-panel {
            position: fixed;
            left: -75vw;
            top: 0;
            width: 75vw;
            height: 100vh;
            background: var(--surface-color);
            border-right: 2px solid var(--border-color);
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.1);
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        
        .year-panel.open {
            left: 0;
        }
        
        .year-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }
        
        .year-panel-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
        }
        
        .year-panel-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
        }
        
        .year-panel-close:hover {
            background: var(--border-color);
            color: var(--text-primary);
        }
        
        .year-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .year-item {
            padding: 12px 16px;
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }
        
        .year-item:hover {
            background: #f3f4f6;
            color: var(--text-primary);
            border-color: #d1d5db;
            transform: translateX(4px);
        }
        
        .year-item.active {
            background: #e5e7eb;
            color: var(--text-primary);
            border-color: #d1d5db;
            box-shadow: var(--shadow-md);
        }
        
        .year-item.loading {
            opacity: 0.6;
            cursor: wait;
        }
        
        .year-item-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }
        
        .year-item-name {
            flex: 1;
        }
        
        .year-item-expand {
            font-size: 12px;
            margin-left: 8px;
            transition: transform 0.2s ease;
        }
        
        .year-item.expanded .year-item-expand {
            transform: rotate(90deg);
        }
        
        .year-json-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
            opacity: 0;
            margin-top: 0;
            padding: 0;
            text-align: left;
            width: 100%;
            box-sizing: border-box;
        }
        
        .year-item.expanded .year-json-list {
            max-height: 500px;
            opacity: 1;
            margin-top: 4px;
            padding: 0;
            text-align: left;
        }
        
        .json-file-item {
            padding: 8px 12px 8px 40px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 4px;
            margin-left: 0;
            margin-right: auto;
            text-align: left;
            width: fit-content;
            min-width: 0;
            display: block;
            box-sizing: border-box;
            white-space: nowrap;
            max-width: 100%;
        }
        
        .json-file-item:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            transform: translateX(4px);
        }
        
        .json-file-item.loading {
            opacity: 0.6;
            cursor: wait;
        }
        
        .year-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        .year-panel-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        /* Red label styling for edit areas that need manual editing */
        .manual-edit-label {
            color: #dc3545 !important;
            font-weight: bold !important;
        }
        
        /* Red label for question text */
        .question-label.manual-edit-label {
            color: #dc3545 !important;
            font-weight: bold !important;
        }
        
        /* Red label for solution text */
        .solution-label.manual-edit-label {
            color: #dc3545 !important;
            font-weight: bold !important;
        }
        
        /* Red label for option inputs */
        .option-label.manual-edit-label {
            color: #dc3545 !important;
            font-weight: bold !important;
        }
        
        .question-editor-panel {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 32px;
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: visible;
            box-sizing: border-box;
            width: 100%;
            max-width: 1200px;
            min-width: 0;
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: var(--shadow-sm);
            margin: 0 auto;
        }
        
        .question-render-panel {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 32px;
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: hidden;
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            min-width: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: var(--shadow-sm);
        }
        
        #inlineMathRender, #inlinePhysicsRender, #inlineChemistryRender, #inlineBiologyRender {
            overflow-y: auto;
            max-height: 60vh;
            min-height: 400px;
            padding: 10px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #f8f9fa;
            width: 100%;
        }
        
        .question-render-item {
            width: 100%;
            margin-bottom: 32px;
            padding: 24px;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-lg);
            background: var(--surface-color);
            transition: all 0.3s ease;
        }
        
        .question-render-item.active-question {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.05) 0%, rgba(37, 99, 235, 0.02) 100%);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        .question-render-item h5 {
            margin: 0 0 16px 0;
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 700;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 8px;
        }
        
        .question-render-item.active-question h5 {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .question-render-item .question-text {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 16px;
            color: var(--text-primary);
        }
        
        .question-render-item .options {
            margin: 16px 0;
        }
        
        .question-render-item .option {
            margin: 8px 0;
            padding: 8px 12px;
            background: var(--background-color);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--border-color);
        }
        
        .question-render-item .answer {
            margin: 16px 0;
            padding: 12px 16px;
            background: linear-gradient(135deg, var(--success-color), #059669);
            color: white;
            border-radius: var(--radius-md);
            font-weight: 600;
        }
        
        .question-render-item .solution {
            margin-top: 16px;
            padding: 16px;
            background: var(--background-color);
            border-radius: var(--radius-md);
            border-left: 4px solid var(--primary-color);
        }
        
        .question-render-item .solution strong {
            color: var(--primary-color);
            font-size: 16px;
        }
        
        .question-editor-panel h4,
        .question-render-panel h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 16px;
            font-weight: 600;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
        }
        
        /* JSON Viewer Styles */
        .viewer-toggle {
            display: flex;
            gap: 2px;
            padding: 2px;
            background: var(--background-color);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            justify-content: flex-start;
        }
        
        .inline-panels-header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            padding: 6px 16px;
            background: var(--surface-color);
            border-bottom: 1px solid var(--border-color);
            min-height: 40px;
            gap: 16px;
        }
        
        .inline-panels-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 600;
        }
        
        .viewer-toggle-btn {
            flex: 1;
            padding: 6px 12px;
            border: none;
            border-radius: var(--radius-sm);
            background: transparent;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            white-space: nowrap;
        }
        
        .viewer-toggle-btn.active {
            background: var(--primary-color);
            color: white;
            box-shadow: var(--shadow-sm);
        }
        
        .viewer-toggle-btn:hover:not(.active) {
            background: var(--background-color);
            color: var(--text-primary);
        }
        
        .json-viewer-panel {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 32px;
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: hidden;
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            min-width: 0;
            display: none;
            flex-direction: column;
            position: relative;
            box-shadow: var(--shadow-sm);
        }
        
        .json-viewer-panel.active {
            display: flex;
        }
        
        .json-viewer-panel h4 {
            margin: 0 0 20px 0;
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 700;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 12px;
        }
        
        .json-content {
            background: #1e293b;
            color: #e2e8f0;
            padding: 24px;
            border-radius: var(--radius-md);
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.7;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            border: 1px solid #334155;
            max-height: 70vh;
            overflow-y: auto;
            min-height: 500px;
        }
        
        .json-content::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .json-content::-webkit-scrollbar-track {
            background: #334155;
            border-radius: 4px;
        }
        
        .json-content::-webkit-scrollbar-thumb {
            background: #64748b;
            border-radius: 4px;
        }
        
        .json-content::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        .json-actions {
            margin-top: 16px;
            display: flex;
            gap: 12px;
        }
        
        .json-action-btn {
            padding: 10px 20px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            background: var(--surface-color);
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .json-action-btn:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .json-action-btn.primary {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .json-action-btn.primary:hover {
            background: var(--primary-hover);
        }
        
        .question-edit-item {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .question-edit-item h5 {
            margin: 0 0 20px 0;
            color: #495057;
            font-size: 18px;
            font-weight: 600;
        }
        
        .edit-field {
            margin-bottom: 20px;
            width: 100%;
            box-sizing: border-box;
            max-width: 100%;
            min-width: 0;
            overflow: visible;
        }
        
        .edit-field label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
            text-align: left;
        }
        
        .question-edit-input {
            width: 100%;
            min-height: 180px;
            padding: 16px;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 15px;
            font-family: inherit;
            resize: vertical;
            box-sizing: border-box;
            max-width: 100%;
            overflow-x: hidden;
            word-wrap: break-word;
            background: var(--surface-color);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }
        
        .question-edit-item {
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .edit-field {
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .edit-field textarea,
        .edit-field input {
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .question-edit-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        .option-edit-input {
            width: 100%;
            min-height: 50px;
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 15px;
            font-family: inherit;
            box-sizing: border-box;
            max-width: 100%;
            overflow-x: hidden;
            word-wrap: break-word;
            resize: vertical;
            background: var(--surface-color);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }
        
        .option-edit-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        .solution-edit-input {
            width: 100%;
            min-height: 150px;
            padding: 16px;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 15px;
            font-family: inherit;
            resize: vertical;
            box-sizing: border-box;
            max-width: 100%;
            overflow-x: hidden;
            word-wrap: break-word;
            background: var(--surface-color);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }
        
        .solution-edit-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        /* AI Solution Analyzer Styles */
        .ai-analyzer-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .ai-analyzer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
        }
        
        .ai-analyzer-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .ai-status {
            font-size: 11px;
            margin-top: 8px;
            padding: 6px 10px;
            border-radius: 4px;
            display: none;
        }
        
        .ai-status.success {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            display: block;
        }
        
        .ai-status.error {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            display: block;
        }
        
        .ai-status.loading {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            display: block;
        }
        
        .ai-batch-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
        }
        
        .ai-batch-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }
        
        .ai-batch-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .upload-json-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
        }
        
        .upload-json-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 172, 254, 0.4);
        }
        
        .upload-json-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Upload Dialog Modal Styles */
        .upload-dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .upload-dialog-overlay.show {
            display: flex;
        }
        
        .upload-dialog {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .upload-dialog-content {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .upload-dialog-field {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .upload-dialog-field label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .upload-dialog-field select,
        .upload-dialog-field input {
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 14px;
        }
        
        .upload-dialog-field select:focus,
        .upload-dialog-field input:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        .upload-dialog-json-preview {
            background: #f8f9fa;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .upload-dialog-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        .upload-dialog-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upload-dialog-btn-primary {
            background: #059669;
            color: white;
        }
        
        .upload-dialog-btn-primary:hover {
            background: #047857;
        }
        
        .upload-dialog-btn-secondary {
            background: #e5e7eb;
            color: var(--text-primary);
        }
        
        .upload-dialog-btn-secondary:hover {
            background: #d1d5db;
        }
        
        /* Math Table Styles - for converted markdown tables */
        .math-table {
            border-collapse: collapse;
            margin: 16px 0;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            width: auto;
            max-width: 100%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .math-table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .math-table th,
        .math-table td {
            padding: 12px 16px;
            text-align: center;
            border: 1px solid #e5e7eb;
        }
        
        .math-table th {
            font-weight: 600;
            font-size: 14px;
        }
        
        .math-table td {
            font-size: 14px;
            background: white;
        }
        
        .math-table tbody tr:nth-child(even) td {
            background: #f9fafb;
        }
        
        .math-table tbody tr:hover td {
            background: #f3f4f6;
        }
        
        .answer-edit-select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 15px;
            font-family: inherit;
            background: var(--surface-color);
            color: var(--text-primary);
            box-sizing: border-box;
            max-width: 100%;
            transition: all 0.3s ease;
        }
        
        .answer-edit-select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        .option-edit-item {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
            width: 100%;
            box-sizing: border-box;
            max-width: 100%;
        }
        
        .option-edit-item label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
            text-align: left !important;
            width: 100%;
            text-align-last: left;
        }
        
        .options-edit-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
            width: 100%;
        }
        
        .render-panel {
            flex: 1;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            position: relative;
            box-sizing: border-box;
            max-width: 100%;
        }
        
        .render-label {
            position: absolute;
            top: -12px;
            right: 0px;
            background: white;
            padding: 2px 12px;
            font-size: 12px;
            color: #666;
            font-weight: 500;
            z-index: 1;
            white-space: nowrap;
        }
        
        .render-header {
            display: none;
        }
        
        .question-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 150px;
            max-height: 250px;
            margin-bottom: 15px;
            overflow-y: auto;
            box-sizing: border-box;
        }
        
        .question-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            border-color: #4facfe;
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .question-number {
            background: #4facfe;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
        }
        
        .subject-selector {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
        }
        
        .question-text {
            margin-bottom: 10px;
            line-height: 1.4;
            color: #333;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .question-options {
            margin-bottom: 10px;
            max-height: 80px;
            overflow-y: auto;
        }
        
        .option {
            margin: 3px 0;
            padding: 3px 8px;
            background: #f8f9fa;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .answer {
            font-weight: bold;
            color: #28a745;
            margin-top: 5px;
        }
        
        .actions {
            text-align: center;
            margin-top: 30px;
        }
        
        .btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 10px;
        }
        
        .btn:hover {
            background: #218838;
        }
        
        .btn-secondary {
            background: #6c757d;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
        }
        
        .subject-assignments {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .subject-group {
            margin: 10px 0;
        }
        
        .subject-title {
            font-weight: bold;
            color: #4facfe;
            margin-bottom: 5px;
        }
        
        .question-list {
            color: #666;
            font-size: 14px;
        }
        
        
        .subject-questions {
            display: none;
        }
        
        .subject-questions.active {
            display: block;
        }
        
        .subject-view {
            display: none;
        }
        
        /* Subject Tabs Container */
        .subject-tabs-container {
            display: flex;
            background: rgba(79, 172, 254, 0.1);
            border-radius: 8px;
            padding: 4px;
            margin: 20px 0;
            border: 1px solid rgba(79, 172, 254, 0.2);
            box-shadow: 0 2px 8px rgba(79, 172, 254, 0.1);
        }
        
        .subject-tab {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: transparent;
            border: none;
            border-radius: 6px;
            color: rgba(79, 172, 254, 0.7);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
            flex: 1;
            justify-content: center;
            position: relative;
        }
        
        .subject-tab:hover {
            background: rgba(79, 172, 254, 0.1);
            color: #4facfe;
        }
        
        .subject-tab.active {
            background: rgba(79, 172, 254, 0.2);
            color: #4facfe;
            font-weight: 600;
        }
        
        .subject-tab span:first-child {
            font-size: 16px;
        }
        
        .subject-tab .question-count {
            background: rgba(79, 172, 254, 0.2);
            color: #4facfe;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }
        
        .subject-tab.active .question-count {
            background: rgba(79, 172, 254, 0.3);
            color: #4facfe;
        }
        
        /* Hide Biology tab when loading from Firebase */
        .subject-tab.biology-hidden,
        #tab-Biology.biology-hidden {
            display: none !important;
        }
        .subject-view.active {
            display: block;
        }
        
        .split-container {
            display: flex;
            gap: 20px;
            height: 70vh;
            margin-top: 20px;
        }
        
        .json-panel {
            flex: 1;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
        }
        
        .render-panel {
            flex: 1;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            position: relative;
            box-sizing: border-box;
        }
        
        .render-label {
            position: absolute;
            top: -12px;
            right: 0px;
            background: white;
            padding: 2px 12px;
            font-size: 12px;
            color: #666;
            font-weight: 500;
            z-index: 1;
            white-space: nowrap;
        }
        
        .render-header {
            display: none;
        }
        
        .json-header {
            background: #4facfe;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .render-header {
            background: #28a745;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .question-render {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .question-render h4 {
            color: #4facfe;
            margin-bottom: 10px;
        }
        
        .options-render {
            margin: 10px 0;
        }
        
        .option-render {
            margin: 5px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .answer-render {
            color: #28a745;
            font-weight: bold;
            margin-top: 10px;
        }
        
        .solution-render {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            color: #495057;
            line-height: 1.6;
        }
        
        .solution {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            color: #495057;
            line-height: 1.4;
            font-size: 14px;
        }
        
        .json-display {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            max-height: calc(100vh - 300px);
            overflow-y: auto;
            box-sizing: border-box;
            position: relative;
        }
        
        .json-display h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 16px;
        }
        
        .json-display pre {
            background: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            margin: 0;
            overflow-x: auto;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.3;
            max-height: calc(100vh - 200px);
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .json-display code {
            color: #212529;
            font-family: 'Courier New', monospace;
        }
        
        .json-container {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .metadata-editor {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: var(--shadow-sm);
        }
        
        .metadata-editor h2 {
            margin: 0 0 20px 0;
            color: var(--text-primary);
            font-size: 20px;
            font-weight: 700;
        }
        
        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .field {
            flex: 1;
            min-width: 200px;
        }
        
        .field label {
            display: block;
            margin-bottom: 4px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .field input, .field select {
            margin: 4px 0;
            padding: 6px;
            width: 100%;
            box-sizing: border-box;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            background: var(--surface-color);
            color: var(--text-primary);
        }
        
        .field input:focus, .field select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        .field input[readonly] {
            background: var(--background-color);
            color: var(--text-secondary);
            cursor: not-allowed;
        }
        
        /* Day and Shift field - reduced width and only for JEE Main */
        #dayAndShift,
        #dayAndShift-physics,
        #dayAndShift-chemistry,
        #dayAndShift-biology {
            width: 250px;
            max-width: 250px;
        }
        
        .day-and-shift-hidden {
            display: none !important;
        }
        
        .metadata-editor > label {
            display: block;
            margin-bottom: 4px;
            font-weight: 600;
            color: var(--text-primary);
            margin-top: 16px;
        }
        
        .metadata-editor > input {
            margin: 4px 0;
            padding: 6px;
            width: 100%;
            box-sizing: border-box;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            background: var(--surface-color);
            color: var(--text-primary);
        }
        
        .metadata-editor > input:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        /* Side by side layout for Tutorial Title and Authority Exam ID */
        .metadata-editor .row:last-of-type {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .metadata-editor .row:last-of-type .field {
            flex: 0 0 auto;
            width: 300px;
            max-width: 300px;
        }
        
        .form-input:hover {
            border-color: #adb5bd;
        }
        
        .question-actions {
            display: flex;
            gap: 10px;
        }
        
        .edit-btn {
            background: #4facfe;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }
        
        .edit-btn:hover {
            background: #00f2fe;
        }
        
        .question-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .question-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            box-sizing: border-box;
        }
        
        .question-textarea:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }
        
        .option-input {
            flex: 1;
            padding: 5px 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            margin-left: 5px;
        }
        
        .option-input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 2px rgba(79, 172, 254, 0.1);
        }
        
        .answer-section, .solution-section {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .answer-section label, .solution-section label {
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }
        
        .answer-select {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }
        
        .answer-select:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }
        
        .solution-textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            box-sizing: border-box;
        }
        
        .solution-textarea:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }
        
        
        
        .question-edit-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .question-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #4facfe;
        }
        
        .question-edit-number {
            font-size: 18px;
            font-weight: bold;
            color: #4facfe;
        }
        
        .question-edit-fields {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .edit-field-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .edit-field-group label {
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }
        
        .edit-field-group input,
        .edit-field-group textarea,
        .edit-field-group select {
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
        }
        
        .edit-field-group input:focus,
        .edit-field-group textarea:focus,
        .edit-field-group select:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }
        
        .edit-field-group textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .options-edit-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .option-edit-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        
        .inline-edit-interface {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        
        
        .inline-panels-header {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }
        
        .inline-panels-header h3 {
            margin: 0;
            color: #495057;
            font-size: 18px;
            font-weight: 600;
        }
        
        .edit-interface-content {
            display: flex;
            min-height: auto;
            gap: 20px;
        }
        
        .edit-fields-container {
            flex: 1;
            border-right: 1px solid #dee2e6;
            padding: 20px;
        }
        
        .inline-render-view {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .inline-render-view h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 18px;
        }
        
        .edit-questions-list {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .tab-controls {
            display: flex;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 20px;
            width: fit-content;
        }
        
        .tab-segment {
            padding: 8px 20px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .tab-segment:first-child {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            border-right: none;
        }
        
        .tab-segment:last-child {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }
        
        .tab-segment.active {
            background: #4facfe;
            color: white;
            border-color: #4facfe;
            box-shadow: 0 2px 4px rgba(79, 172, 254, 0.2);
        }
        
        .tab-segment:hover:not(.active) {
            background: #e9ecef;
            color: #495057;
        }
        
        .json-view-container {
            flex: 1;
            border-right: 1px solid #dee2e6;
            padding: 20px;
        }
        
        .json-view-container .json-display {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            height: 100%;
        }
        
        .json-view-container .json-display h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 16px;
        }
        
        .json-textarea {
            width: 100%;
            min-height: 300px;
            background: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            resize: none;
            white-space: pre-wrap;
            overflow-x: hidden;
            overflow-y: auto;
            word-wrap: break-word;
            box-sizing: border-box;
        }
        
        .json-textarea:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }
        
        /* Image Upload Styles */
        .image-upload-area {
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            background: #f8f9fa;
            margin: 10px 0;
            transition: all 0.3s ease;
            cursor: pointer;
            width: 60%;
            box-sizing: border-box;
            max-width: 60%;
            align-self: flex-start;
        }
        
        .image-upload-area:hover {
            border-color: #4facfe;
            background: #e3f2fd;
        }
        
        .image-upload-area.dragover {
            border-color: #4facfe;
            background: #e3f2fd;
            transform: scale(1.02);
        }
        
        .image-upload-icon {
            font-size: 24px;
            color: #6c757d;
            margin-bottom: 10px;
        }
        
        .image-upload-text {
            color: #6c757d;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .image-upload-hint {
            color: #adb5bd;
            font-size: 12px;
        }
        
        .uploaded-images {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .uploaded-image {
            position: relative;
            width: 80px;
            height: 80px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e9ecef;
        }
        
        .uploaded-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .upload-checkmark {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(16, 185, 129, 0.9);
            color: white;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            animation: checkmarkPulse 0.3s ease-in-out;
        }
        
        @keyframes checkmarkPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .upload-image-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(37, 99, 235, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background 0.2s;
        }
        
        .upload-image-btn:hover {
            background: rgba(37, 99, 235, 1);
        }
        
        .upload-image-btn:active {
            transform: scale(0.95);
        }
        
        .upload-error {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            animation: checkmarkPulse 0.3s ease-in-out;
        }
        
        .upload-error:hover {
            background: rgba(239, 68, 68, 1);
        }
        
        .upload-error::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            right: 0;
            margin-bottom: 5px;
            padding: 8px 12px;
            background: rgba(239, 68, 68, 0.95);
            color: white;
            border-radius: 4px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            font-size: 12px;
        }
        
        .upload-error:hover::after {
            opacity: 1;
        }
        
        .remove-image {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Progress Bar Styles */
        .upload-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 12px;
            color: #6c757d;
            min-width: 50px;
            text-align: right;
        }

        .upload-status {
            font-size: 12px;
            font-weight: 500;
        }

        .upload-status.uploading {
            color: #007bff;
        }

        .upload-status.success {
            color: #28a745;
        }

        .upload-status.error {
            color: #dc3545;
        }
        
        .option-image-upload {
            margin-top: 8px;
            width: 100%;
            box-sizing: border-box;
            max-width: 100%;
        }
        
        .image-upload-section {
            margin-bottom: 20px;
            width: 100%;
        }
        
        .image-upload-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
            text-align: left;
        }
        
        .image-upload-area {
            width: 100%;
            min-height: 80px;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
            box-sizing: border-box;
        }
        
        .option-image-upload .image-upload-area {
            padding: 15px;
            margin: 0;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .option-image-upload .image-upload-icon {
            font-size: 16px;
            margin-bottom: 4px;
        }
        
        .option-image-upload .image-upload-text {
            font-size: 11px;
            margin-bottom: 2px;
        }
        
        .option-image-upload .image-upload-hint {
            font-size: 10px;
        }
        
        .option-image-upload .uploaded-image {
            width: 50px;
            height: 50px;
        }
        
        .option-edit-item {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }
        
        
        .option-edit-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .options-edit-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <!-- Left Sidebar -->
    <div class="sidebar">
        <!-- Side by Side Container -->
        <div style="display: flex; gap: 50px; align-items: flex-start; height: fit-content;">
            <!-- Firebase Directory Selector in Left Sidebar -->
            <div class="firebase-directory-selector" style="flex: 1;">
                <h3>üìÅ Select Firebase Directory</h3>
                <div class="directory-select-row">
                    <select id="firebaseDirectorySelect">
                        <option value="">-- Select Directory --</option>
                        <option value="KCET_JSON">KCET_JSON</option>
                        <option value="JEE_MAIN">JEE_MAIN</option>
                        <option value="questions">questions</option>
                    </select>
                    <button id="loadDirectoryBtn" onclick="loadFirebaseDirectory()" disabled>Load Directory</button>
                </div>
                <button id="selectYearBtn" onclick="toggleYearPanel()" style="width: fit-content; margin-top: 12px; padding: 10px 20px; background: #059669; color: white; border: none; border-radius: var(--radius-sm); cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    Select year and paper
                </button>
            </div>
            
            <!-- Markdown to Json Converter Section (Right Side of Select Firebase Directory) -->
            <div class="markdown-converter-section" style="flex: 1;">
                <div class="sidebar-header">
                    <h1>üìö Markdown to Json Converter</h1>
                    <p>Professional Question Management</p>
                </div>
                
                <div class="upload-section" style="margin-top: 20px;">
                    <h3>üìÅ Upload File</h3>
                    <p>Select your markdown file or JSON folder containing questions</p>
                    <input type="file" id="fileInput" class="file-input" accept=".md,.txt">
                    <input type="file" id="jsonFolderInput" class="file-input" accept=".json" multiple style="display: none;">
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="upload-btn" onclick="document.getElementById('fileInput').click()" style="flex: 1;">
                            üìÑ Choose MD File
                        </button>
                        <button class="upload-btn" onclick="document.getElementById('jsonFolderInput').click()" style="flex: 1; background: #059669;">
                            üìÇ Load JSON Folder
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
        
        <!-- Main Content Area -->
        <div class="main-content">
        
        <!-- Progress Bar -->
        <div class="firebase-progress-bar" id="firebaseProgressBar">
            <div class="firebase-progress-bar-indeterminate"></div>
        </div>
        
        
        
        <!-- Selection Banner -->
        <div class="selection-banner" id="selectionBanner">
            <div class="selection-banner-item">
                <span class="selection-banner-label">Year:</span>
                <span class="selection-banner-value" id="selectedYearDisplay">--</span>
            </div>
            <div class="selection-banner-divider"></div>
            <div class="selection-banner-item">
                <span class="selection-banner-label">JSON File:</span>
                <span class="selection-banner-value" id="selectedJsonDisplay">--</span>
                <button class="selection-banner-close-btn" onclick="unloadJSON()" title="Unload JSON">
                    ‚úï
                </button>
            </div>
        </div>
        
        <!-- Year Panel (Sliding from left) -->
        <div class="year-panel-overlay" id="yearPanelOverlay" onclick="closeYearPanel()"></div>
        <div class="year-panel" id="yearPanel">
            <div class="year-panel-header">
                <h3 id="yearPanelTitle">Select Year</h3>
                <button class="year-panel-close" onclick="closeYearPanel()">√ó</button>
            </div>
            <div class="year-list" id="yearList">
                <!-- Years will be populated here -->
            </div>
        </div>

        <!-- Subject Tabs -->
        <div class="subject-tabs-container" id="subjectTabsContainer" style="display: none;">
            <button class="subject-tab active" onclick="showSubject('Mathematics')" id="tab-Mathematics">
                <span>üî¢</span>
                <span>Mathematics</span>
                <span class="question-count" id="count-Mathematics">0</span>
            </button>
            <button class="subject-tab" onclick="showSubject('Physics')" id="tab-Physics">
                <span>‚öõÔ∏è</span>
                <span>Physics</span>
                <span class="question-count" id="count-Physics">0</span>
            </button>
            <button class="subject-tab" onclick="showSubject('Chemistry')" id="tab-Chemistry">
                <span>üß™</span>
                <span>Chemistry</span>
                <span class="question-count" id="count-Chemistry">0</span>
            </button>
            <button class="subject-tab" onclick="showSubject('Biology')" id="tab-Biology">
                <span>üß¨</span>
                <span>Biology</span>
                <span class="question-count" id="count-Biology">0</span>
            </button>
        </div>
        

        
        <div id="questionsContainer" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h3>üìã JSON Viewer</h3>
                <h3>üìñ Render View</h3>
            </div>
            <div class="questions-container">
                <div class="questions-grid">
                    <div class="questions-list" id="questionsList">
                        <!-- Questions will be populated here -->
                    </div>
                </div>
                <div class="render-panel">
                    <div id="allQuestionsRender">
                        <p>Select a question to view its rendered content with MathJax.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Subject Views -->
        <div id="subjectView-Mathematics" class="subject-view">
            
            <!-- Metadata Editor Section -->
            <div class="metadata-editor">
                <h2>Tutorial JSON Builder</h2>
                <div class="row">
                    <div class="field">
                        <label>State:</label>
                        <select id="state">
                            <option value="Karnataka" selected>Karnataka</option>
                            <option value="Maharashtra">Maharashtra</option>
                            <option value="Tamil Nadu">Tamil Nadu</option>
                            <option value="Center">Center</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Board:</label>
                        <select id="board" onchange="setConductedByFromBoard(this.value, 'conductedBy')">
                            <option value="KCET" selected>KCET</option>
                            <option value="NEET">NEET</option>
                            <option value="JEE Main">JEE Main</option>
                            <option value="JEE Advanced">JEE Advanced</option>
                            <option value="MH-CET">MH-CET</option>
                            <option value="TN-Board">TN-Board</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Conducted By:</label>
                        <select id="conductedBy">
                            <option value="">Select</option>
                            <option value="KCET ‚Äî Karnataka Examinations Authority (KEA)">KCET ‚Äî Karnataka Examinations Authority (KEA)</option>
                            <option value="JEE Main ‚Äî National Testing Agency (NTA)">JEE Main ‚Äî National Testing Agency (NTA)</option>
                            <option value="JEE Advanced ‚Äî Indian Institutes of Technology (IITs)">JEE Advanced ‚Äî Indian Institutes of Technology (IITs)</option>
                            <option value="NEET ‚Äî National Testing Agency (NTA)">NEET ‚Äî National Testing Agency (NTA)</option>
                        </select>
                    </div>
                    <div class="field">
                        <label>Year:</label>
                        <select id="year">
                            <option value="2025" selected>2025</option>
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                            <option value="2022">2022</option>
                            <option value="2021">2021</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Subject:</label>
                        <select id="subject">
                            <option value="Mathematics" selected>Mathematics</option>
                            <option value="Physics">Physics</option>
                            <option value="Chemistry">Chemistry</option>
                            <option value="Biology">Biology</option>
                        </select>
                    </div>
                    <div class="field">
                        <label>Tutorial ID:</label>
                        <input type="text" id="tutorialId" value="KCET_2025_Mathematics" readonly/>
                        </div>
                    <div class="field">
                        <label>Day and Shift:</label>
                        <input type="text" id="dayAndShift" value="2 April 2025 Shift - 2" placeholder="e.g., 2 April 2025 Shift - 2"/>
                        </div>
                    </div>
                <div class="row">
                    <div class="field">
                        <label>Tutorial Title:</label>
                        <input type="text" id="tutorialTitle" value="KCET 2025 Mathematics"/>
                        </div>
                    <div class="field">
                        <label>Authority Exam ID:</label>
                        <input type="text" id="authorityExamId" value="kar_kect"/>
                    </div>
                </div>
            </div>
            
            
            <!-- Always show edit interface for Mathematics -->
            <div id="inlineEditInterface-Mathematics" class="inline-edit-interface">
                <div class="inline-panels-header">
                    <!-- Viewer Toggle -->
                    <div class="viewer-toggle" id="viewerToggle-Mathematics" style="display: none;">
                        <button class="viewer-toggle-btn active" onclick="switchViewer('Mathematics', 'editor')">‚úèÔ∏è Edit</button>
                        <button class="viewer-toggle-btn" onclick="switchViewer('Mathematics', 'json')">üìÑ JSON Viewer</button>
                        <button class="viewer-toggle-btn" onclick="switchViewer('Mathematics', 'preview')">üëÅÔ∏è Live Preview</button>
                        <button class="ai-batch-btn" onclick="batchAnalyzeAllSolutions('Mathematics')">
                            ü§ñ Batch Analyzer
                        </button>
                        <button class="upload-json-btn" onclick="openUploadDialog('Mathematics')">
                            üì§ Upload
                        </button>
                    </div>
                </div>
                <div class="edit-interface-content">
                    <div class="question-list-sidebar" id="questionList-Mathematics">
                        <h4>üìã Questions</h4>
                        <!-- Question list will be populated here -->
                    </div>
                    
                    <!-- Question Editor Panel -->
                    <div class="question-editor-panel" id="questionEditor-Mathematics" style="display: none;">
                        <h4>‚úèÔ∏è Question Editor</h4>
                        <div id="editQuestionsList-Mathematics">
                            <!-- Editable question fields will be populated here -->
                        </div>
                    </div>
                    
                    <!-- JSON Viewer Panel -->
                    <div class="json-viewer-panel" id="jsonViewer-Mathematics" style="display: none;">
                        <h4>üìÑ JSON Data Structure</h4>
                        <div class="json-content" id="jsonContent-Mathematics">
                            <!-- JSON content will be populated here -->
                        </div>
                    </div>
                    
                    <div class="question-render-panel" id="questionRender-Mathematics" style="display: none;">
                        <h4>üìñ Live Preview</h4>
                        <div id="inlineMathRender">
                            <!-- Live render view will be shown here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="subjectView-Physics" class="subject-view">
            
            <!-- Metadata Editor Section -->
            <div class="metadata-editor">
                <h2>Tutorial JSON Builder</h2>
                <div class="row">
                    <div class="field">
                        <label>State:</label>
                        <select id="state-physics">
                            <option value="Karnataka" selected>Karnataka</option>
                            <option value="Maharashtra">Maharashtra</option>
                            <option value="Tamil Nadu">Tamil Nadu</option>
                            <option value="Center">Center</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Board:</label>
                        <select id="board-physics" onchange="setConductedByFromBoard(this.value, 'conductedBy-physics')">
                            <option value="KCET" selected>KCET</option>
                            <option value="NEET">NEET</option>
                            <option value="JEE Main">JEE Main</option>
                            <option value="JEE Advanced">JEE Advanced</option>
                            <option value="MH-CET">MH-CET</option>
                            <option value="TN-Board">TN-Board</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Conducted By:</label>
                        <select id="conductedBy-physics">
                            <option value="">Select</option>
                            <option value="KCET ‚Äî Karnataka Examinations Authority (KEA)">KCET ‚Äî Karnataka Examinations Authority (KEA)</option>
                            <option value="JEE Main ‚Äî National Testing Agency (NTA)">JEE Main ‚Äî National Testing Agency (NTA)</option>
                            <option value="JEE Advanced ‚Äî Indian Institutes of Technology (IITs)">JEE Advanced ‚Äî Indian Institutes of Technology (IITs)</option>
                            <option value="NEET ‚Äî National Testing Agency (NTA)">NEET ‚Äî National Testing Agency (NTA)</option>
                        </select>
                    </div>
                    <div class="field">
                        <label>Year:</label>
                        <select id="year-physics">
                            <option value="2025" selected>2025</option>
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                            <option value="2022">2022</option>
                            <option value="2021">2021</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Subject:</label>
                        <select id="subject-physics">
                            <option value="Mathematics">Mathematics</option>
                            <option value="Physics" selected>Physics</option>
                            <option value="Chemistry">Chemistry</option>
                            <option value="Biology">Biology</option>
                        </select>
                    </div>
                    <div class="field">
                        <label>Tutorial ID:</label>
                        <input type="text" id="tutorialId-physics" value="KCET_2025_Physics" readonly/>
                        </div>
                    <div class="field">
                        <label>Day and Shift:</label>
                        <input type="text" id="dayAndShift-physics" value="2 April 2025 Shift - 2" placeholder="e.g., 2 April 2025 Shift - 2"/>
                        </div>
                    </div>
                <div class="row">
                    <div class="field">
                        <label>Tutorial Title:</label>
                        <input type="text" id="tutorialTitle-physics" value="KCET 2025 Physics"/>
                        </div>
                    <div class="field">
                        <label>Authority Exam ID:</label>
                        <input type="text" id="authorityExamId-physics" value="kar_kect"/>
                    </div>
                </div>
            </div>
            
            
            <!-- Always show edit interface for Physics -->
            <div id="inlineEditInterface-Physics" class="inline-edit-interface">
                <div class="inline-panels-header">
                    <!-- Viewer Toggle -->
                    <div class="viewer-toggle" id="viewerToggle-Physics" style="display: none;">
                        <button class="viewer-toggle-btn active" onclick="switchViewer('Physics', 'editor')">‚úèÔ∏è Edit</button>
                        <button class="viewer-toggle-btn" onclick="switchViewer('Physics', 'json')">üìÑ JSON Viewer</button>
                        <button class="viewer-toggle-btn" onclick="switchViewer('Physics', 'preview')">üëÅÔ∏è Live Preview</button>
                        <button class="ai-batch-btn" onclick="batchAnalyzeAllSolutions('Physics')">
                            ü§ñ Batch Analyzer
                        </button>
                        <button class="upload-json-btn" onclick="openUploadDialog('Physics')">
                            üì§ Upload
                        </button>
                    </div>
                </div>
                <div class="edit-interface-content">
                    <div class="question-list-sidebar" id="questionList-Physics">
                        <h4>üìã Questions</h4>
                        <!-- Question list will be populated here -->
                    </div>
                    
                    <!-- Question Editor Panel -->
                    <div class="question-editor-panel" id="questionEditor-Physics" style="display: none;">
                        <h4>‚úèÔ∏è Question Editor</h4>
                        <div id="editQuestionsList-Physics">
                            <!-- Editable question fields will be populated here -->
                        </div>
                    </div>
                    
                    <!-- JSON Viewer Panel -->
                    <div class="json-viewer-panel" id="jsonViewer-Physics" style="display: none;">
                        <h4>üìÑ JSON Data Structure</h4>
                        <div class="json-content" id="jsonContent-Physics">
                            <!-- JSON content will be populated here -->
                        </div>
                    </div>
                    
                    <div class="question-render-panel" id="questionRender-Physics" style="display: none;">
                        <h4>üìñ Live Preview</h4>
                        <div id="inlinePhysicsRender">
                            <!-- Live render view will be shown here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="subjectView-Chemistry" class="subject-view">
            
            <!-- Metadata Editor Section -->
            <div class="metadata-editor">
                <h2>Tutorial JSON Builder</h2>
                <div class="row">
                    <div class="field">
                        <label>State:</label>
                        <select id="state-chemistry">
                            <option value="Karnataka" selected>Karnataka</option>
                            <option value="Maharashtra">Maharashtra</option>
                            <option value="Tamil Nadu">Tamil Nadu</option>
                            <option value="Center">Center</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Board:</label>
                        <select id="board-chemistry" onchange="setConductedByFromBoard(this.value, 'conductedBy-chemistry')">
                            <option value="KCET" selected>KCET</option>
                            <option value="NEET">NEET</option>
                            <option value="JEE Main">JEE Main</option>
                            <option value="JEE Advanced">JEE Advanced</option>
                            <option value="MH-CET">MH-CET</option>
                            <option value="TN-Board">TN-Board</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Conducted By:</label>
                        <select id="conductedBy-chemistry">
                            <option value="">Select</option>
                            <option value="KCET ‚Äî Karnataka Examinations Authority (KEA)">KCET ‚Äî Karnataka Examinations Authority (KEA)</option>
                            <option value="JEE Main ‚Äî National Testing Agency (NTA)">JEE Main ‚Äî National Testing Agency (NTA)</option>
                            <option value="JEE Advanced ‚Äî Indian Institutes of Technology (IITs)">JEE Advanced ‚Äî Indian Institutes of Technology (IITs)</option>
                            <option value="NEET ‚Äî National Testing Agency (NTA)">NEET ‚Äî National Testing Agency (NTA)</option>
                        </select>
                    </div>
                    <div class="field">
                        <label>Year:</label>
                        <select id="year-chemistry">
                            <option value="2025" selected>2025</option>
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                            <option value="2022">2022</option>
                            <option value="2021">2021</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Subject:</label>
                        <select id="subject-chemistry">
                            <option value="Mathematics">Mathematics</option>
                            <option value="Physics">Physics</option>
                            <option value="Chemistry" selected>Chemistry</option>
                            <option value="Biology">Biology</option>
                        </select>
                    </div>
                    <div class="field">
                        <label>Tutorial ID:</label>
                        <input type="text" id="tutorialId-chemistry" value="KCET_2025_Chemistry" readonly/>
                        </div>
                    <div class="field">
                        <label>Day and Shift:</label>
                        <input type="text" id="dayAndShift-chemistry" value="2 April 2025 Shift - 2" placeholder="e.g., 2 April 2025 Shift - 2"/>
                        </div>
                    </div>
                <div class="row">
                    <div class="field">
                        <label>Tutorial Title:</label>
                        <input type="text" id="tutorialTitle-chemistry" value="KCET 2025 Chemistry"/>
                        </div>
                    <div class="field">
                        <label>Authority Exam ID:</label>
                        <input type="text" id="authorityExamId-chemistry" value="kar_kect"/>
                    </div>
                </div>
            </div>
            
            
            <!-- Always show edit interface for Chemistry -->
            <div id="inlineEditInterface-Chemistry" class="inline-edit-interface">
                <div class="inline-panels-header">
                    <!-- Viewer Toggle -->
                    <div class="viewer-toggle" id="viewerToggle-Chemistry" style="display: none;">
                        <button class="viewer-toggle-btn active" onclick="switchViewer('Chemistry', 'editor')">‚úèÔ∏è Edit</button>
                        <button class="viewer-toggle-btn" onclick="switchViewer('Chemistry', 'json')">üìÑ JSON Viewer</button>
                        <button class="viewer-toggle-btn" onclick="switchViewer('Chemistry', 'preview')">üëÅÔ∏è Live Preview</button>
                        <button class="ai-batch-btn" onclick="batchAnalyzeAllSolutions('Chemistry')">
                            ü§ñ Batch Analyzer
                        </button>
                        <button class="upload-json-btn" onclick="openUploadDialog('Chemistry')">
                            üì§ Upload
                        </button>
                    </div>
                </div>
                <div class="edit-interface-content">
                    <div class="question-list-sidebar" id="questionList-Chemistry">
                        <h4>üìã Questions</h4>
                        <!-- Question list will be populated here -->
                    </div>
                    
                    <!-- Question Editor Panel -->
                    <div class="question-editor-panel" id="questionEditor-Chemistry" style="display: none;">
                        <h4>‚úèÔ∏è Question Editor</h4>
                        <div id="editQuestionsList-Chemistry">
                            <!-- Editable question fields will be populated here -->
                        </div>
                    </div>
                    
                    <!-- JSON Viewer Panel -->
                    <div class="json-viewer-panel" id="jsonViewer-Chemistry" style="display: none;">
                        <h4>üìÑ JSON Data Structure</h4>
                        <div class="json-content" id="jsonContent-Chemistry">
                            <!-- JSON content will be populated here -->
                        </div>
                    </div>
                    
                    <div class="question-render-panel" id="questionRender-Chemistry" style="display: none;">
                        <h4>üìñ Live Preview</h4>
                        <div id="inlineChemistryRender">
                            <!-- Live render view will be shown here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="subjectView-Biology" class="subject-view">
            
            <!-- Metadata Editor Section -->
            <div class="metadata-editor">
                <h2>Tutorial JSON Builder</h2>
                <div class="row">
                    <div class="field">
                        <label>State:</label>
                        <select id="state-biology">
                            <option value="Karnataka" selected>Karnataka</option>
                            <option value="Maharashtra">Maharashtra</option>
                            <option value="Tamil Nadu">Tamil Nadu</option>
                            <option value="Center">Center</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Board:</label>
                        <select id="board-biology" onchange="setConductedByFromBoard(this.value, 'conductedBy-biology')">
                            <option value="KCET" selected>KCET</option>
                            <option value="NEET">NEET</option>
                            <option value="JEE Main">JEE Main</option>
                            <option value="JEE Advanced">JEE Advanced</option>
                            <option value="MH-CET">MH-CET</option>
                            <option value="TN-Board">TN-Board</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Conducted By:</label>
                        <select id="conductedBy-biology">
                            <option value="">Select</option>
                            <option value="KCET ‚Äî Karnataka Examinations Authority (KEA)">KCET ‚Äî Karnataka Examinations Authority (KEA)</option>
                            <option value="JEE Main ‚Äî National Testing Agency (NTA)">JEE Main ‚Äî National Testing Agency (NTA)</option>
                            <option value="JEE Advanced ‚Äî Indian Institutes of Technology (IITs)">JEE Advanced ‚Äî Indian Institutes of Technology (IITs)</option>
                            <option value="NEET ‚Äî National Testing Agency (NTA)">NEET ‚Äî National Testing Agency (NTA)</option>
                        </select>
                    </div>
                    <div class="field">
                        <label>Year:</label>
                        <select id="year-biology">
                            <option value="2025" selected>2025</option>
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                            <option value="2022">2022</option>
                            <option value="2021">2021</option>
                        </select>
                        </div>
                    <div class="field">
                        <label>Subject:</label>
                        <select id="subject-biology">
                            <option value="Mathematics">Mathematics</option>
                            <option value="Physics">Physics</option>
                            <option value="Chemistry">Chemistry</option>
                            <option value="Biology" selected>Biology</option>
                        </select>
                    </div>
                    <div class="field">
                        <label>Tutorial ID:</label>
                        <input type="text" id="tutorialId-biology" value="KCET_2025_Biology" readonly/>
                        </div>
                    <div class="field">
                        <label>Day and Shift:</label>
                        <input type="text" id="dayAndShift-biology" value="2 April 2025 Shift - 2" placeholder="e.g., 2 April 2025 Shift - 2"/>
                        </div>
                    </div>
                <div class="row">
                    <div class="field">
                        <label>Tutorial Title:</label>
                        <input type="text" id="tutorialTitle-biology" value="KCET 2025 Biology"/>
                        </div>
                    <div class="field">
                        <label>Authority Exam ID:</label>
                        <input type="text" id="authorityExamId-biology" value="kar_kect"/>
                    </div>
                </div>
            </div>
            
            
            <!-- Always show edit interface for Biology -->
            <div id="inlineEditInterface-Biology" class="inline-edit-interface">
                <div class="inline-panels-header">
                    <!-- Viewer Toggle -->
                    <div class="viewer-toggle" id="viewerToggle-Biology" style="display: none;">
                        <button class="viewer-toggle-btn active" onclick="switchViewer('Biology', 'editor')">‚úèÔ∏è Edit</button>
                        <button class="viewer-toggle-btn" onclick="switchViewer('Biology', 'json')">üìÑ JSON Viewer</button>
                        <button class="viewer-toggle-btn" onclick="switchViewer('Biology', 'preview')">üëÅÔ∏è Live Preview</button>
                        <button class="ai-batch-btn" onclick="batchAnalyzeAllSolutions('Biology')">
                            ü§ñ Batch Analyzer
                        </button>
                        <button class="upload-json-btn" onclick="openUploadDialog('Biology')">
                            üì§ Upload
                        </button>
                    </div>
                </div>
                <div class="edit-interface-content">
                    <div class="question-list-sidebar" id="questionList-Biology">
                        <h4>üìã Questions</h4>
                        <!-- Question list will be populated here -->
                    </div>
                    
                    <!-- Question Editor Panel -->
                    <div class="question-editor-panel" id="questionEditor-Biology" style="display: none;">
                        <h4>‚úèÔ∏è Question Editor</h4>
                        <div id="editQuestionsList-Biology">
                            <!-- Editable question fields will be populated here -->
                        </div>
                    </div>
                    
                    <!-- JSON Viewer Panel -->
                    <div class="json-viewer-panel" id="jsonViewer-Biology" style="display: none;">
                        <h4>üìÑ JSON Data Structure</h4>
                        <div class="json-content" id="jsonContent-Biology">
                            <!-- JSON content will be populated here -->
                        </div>
                    </div>
                    
                    <div class="question-render-panel" id="questionRender-Biology" style="display: none;">
                        <h4>üìñ Live Preview</h4>
                        <div id="inlineBiologyRender">
                            <!-- Live render view will be shown here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        
    </div>


    <script>
        let allQuestions = [];
        let biologyTabElement = null; // Store Biology tab element for restoration
        let questionAssignments = {};
        let originalMarkdownContent = '';
        
        // OpenAI API Configuration
        const OPENAI_API_KEY = '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';
        const OPENAI_MODEL = 'gpt-4o'; // Using GPT-4o instead of gpt-5-nano
        
        // Table Converter - Convert markdown tables to HTML
        function hasMarkdownTable(text) {
            if (!text || typeof text !== 'string') return false;
            // Check for markdown table syntax: | :---: | or |---| or variations
            // Look for pipe character AND table separator pattern
            const hasPipes = text.includes('|');
            if (!hasPipes) return false;
            
            // Check for various table separator patterns
            // :---: or :--- or ---: or --- (with any spacing, with or without pipes around them)
            // Pattern: :---: or :--: or :--- or ---: or --- or :---:---: etc
            const separatorPattern = /:\s*-{2,}\s*:|:\s*-{2,}|---{2,}\s*:|---{2,}/;
            const hasSeparator = separatorPattern.test(text);
            
            // Also check if we have at least 3 pipes (which indicates a table row with 2+ columns)
            const pipeCount = (text.match(/\|/g) || []).length;
            const hasTableStructure = pipeCount >= 3; // At least 3 pipes means at least 2 columns
            
            // Debug logging
            if (hasPipes && (hasSeparator || hasTableStructure)) {
                console.log('Table detected:', { hasSeparator, hasTableStructure, pipeCount });
            }
            
            return hasSeparator || (hasTableStructure && hasPipes);
        }
        
        // Scan entire question object for markdown tables
        function findTablesInQuestion(question) {
            const locations = [];
            
            // Debug: Log what we're checking
            console.log('Scanning question for tables:', {
                hasQuestionDetails: !!question.questionDetails,
                hasText: !!question.text,
                hasQuestion: !!question.question,
                hasSolution: !!question.solution
            });
            
            // Check questionDetails array
            if (question.questionDetails && Array.isArray(question.questionDetails)) {
                question.questionDetails.forEach((detail, detailIndex) => {
                    // Check question text
                    if (hasMarkdownTable(detail.text)) {
                        locations.push({
                            path: ['questionDetails', detailIndex, 'text'],
                            text: detail.text,
                            type: 'questionText'
                        });
                    }
                    
                    // Check solution
                    if (hasMarkdownTable(detail.solution)) {
                        locations.push({
                            path: ['questionDetails', detailIndex, 'solution'],
                            text: detail.solution,
                            type: 'solution'
                        });
                    }
                    
                    // Check possibleAnswers
                    if (detail.possibleAnswers) {
                        Object.keys(detail.possibleAnswers).forEach(key => {
                            const answer = detail.possibleAnswers[key];
                            if (answer && answer.text && hasMarkdownTable(answer.text)) {
                                locations.push({
                                    path: ['questionDetails', detailIndex, 'possibleAnswers', key, 'text'],
                                    text: answer.text,
                                    type: 'answerOption'
                                });
                            }
                        });
                    }
                    
                    // Check solutionTextImages (if they contain text)
                    if (detail.solutionTextImages && Array.isArray(detail.solutionTextImages)) {
                        detail.solutionTextImages.forEach((imgObj, imgIndex) => {
                            if (imgObj && imgObj.text && hasMarkdownTable(imgObj.text)) {
                                locations.push({
                                    path: ['questionDetails', detailIndex, 'solutionTextImages', imgIndex, 'text'],
                                    text: imgObj.text,
                                    type: 'solutionImage'
                                });
                            }
                        });
                    }
                    
                    // Check textImages (if they contain text)
                    if (detail.textImages && Array.isArray(detail.textImages)) {
                        detail.textImages.forEach((imgObj, imgIndex) => {
                            if (imgObj && imgObj.text && hasMarkdownTable(imgObj.text)) {
                                locations.push({
                                    path: ['questionDetails', detailIndex, 'textImages', imgIndex, 'text'],
                                    text: imgObj.text,
                                    type: 'questionImage'
                                });
                            }
                        });
                    }
                });
            }
            
            // Also check allQuestions format (for backward compatibility)
            if (question.text) {
                if (hasMarkdownTable(question.text)) {
                    console.log('Found table in question.text');
                    locations.push({
                        path: ['text'],
                        text: question.text,
                        type: 'questionText'
                    });
                } else {
                    console.log('question.text exists but no table detected');
                }
            }
            
            if (question.solution && hasMarkdownTable(question.solution)) {
                locations.push({
                    path: ['solution'],
                    text: question.solution,
                    type: 'solution'
                });
            }
            
            if (question.question && hasMarkdownTable(question.question)) {
                locations.push({
                    path: ['question'],
                    text: question.question,
                    type: 'questionText'
                });
            }
            
            if (question.options && Array.isArray(question.options)) {
                question.options.forEach((option, optIndex) => {
                    if (option && option.text && hasMarkdownTable(option.text)) {
                        locations.push({
                            path: ['options', optIndex, 'text'],
                            text: option.text,
                            type: 'option'
                        });
                    }
                });
            }
            
            console.log(`Found ${locations.length} table location(s):`, locations.map(l => `${l.type} at ${l.path.join('.')}`));
            return locations;
        }
        
        // Set value in nested object using path array
        function setNestedValue(obj, path, value) {
            let current = obj;
            for (let i = 0; i < path.length - 1; i++) {
                if (!current[path[i]]) {
                    current[path[i]] = {};
                }
                current = current[path[i]];
            }
            current[path[path.length - 1]] = value;
        }
        
        // Internal function to convert markdown tables to HTML tables
        function convertMarkdownTablesToHTML(text) {
            if (!text || typeof text !== 'string') return text;
            
            // Pattern to match markdown tables including those with text before/after
            // Matches: text before | table | table | (optional text after)
            // Followed by: | :---: | separator row
            // Followed by: | table | table | data rows
            
            // First, try to find complete table blocks (lines starting with |)
            const lines = text.split('\n');
            const result = [];
            let i = 0;
            
            while (i < lines.length) {
                const line = lines[i];
                
                // Check if this line contains a table structure (has | and looks like a table)
                // Look for pattern: text|content|content| or |content|content|
                if (line.includes('|')) {
                    // Check if there's a potential table separator on next line
                    if (i + 1 < lines.length && lines[i + 1].includes('|')) {
                        const nextLine = lines[i + 1].trim();
                        // Check if next line is a separator row
                        if (/^\|[\s:-]+\|/.test(nextLine)) {
                            // Found a potential table - collect all rows
                            const tableStart = i;
                            let tableLines = [];
                            let textBefore = '';
                            let textAfter = '';
                            let headerColumns = null; // Column headers from markdown header (## text)
                            
                            // Check if there's a markdown header (## text) before the table
                            if (i > 0) {
                                const prevLine = lines[i - 1].trim();
                                // Match markdown headers like ## Header Text or ##Header Text
                                const headerMatch = prevLine.match(/^##+\s*(.+)$/);
                                if (headerMatch && headerMatch[1]) {
                                    const headerText = headerMatch[1].trim();
                                    // Split header text into column names (space-separated)
                                    const columns = headerText.split(/\s+/).filter(h => h.trim() !== '');
                                    if (columns.length > 0) {
                                        // Store header columns for later use
                                        headerColumns = columns;
                                        // Remove the header line from output (it will become table header)
                                        result.pop(); // Remove the last added line (which is the header)
                                    }
                                }
                            }
                            
                            // Extract table from first line if there's text before it
                            // Match pattern: text before |cell|cell| (with potential text after)
                            const firstLineMatch = line.match(/^(.*?)(\|[^\n]*\|)(.*)$/);
                            if (firstLineMatch && firstLineMatch[2] && firstLineMatch[2].includes('|')) {
                                textBefore = firstLineMatch[1].trim();
                                // Clean up the table row (ensure it starts and ends with |)
                                let tableRow = firstLineMatch[2].trim();
                                if (!tableRow.startsWith('|')) tableRow = '|' + tableRow;
                                if (!tableRow.endsWith('|')) tableRow = tableRow + '|';
                                tableLines.push(tableRow);
                                textAfter = firstLineMatch[3].trim();
                            } else if (line.trim().startsWith('|')) {
                                // Line starts with |, it's a table row
                                tableLines.push(line.trim());
                            } else {
                                // Check if line contains table structure in the middle
                                // Pattern: content|cell|cell|content
                                const midTableMatch = line.match(/(.*?)(\|[^|\n]+\|[^|\n]*\|.*?)(.*)$/);
                                if (midTableMatch && midTableMatch[2]) {
                                    textBefore = midTableMatch[1].trim();
                                    let tableRow = midTableMatch[2].trim();
                                    if (!tableRow.startsWith('|')) tableRow = '|' + tableRow;
                                    if (!tableRow.endsWith('|')) tableRow = tableRow + '|';
                                    tableLines.push(tableRow);
                                    textAfter = midTableMatch[3].trim();
                                } else {
                                    // Not a table, move on
                                    result.push(line);
                                    i++;
                                    continue;
                                }
                            }
                            
                            // Add separator row (second line)
                            i++;
                            tableLines.push(lines[i].trim());
                            
                            // Collect data rows
                            i++;
                            while (i < lines.length && lines[i].includes('|')) {
                                const dataLine = lines[i].trim();
                                // Check if it's another separator (unlikely but possible)
                                if (/^\|[\s:-]+\|/.test(dataLine)) {
                                    // Another separator, treat as part of table structure
                                    tableLines.push(dataLine);
                                    i++;
                                    continue;
                                }
                                // Check if line contains table structure
                                if (dataLine.startsWith('|') || /\|.*\|/.test(dataLine)) {
                                    // Extract table part if there's text before/after
                                    const dataMatch = dataLine.match(/^(.*?)(\|[^\n]*\|)(.*)$/);
                                    if (dataMatch && dataMatch[2] && dataMatch[2].includes('|')) {
                                        // If there's text before the table on first data row, preserve it
                                        let tableRow = dataMatch[2].trim();
                                        if (!tableRow.startsWith('|')) tableRow = '|' + tableRow;
                                        if (!tableRow.endsWith('|')) tableRow = tableRow + '|';
                                        tableLines.push(tableRow);
                                        // If there's text after, it might be continuation or end
                                        if (dataMatch[3].trim()) {
                                            // Text after table - continue for now but mark it
                                            textAfter = dataMatch[3].trim();
                                        }
                                    } else if (dataLine.startsWith('|')) {
                                        // Pure table row
                                        tableLines.push(dataLine);
                                    } else {
                                        // No table structure in this line
                                        break;
                                    }
                                } else {
                                    // Line doesn't have table structure, stop collecting
                                    break;
                                }
                                i++;
                            }
                            
                            // Convert table if we have at least separator + 1 data row (or header + separator + 1 data row)
                            const hasHeaderColumns = headerColumns && headerColumns.length > 0;
                            // When headerColumns exist: need separator + firstRow (as data) + at least 1 more data row = 3 rows minimum
                            // When no headerColumns: need headerRow + separator + 1 data row = 3 rows minimum
                            const minRows = 3; // Both cases need at least 3 rows
                            
                            const tableMarkdown = tableLines.join('\n');
                            
                            if (tableLines.length >= minRows) {
                                const htmlTable = convertSingleMarkdownTable(tableMarkdown, headerColumns);
                                
                                // Combine text before, table, and text after
                                let combined = '';
                                if (textBefore) combined += textBefore + ' ';
                                combined += htmlTable;
                                if (textAfter) combined += ' ' + textAfter;
                                
                                result.push(combined);
                                continue; // Don't increment i, it's already at the next line
                            } else {
                                // Not a complete table, add lines as-is
                                result.push(...lines.slice(tableStart, i + 1));
                                i++;
                                continue;
                            }
                        }
                    }
                }
                
                // No table found, add line as-is
                result.push(line);
                i++;
            }
            
            return result.join('\n');
        }
        
        // Convert a single markdown table to HTML
        function convertSingleMarkdownTable(markdownTable, headerColumns = null) {
            const lines = markdownTable.split('\n').filter(line => line.trim() !== '');
            
            if (lines.length < 2) return markdownTable; // Not a valid table
            
            // Find separator row index (contains :---: or ---)
            let separatorIndex = -1;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (/^\|[:\s-]+\|/.test(line)) {
                    separatorIndex = i;
                    break;
                }
            }
            
            if (separatorIndex === -1) {
                return markdownTable; // No valid separator found
            }
            
            // Determine header row
            let headerRow = [];
            let firstDataRowIndex = separatorIndex + 1;
            
            if (headerColumns && headerColumns.length > 0) {
                // Use markdown header columns as table header
                // Add empty first cell when using markdown header
                headerRow = ['', ...headerColumns]; // First cell is empty
                // All rows (including first row) are data rows when headerColumns is provided
                firstDataRowIndex = 0;
            } else {
                // Use row before separator as header
                if (separatorIndex === 0) {
                    return markdownTable; // Separator is first row, no header
                }
                headerRow = parseTableRow(lines[separatorIndex - 1]);
                firstDataRowIndex = separatorIndex + 1;
            }
            
            // Parse data rows (all rows when headerColumns exist, or rows after separator when using first row as header)
            const dataRows = [];
            for (let i = firstDataRowIndex; i < lines.length; i++) {
                // Skip separator row
                if (i === separatorIndex) continue;
                const cells = parseTableRow(lines[i]);
                if (cells.length > 0) {
                    dataRows.push(cells);
                }
            }
            
            // Build HTML table
            let html = '<table class="math-table">\n';
            
            // Header - handle empty cells with colspan
            if (headerRow.length > 0) {
                html += '<thead>\n<tr>\n';
                
                // Process header row with colspan detection
                let i = 0;
                while (i < headerRow.length) {
                    const cell = headerRow[i];
                    const cellText = cell ? cell.trim() : '';
                    
                    // Check how many empty cells follow this cell
                    let colspan = 1;
                    let j = i + 1;
                    while (j < headerRow.length) {
                        const nextCell = headerRow[j];
                        const nextCellText = nextCell ? nextCell.trim() : '';
                        if (nextCellText === '') {
                            colspan++;
                            j++;
                        } else {
                            break;
                        }
                    }
                    
                    // Render the cell
                    if (cellText === '') {
                        // Empty cell - render as empty th
                        if (colspan > 1) {
                            html += `<th colspan="${colspan}"></th>\n`;
                            i = j; // Skip processed cells
                        } else {
                            html += `<th></th>\n`;
                            i++;
                        }
                    } else {
                        // Non-empty cell - check if it should span columns
                        if (colspan > 1) {
                            html += `<th colspan="${colspan}">${cellText}</th>\n`;
                            i = j; // Skip processed cells
                        } else {
                            html += `<th>${cellText}</th>\n`;
                            i++;
                        }
                    }
                }
                
                html += '</tr>\n</thead>\n';
            }
            
            // Body
            if (dataRows.length > 0) {
                html += '<tbody>\n';
                dataRows.forEach(row => {
                    html += '<tr>\n';
                    row.forEach(cell => {
                        html += `<td>${cell.trim()}</td>\n`;
                    });
                    html += '</tr>\n';
                });
                html += '</tbody>\n';
            }
            
            html += '</table>';
            
            return html;
        }
        
        // Parse a table row into cells
        function parseTableRow(row) {
            if (!row || !row.includes('|')) return [];
            
            // Remove leading/trailing pipe if present
            row = row.trim();
            if (row.startsWith('|')) row = row.substring(1);
            if (row.endsWith('|')) row = row.substring(0, row.length - 1);
            
            // Split by pipe, but preserve pipes inside LaTeX
            const cells = [];
            let currentCell = '';
            let insideLaTeX = false;
            let latexDelimiter = '';
            
            for (let i = 0; i < row.length; i++) {
                const char = row[i];
                
                // Check for LaTeX delimiters
                if (!insideLaTeX && (char === '$')) {
                    insideLaTeX = true;
                    latexDelimiter = '$';
                } else if (insideLaTeX && char === latexDelimiter) {
                    // Check if it's escaped or double $$
                    if (i < row.length - 1 && row[i + 1] === '$' && latexDelimiter === '$') {
                        currentCell += '$$';
                        i++; // Skip next $
                        continue;
                    }
                    insideLaTeX = false;
                    latexDelimiter = '';
                }
                
                // If we hit a pipe and we're not inside LaTeX, it's a cell separator
                if (char === '|' && !insideLaTeX) {
                    cells.push(currentCell.trim());
                    currentCell = '';
                } else {
                    currentCell += char;
                }
            }
            
            // Add the last cell (preserve it even if empty, as empty cells are meaningful for colspan)
            cells.push(currentCell.trim());
            
            return cells; // Preserve empty cells for colspan detection
        }
        
        // AI Solution Analyzer - Format solution step by step
        async function formatSolutionWithAI(questionNumber, questionText, currentSolution) {
            const statusId = `ai-status-${questionNumber}`;
            const statusDiv = document.getElementById(statusId);
            const button = document.getElementById(`ai-btn-${questionNumber}`);
            
            if (statusDiv) {
                statusDiv.className = 'ai-status loading';
                statusDiv.textContent = 'üîÑ Analyzing and formatting...';
            }
            
            if (button) {
                button.disabled = true;
            }
            
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: OPENAI_MODEL,
                        messages: [
                            {
                                role: 'system',
                                content: `You are an expert mathematics and science educator. Your task is to format solutions in a clear, step-by-step manner using HTML tags.

FORMAT REQUIREMENTS:
1. **Step-by-Step Structure**: Break down the solution into clear, numbered steps using HTML
2. **Mathematical Notation**: Use proper LaTeX notation with $ for inline math and $$ for display equations
3. **Clear Explanations**: Add brief explanations for each step
4. **Professional Formatting**: Remove redundant text like "Sol.", "Ans.", etc.
5. **Logical Flow**: Ensure steps follow logically from one to another
6. **HTML Tags**: Use <strong>, <p>, <br> tags instead of markdown

EXAMPLE FORMAT:
<p><strong>Step 1:</strong> [Brief description of what we're doing]</p>
<p>$$ equation $$</p>

<p><strong>Step 2:</strong> [Explanation of the next step]</p>
<p>$$ next equation $$</p>

<p><strong>Step 3:</strong> [Continue with clear explanations]</p>
<p>$$ result $$</p>

<p><strong>Final Answer:</strong> [Clear statement of the final result]</p>

IMPORTANT: 
- Use <strong> tags for bold text (like "Step 1:", "Step 2:", "Final Answer:")
- Use <p> tags to wrap each paragraph/step
- Use <br> for line breaks if needed
- Do NOT use markdown formatting like ** or ##
- Return ONLY the formatted HTML solution with proper step-by-step breakdown
- No additional commentary or explanations outside the solution`
                            },
                            {
                                role: 'user',
                                content: `Question: ${questionText}

Current Solution:
${currentSolution}

Please format this solution with clear step-by-step explanations and proper mathematical notation.`
                            }
                        ],
                        temperature: 0.3,
                        max_tokens: 2000
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'API request failed');
                }
                
                const data = await response.json();
                const formattedSolution = data.choices[0].message.content.trim();
                
                if (statusDiv) {
                    statusDiv.className = 'ai-status success';
                    statusDiv.textContent = '‚úÖ Formatted successfully!';
                    setTimeout(() => {
                        statusDiv.className = 'ai-status';
                    }, 5000);
                }
                
                if (button) {
                    button.disabled = false;
                }
                
                return formattedSolution;
                
            } catch (error) {
                console.error('AI formatting error:', error);
                
                if (statusDiv) {
                    statusDiv.className = 'ai-status error';
                    statusDiv.textContent = `‚ùå Error: ${error.message}`;
                }
                
                if (button) {
                    button.disabled = false;
                }
                
                alert(`Error formatting solution: ${error.message}`);
                return null;
            }
        }
        
        // Apply AI formatting to a single question's solution
        async function analyzeAndFormatSolution(questionNumber) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question) {
                alert('Question not found!');
                return;
            }
            
            if (!question.solution || question.solution.trim() === '') {
                alert('No solution text to format!');
                return;
            }
            
            const formattedSolution = await formatSolutionWithAI(
                questionNumber,
                question.text,
                question.solution
            );
            
            if (formattedSolution) {
                // Update the question object
                question.solution = formattedSolution;
                
                // Update all textareas showing this solution
                const textareas = document.querySelectorAll(`textarea[data-question="${questionNumber}"]`);
                textareas.forEach(textarea => {
                    if (textarea.classList.contains('solution-edit-textarea') || 
                        textarea.classList.contains('solution-edit-input') ||
                        textarea.classList.contains('solution-textarea')) {
                        textarea.value = formattedSolution;
                    }
                });
                
                // Update live preview
                updateLivePreview();
                
                // Mark work as unsaved
                markWorkAsUnsaved();
            }
        }
        
        // Batch analyze and format all solutions for a subject
        async function batchAnalyzeAllSolutions(subject) {
            const subjectQuestions = allQuestions.filter(q => q.subject === subject.toLowerCase());
            
            if (subjectQuestions.length === 0) {
                alert(`No questions found for ${subject}`);
                return;
            }
            
            const questionsWithSolutions = subjectQuestions.filter(q => q.solution && q.solution.trim() !== '');
            
            if (questionsWithSolutions.length === 0) {
                alert(`No solutions found to format in ${subject}`);
                return;
            }
            
            if (!confirm(`ü§ñ AI Analyzer will format ${questionsWithSolutions.length} solutions step by step.\n\nThis will:\n‚úì Break down solutions into clear steps\n‚úì Add proper mathematical notation\n‚úì Include explanations for each step\n‚úì Take approximately ${Math.ceil(questionsWithSolutions.length * 1.5)} minutes\n\nContinue?`)) {
                return;
            }
            
            let successCount = 0;
            let failCount = 0;
            let processedCount = 0;
            
            // Create progress indicator
            const progressDiv = document.createElement('div');
            progressDiv.style.cssText = 'position: fixed; top: 20px; right: 20px; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 10000; min-width: 300px;';
            progressDiv.innerHTML = `
                <h3 style="margin: 0 0 10px 0; color: #667eea;">ü§ñ AI Analyzer Progress</h3>
                <div style="margin: 10px 0;">
                    <div style="font-size: 14px; margin-bottom: 5px;">Processing: <strong id="ai-progress-text">0/${questionsWithSolutions.length}</strong></div>
                    <div style="background: #e0e0e0; height: 8px; border-radius: 4px; overflow: hidden;">
                        <div id="ai-progress-bar" style="background: linear-gradient(90deg, #667eea, #764ba2); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 10px;">
                    <div>‚úÖ Success: <span id="ai-success-count">0</span></div>
                    <div>‚ùå Failed: <span id="ai-fail-count">0</span></div>
                </div>
            `;
            document.body.appendChild(progressDiv);
            
            const progressBar = document.getElementById('ai-progress-bar');
            const progressText = document.getElementById('ai-progress-text');
            const successCountSpan = document.getElementById('ai-success-count');
            const failCountSpan = document.getElementById('ai-fail-count');
            
            for (let i = 0; i < questionsWithSolutions.length; i++) {
                const question = questionsWithSolutions[i];
                processedCount++;
                
                console.log(`[AI Analyzer] Formatting ${processedCount}/${questionsWithSolutions.length}: Q${question.number} (${subject})`);
                
                // Update progress
                const progress = (processedCount / questionsWithSolutions.length) * 100;
                progressBar.style.width = progress + '%';
                progressText.textContent = `${processedCount}/${questionsWithSolutions.length}`;
                
                const formattedSolution = await formatSolutionWithAI(
                    question.number,
                    question.text,
                    question.solution
                );
                
                if (formattedSolution) {
                    question.solution = formattedSolution;
                    successCount++;
                    successCountSpan.textContent = successCount;
                } else {
                    failCount++;
                    failCountSpan.textContent = failCount;
                }
                
                // Add delay between requests to avoid rate limiting (1.5 seconds)
                if (i < questionsWithSolutions.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            // Remove progress indicator
            setTimeout(() => {
                document.body.removeChild(progressDiv);
            }, 3000);
            
            // Refresh the UI
            const currentQuestionIndex = getCurrentQuestionIndex();
            generateQuestionEditor(subject, currentQuestionIndex || 0);
            updateLivePreview();
            
            // Show completion message
            alert(`üéâ AI Analysis Complete!\n\n‚úÖ Successfully formatted: ${successCount} solutions\n‚ùå Failed: ${failCount} solutions\n\nAll solutions now have step-by-step formatting with clear explanations!`);
        }
        
        // Helper function to get option text from both array and object formats
        function getOptionText(question, optionKey) {
            if (!question || !question.options) return '';
            
            if (Array.isArray(question.options)) {
                // Array format: ["(1) text1", "(2) text2", ...]
                const optionIndex = optionKey.charCodeAt(0) - 65; // A=0, B=1, C=2, D=3
                return question.options[optionIndex] ? question.options[optionIndex].replace(/^\(\d+\)\s*/, '').trim() : '';
            } else {
                // Object format: {A: {text: "...", image: null}, ...}
                return question.options[optionKey] && question.options[optionKey].text ? question.options[optionKey].text : '';
            }
        }
        
        // Helper function to get correct answer text
        function getCorrectAnswerText(question) {
            if (!question || !question.answer || !question.options) return '';
            
            const answerNum = parseInt(question.answer);
            if (isNaN(answerNum) || answerNum < 1 || answerNum > 4) return '';
            
            const optionKey = String.fromCharCode(64 + answerNum); // 1=A, 2=B, 3=C, 4=D
            return getOptionText(question, optionKey);
        }
        
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('jsonFolderInput').addEventListener('change', handleJSONFolderSelect);
        
        // Initialize: Hide subject-tabs-container by default
        // It will only be shown when loading from .md files
        const subjectTabsContainer = document.getElementById('subjectTabsContainer');
        if (subjectTabsContainer) {
            subjectTabsContainer.style.display = 'none';
            console.log('üîí subject-tabs-container hidden by default (will show only for .md files)');
        }
        
        // Firebase Directory Selector Event Listener
        document.getElementById('firebaseDirectorySelect').addEventListener('change', function() {
            const select = document.getElementById('firebaseDirectorySelect');
            const loadBtn = document.getElementById('loadDirectoryBtn');
            loadBtn.disabled = !select.value;
        });
        
        // Global variables for Firebase directory management
        let currentFirebaseDirectory = '';
        let currentYear = '';
        let selectedJsonFileName = '';
        let currentFirebaseJsonPath = null; // Store the Firebase path of the loaded JSON file
        
        // Toggle year panel
        function toggleYearPanel() {
            const yearPanel = document.getElementById('yearPanel');
            const overlay = document.getElementById('yearPanelOverlay');
            const toggleBtn = document.getElementById('selectYearBtn');
            
            if (yearPanel.classList.contains('open')) {
                closeYearPanel();
            } else {
                openYearPanel();
            }
        }
        
        // Update selection banner
        function updateSelectionBanner() {
            const banner = document.getElementById('selectionBanner');
            const yearDisplay = document.getElementById('selectedYearDisplay');
            const jsonDisplay = document.getElementById('selectedJsonDisplay');
            
            if (currentYear || selectedJsonFileName) {
                yearDisplay.textContent = currentYear || '--';
                jsonDisplay.textContent = selectedJsonFileName || '--';
                banner.classList.add('show');
            } else {
                banner.classList.remove('show');
            }
        }
        
        // Clear all data (internal function without confirmation)
        function clearAllData() {
            // Clear global variables
            currentYear = '';
            selectedJsonFileName = '';
            currentFirebaseJsonPath = null;
            window.currentDataSource = null;
            
            // Clear questions and assignments
            allQuestions = [];
            questionAssignments = {};
            
            // Hide subject tabs container
            const subjectTabsContainer = document.getElementById('subjectTabsContainer');
            if (subjectTabsContainer) {
                subjectTabsContainer.style.display = 'none';
            }
            
            // Hide subject views
            document.querySelectorAll('.subject-view').forEach(view => {
                view.style.display = 'none';
                view.classList.remove('active');
            });
            
            // Hide sidebar stats and download
            const sidebarStats = document.getElementById('sidebarStats');
            const sidebarDownload = document.getElementById('sidebarDownload');
            if (sidebarStats) sidebarStats.style.display = 'none';
            if (sidebarDownload) sidebarDownload.style.display = 'none';
            
            // Clear question lists
            ['Mathematics', 'Physics', 'Chemistry', 'Biology'].forEach(subject => {
                const questionList = document.getElementById(`questionList-${subject}`);
                if (questionList) {
                    questionList.innerHTML = '<h4>üìã Questions</h4>';
                }
                
                // Clear editor panels
                const editorPanel = document.getElementById(`questionEditor-${subject}`);
                const jsonPanel = document.getElementById(`jsonViewer-${subject}`);
                const renderPanel = document.getElementById(`questionRender-${subject}`);
                if (editorPanel) editorPanel.innerHTML = '<h4>‚úèÔ∏è Question Editor</h4><div id="editQuestionsList-' + subject + '"></div>';
                if (jsonPanel) jsonPanel.innerHTML = '<h4>üìÑ JSON Data Structure</h4><div class="json-content" id="jsonContent-' + subject + '"></div>';
                if (renderPanel) {
                    const renderContainer = document.getElementById(
                        subject === 'Mathematics' ? 'inlineMathRender' : 
                        subject === 'Physics' ? 'inlinePhysicsRender' : 
                        subject === 'Chemistry' ? 'inlineChemistryRender' :
                        'inlineBiologyRender'
                    );
                    if (renderContainer) renderContainer.innerHTML = '';
                }
            });
            
            // Reset form fields to defaults
            const formFields = ['state', 'board', 'conductedBy', 'year', 'subject', 'tutorialId', 'dayAndShift', 'tutorialTitle', 'authorityExamId'];
            formFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    if (field.tagName === 'SELECT') {
                        field.selectedIndex = 0;
                    } else {
                        field.value = '';
                    }
                }
            });
            
            // Update banner (will hide it since values are cleared)
            updateSelectionBanner();
            
            // Mark as saved (no unsaved work)
            markWorkAsUnsaved(false);
        }
        
        // Unload JSON - Clear loaded data and reset UI (with confirmation)
        function unloadJSON() {
            if (!confirm('Are you sure you want to unload the current JSON file? This will clear all loaded data.')) {
                return;
            }
            
            clearAllData();
            
            console.log('‚úÖ JSON unloaded successfully');
            alert('‚úÖ JSON file unloaded. All data has been cleared.');
        }
        
        // Show progress bar
        function showProgressBar() {
            const progressBar = document.getElementById('firebaseProgressBar');
            if (progressBar) {
                progressBar.classList.add('show');
            }
        }
        
        // Hide progress bar
        function hideProgressBar() {
            const progressBar = document.getElementById('firebaseProgressBar');
            if (progressBar) {
                progressBar.classList.remove('show');
            }
        }
        
        // Load Firebase Directory and show year panel
        async function loadFirebaseDirectory() {
            const select = document.getElementById('firebaseDirectorySelect');
            const directory = select.value;
            
            if (!directory) {
                alert('Please select a directory');
                return;
            }
            
            currentFirebaseDirectory = directory;
            
            try {
                // Show progress bar
                showProgressBar();
                
                // Show loading state
                const loadBtn = document.getElementById('loadDirectoryBtn');
                loadBtn.disabled = true;
                loadBtn.textContent = 'Loading...';
                
                // List all folders in the directory (these should be year folders)
                const { storage, ref, listAll } = window.firebaseStorage;
                const directoryRef = ref(storage, directory);
                
                console.log(`üìÅ Listing folders in: ${directory}`);
                const result = await listAll(directoryRef);
                
                // Extract year folders (e.g., KCET_question_papers_2004)
                const yearFolders = result.prefixes
                    .map(prefix => {
                        const name = prefix.name;
                        // Extract year from folder name like "KCET_question_papers_2004"
                        const yearMatch = name.match(/(\d{4})/);
                        return yearMatch ? {
                            year: yearMatch[1],
                            folderName: name,
                            fullPath: `${directory}/${name}`
                        } : null;
                    })
                    .filter(item => item !== null)
                    .sort((a, b) => parseInt(b.year) - parseInt(a.year)); // Sort descending (newest first)
                
                console.log(`‚úÖ Found ${yearFolders.length} year folders:`, yearFolders);
                
                // Populate year panel
                populateYearPanel(yearFolders);
                
                // Show year panel
                openYearPanel();
                
                loadBtn.disabled = false;
                loadBtn.textContent = 'Load Directory';
                
                // Hide progress bar
                hideProgressBar();
                
            } catch (error) {
                console.error('‚ùå Error loading directory:', error);
                alert(`Error loading directory: ${error.message}`);
                const loadBtn = document.getElementById('loadDirectoryBtn');
                loadBtn.disabled = false;
                loadBtn.textContent = 'Load Directory';
                
                // Hide progress bar on error
                hideProgressBar();
            }
        }
        
        // Populate year panel with year folders
        function populateYearPanel(yearFolders) {
            const yearList = document.getElementById('yearList');
            const yearPanelTitle = document.getElementById('yearPanelTitle');
            
            yearPanelTitle.textContent = `Select Year - ${currentFirebaseDirectory}`;
            yearList.innerHTML = '';
            
            if (yearFolders.length === 0) {
                yearList.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 20px;">No year folders found</p>';
                return;
            }
            
            yearFolders.forEach(yearFolder => {
                // Create year item container
                const yearItem = document.createElement('div');
                yearItem.className = 'year-item';
                yearItem.dataset.year = yearFolder.year;
                yearItem.dataset.fullPath = yearFolder.fullPath;
                
                // Create header with year name and expand icon
                const yearHeader = document.createElement('div');
                yearHeader.className = 'year-item-header';
                
                const yearName = document.createElement('span');
                yearName.className = 'year-item-name';
                yearName.textContent = yearFolder.year;
                
                const expandIcon = document.createElement('span');
                expandIcon.className = 'year-item-expand';
                expandIcon.textContent = '‚ñ∂';
                
                yearHeader.appendChild(yearName);
                yearHeader.appendChild(expandIcon);
                yearItem.appendChild(yearHeader);
                
                // Create JSON file list container (initially hidden)
                const jsonList = document.createElement('div');
                jsonList.className = 'year-json-list';
                yearItem.appendChild(jsonList);
                
                // Click handler to expand/collapse and load JSON files
                yearItem.onclick = async (e) => {
                    // Don't toggle if clicking on JSON file item or its children
                    if (e.target.closest('.json-file-item')) {
                        return;
                    }
                    
                    const isExpanded = yearItem.classList.contains('expanded');
                    
                    if (isExpanded) {
                        // Collapse
                        yearItem.classList.remove('expanded');
                        expandIcon.textContent = '‚ñ∂';
                    } else {
                        // Expand and load JSON files
                        yearItem.classList.add('expanded');
                        expandIcon.textContent = '‚ñº';
                        
                        // Load JSON files for this year
                        await loadYearJSONFiles(yearFolder, jsonList);
                    }
                };
                
                yearList.appendChild(yearItem);
            });
        }
        
        // Open year panel
        function openYearPanel() {
            const yearPanel = document.getElementById('yearPanel');
            const overlay = document.getElementById('yearPanelOverlay');
            const toggleBtn = document.getElementById('selectYearBtn');
            yearPanel.classList.add('open');
            overlay.classList.add('show');
            if (toggleBtn) {
                toggleBtn.classList.add('active');
            }
        }
        
        // Close year panel
        function closeYearPanel() {
            const yearPanel = document.getElementById('yearPanel');
            const overlay = document.getElementById('yearPanelOverlay');
            const toggleBtn = document.getElementById('selectYearBtn');
            yearPanel.classList.remove('open');
            overlay.classList.remove('show');
            if (toggleBtn) {
                toggleBtn.classList.remove('active');
            }
        }
        
        // Load JSON files for a year and display them in the list
        async function loadYearJSONFiles(yearFolder, jsonListContainer) {
            // Clear previous content
            jsonListContainer.innerHTML = '';
            
            // Show progress bar
            showProgressBar();
            
            // Show loading state
            const loadingMsg = document.createElement('div');
            loadingMsg.textContent = 'Loading JSON files...';
            loadingMsg.style.cssText = 'padding: 8px 12px; color: var(--text-secondary); font-size: 12px; font-style: italic;';
            jsonListContainer.appendChild(loadingMsg);
            
            try {
                console.log(`üìÇ Loading JSON files for year ${yearFolder.year} from ${yearFolder.fullPath}`);
                
                // List all files in the year folder
                const { storage, ref, listAll } = window.firebaseStorage;
                const yearFolderRef = ref(storage, yearFolder.fullPath);
                
                console.log(`üîç Listing files in: ${yearFolder.fullPath}`);
                const result = await listAll(yearFolderRef);
                
                console.log(`üìã Found ${result.items.length} items in folder`);
                console.log(`üìã Items:`, result.items.map(item => item.name));
                console.log(`üìã Prefixes (subfolders):`, result.prefixes.map(prefix => prefix.name));
                
                // Clear loading message
                jsonListContainer.innerHTML = '';
                
                // Filter and display JSON files (from root of year folder)
                const jsonFiles = [];
                console.log(`üîç Processing ${result.items.length} items in root of year folder...`);
                for (const item of result.items) {
                    const fileName = item.name.toLowerCase();
                    console.log(`  - Checking item: ${item.name} (lowercase: ${fileName})`);
                    
                    // Only process .json files
                    if (fileName.endsWith('.json')) {
                        console.log(`  ‚úÖ Found JSON file in root: ${item.name}`);
                        jsonFiles.push({
                            ref: item,
                            name: item.name,
                            fullPath: `${yearFolder.fullPath}/${item.name}`,
                            yearFolder: yearFolder,
                            subfolder: '' // File is in root of year folder
                        });
                    } else {
                        console.log(`  ‚è≠Ô∏è Skipping non-JSON file: ${item.name}`);
                    }
                }
                console.log(`üìä Found ${jsonFiles.length} JSON files in root of year folder`);
                
                // Also check subdirectories (prefixes) for JSON files
                console.log(`üîç Checking ${result.prefixes.length} subdirectories for JSON files...`);
                for (const prefix of result.prefixes) {
                    const subfolderPath = `${yearFolder.fullPath}/${prefix.name}`;
                    console.log(`üìÅ Checking subdirectory: ${subfolderPath}`);
                    
                    try {
                        const subfolderRef = ref(storage, subfolderPath);
                        const subfolderResult = await listAll(subfolderRef);
                        
                        console.log(`üìã Found ${subfolderResult.items.length} items in ${prefix.name}`);
                        
                        for (const item of subfolderResult.items) {
                            const fileName = item.name.toLowerCase();
                            
                            // Only process .json files
                            if (fileName.endsWith('.json')) {
                                jsonFiles.push({
                                    ref: item,
                                    name: item.name,
                                    fullPath: `${subfolderPath}/${item.name}`,
                                    yearFolder: yearFolder,
                                    subfolder: prefix.name // Track which subfolder this file is in
                                });
                                console.log(`‚úÖ Found JSON file in subfolder: ${prefix.name}/${item.name}`);
                            }
                        }
                    } catch (subfolderError) {
                        console.warn(`‚ö†Ô∏è Error listing subdirectory ${prefix.name}:`, subfolderError);
                    }
                }
                
                if (jsonFiles.length === 0) {
                    const noJsonMsg = document.createElement('div');
                    noJsonMsg.textContent = 'No JSON files found';
                    noJsonMsg.style.cssText = 'padding: 8px 12px; color: var(--text-secondary); font-size: 12px; font-style: italic;';
                    jsonListContainer.appendChild(noJsonMsg);
                    return;
                }
                
                console.log(`‚úÖ Total JSON files found: ${jsonFiles.length} (including subdirectories)`);
                
                // Create JSON file items
                jsonFiles.forEach(jsonFile => {
                    const jsonItem = document.createElement('div');
                    jsonItem.className = 'json-file-item';
                    
                    // Show subfolder name if file is in a subdirectory
                    const displayName = jsonFile.subfolder 
                        ? `${jsonFile.subfolder}/${jsonFile.name}` 
                        : jsonFile.name;
                    jsonItem.textContent = displayName;
                    jsonItem.title = `Click to load: ${jsonFile.fullPath}`;
                    
                    jsonItem.onclick = async (e) => {
                        e.stopPropagation();
                        await loadJSONFile(jsonFile);
                    };
                    
                    jsonListContainer.appendChild(jsonItem);
                });
                
                // Hide progress bar
                hideProgressBar();
                
            } catch (error) {
                console.error('‚ùå Error loading JSON files:', error);
                jsonListContainer.innerHTML = '';
                const errorMsg = document.createElement('div');
                errorMsg.textContent = `Error: ${error.message}`;
                errorMsg.style.cssText = 'padding: 8px 12px; color: #ef4444; font-size: 12px;';
                jsonListContainer.appendChild(errorMsg);
                
                // Hide progress bar on error
                hideProgressBar();
            }
        }
        
        // Force hide subject-tabs-container - called immediately when loading from Firebase
        function forceHideSubjectTabs() {
            const subjectTabsContainer = document.getElementById('subjectTabsContainer');
            if (subjectTabsContainer) {
                subjectTabsContainer.style.display = 'none';
                console.log('üîí ‚úÖ Force hidden subject-tabs-container (Firebase load)');
            }
        }
        
        // Load a specific JSON file into the Tutorial JSON Builder
        async function loadJSONFile(jsonFile) {
            console.log(`üì• Loading JSON file: ${jsonFile.name}`);
            
            // IMMEDIATELY hide subject-tabs-container when loading from Firebase
            forceHideSubjectTabs();
            
            // Show progress bar
            showProgressBar();
            
            // Set selected JSON file name and update banner
            selectedJsonFileName = jsonFile.name;
            updateSelectionBanner();
            
            // Find the JSON file item and show loading state
            const jsonItems = document.querySelectorAll('.json-file-item');
            jsonItems.forEach(item => {
                if (item.textContent === jsonFile.name) {
                    item.classList.add('loading');
                }
            });
            
            try {
                // Get download URL and fetch the file
                const { getDownloadURL } = window.firebaseStorage;
                const downloadURL = await getDownloadURL(jsonFile.ref);
                
                console.log(`   Download URL obtained: ${downloadURL.substring(0, 80)}...`);
                
                // Fetch the file
                const response = await fetch(downloadURL, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
                }
                
                const jsonData = await response.json();
                
                // Handle array format
                let data = jsonData;
                if (Array.isArray(data) && data.length > 0) {
                    console.log(`üì¶ JSON is an array, extracting first object`);
                    data = data[0];
                }
                
                console.log(`‚úÖ Loaded JSON file:`, data);
                
                // Determine subject from filename
                const fileName = jsonFile.name.toLowerCase();
                const subjectMap = {
                    'mathematics': ['mathematics', 'math'],
                    'physics': ['physics'],
                    'chemistry': ['chemistry', 'chem'],
                    'biology': ['biology', 'bio']
                };
                
                let matchedSubject = null;
                for (const [subject, keywords] of Object.entries(subjectMap)) {
                    if (keywords.some(keyword => fileName.includes(keyword))) {
                        matchedSubject = subject;
                        break;
                    }
                }
                
                // Store the Firebase path for updating later
                currentFirebaseJsonPath = jsonFile.fullPath;
                console.log(`üíæ Stored Firebase path for update: ${currentFirebaseJsonPath}`);
                
                // Load the JSON data into the Tutorial JSON Builder
                if (matchedSubject) {
                    await loadSubjectData(matchedSubject, data, jsonFile.yearFolder);
                } else {
                    // If subject can't be determined, try to load all subjects from the data
                    console.log(`‚ö†Ô∏è Could not determine subject from filename, attempting to load all subjects`);
                    await loadAllSubjectsFromJSON(data, jsonFile.yearFolder);
                }
                
                // Remove loading state
                jsonItems.forEach(item => {
                    if (item.textContent === jsonFile.name) {
                        item.classList.remove('loading');
                    }
                });
                
                // Close year panel after loading
                closeYearPanel();
                
                // Hide progress bar
                hideProgressBar();
                
            } catch (error) {
                console.error(`‚ùå Error loading JSON file:`, error);
                alert(`Error loading JSON file: ${error.message}`);
                
                // Remove loading state
                jsonItems.forEach(item => {
                    if (item.textContent === jsonFile.name) {
                        item.classList.remove('loading');
                    }
                });
                
                // Hide progress bar on error
                hideProgressBar();
            }
        }
        
        // Load all subjects from a single JSON file
        async function loadAllSubjectsFromJSON(jsonData, yearFolder) {
            // Set current year and update banner
            currentYear = yearFolder.year;
            updateSelectionBanner();
            
            // Try to extract subject data from the JSON structure
            // This assumes the JSON might have a structure with subject keys or an array of questions with subject info
            const subjectData = {
                mathematics: null,
                physics: null,
                chemistry: null,
                biology: null
            };
            
            // Check if JSON has subject-specific keys
            if (jsonData.mathematics || jsonData.physics || jsonData.chemistry || jsonData.biology) {
                subjectData.mathematics = jsonData.mathematics || null;
                subjectData.physics = jsonData.physics || null;
                subjectData.chemistry = jsonData.chemistry || null;
                subjectData.biology = jsonData.biology || null;
            } else if (jsonData.questions && Array.isArray(jsonData.questions)) {
                // If it's a single JSON with questions, try to determine subject from metadata
                const subject = jsonData.subject ? jsonData.subject.toLowerCase() : null;
                if (subject && subjectData.hasOwnProperty(subject)) {
                    subjectData[subject] = jsonData;
                } else {
                    // Default to first available subject or mathematics
                    subjectData.mathematics = jsonData;
                }
            } else {
                // Single JSON file, try to determine subject from metadata
                const subject = jsonData.subject ? jsonData.subject.toLowerCase() : 'mathematics';
                if (subjectData.hasOwnProperty(subject)) {
                    subjectData[subject] = jsonData;
                } else {
                    subjectData.mathematics = jsonData;
                }
            }
            
            // Populate UI directly with the JSON data
            populateUIFromJSON(subjectData, true); // true = from Firebase
            markWorkAsUnsaved();
            alert(`‚úÖ Successfully loaded JSON file for year ${currentYear}!`);
        }
        
        // Load subject data (helper function) - UPDATED VERSION - DO NOT USE loadJSONFilesFromFirebase
        async function loadSubjectData(subject, data, yearFolder) {
            console.log(`üÜï NEW CODE PATH: Loading subject data for ${subject} from year ${yearFolder.year}`);
            console.log(`üÜï This should NOT call loadJSONFilesFromFirebase - if you see that error, browser cache needs clearing!`);
            
            // Set current year and update banner
            currentYear = yearFolder.year;
            updateSelectionBanner();
            
            const subjectData = {
                mathematics: null,
                physics: null,
                chemistry: null,
                biology: null
            };
            
            subjectData[subject] = data;
            
            console.log(`‚úÖ Subject data prepared, calling populateUIFromJSON directly...`);
            
            // Populate UI directly with the JSON data - DO NOT call loadJSONFilesFromFirebase here!
            populateUIFromJSON(subjectData, true); // true = from Firebase
            markWorkAsUnsaved();
            alert(`‚úÖ Successfully loaded ${subject} JSON file for year ${currentYear}!`);
        }
        
        // Select year and load JSON files (kept for backward compatibility, but now redirects to expand behavior)
        async function selectYear(yearFolder) {
            currentYear = yearFolder.year;
            updateSelectionBanner();
            
            // Update active state
            document.querySelectorAll('.year-item').forEach(item => {
                item.classList.remove('active');
                if (item.textContent === yearFolder.year) {
                    item.classList.add('active');
                    item.classList.add('loading');
                }
            });
            
            try {
                console.log(`üìÇ Loading JSON files for year ${yearFolder.year} from ${yearFolder.fullPath}`);
                
                // List all files in the year folder
                const { storage, ref, listAll, getDownloadURL } = window.firebaseStorage;
                const yearFolderRef = ref(storage, yearFolder.fullPath);
                
                console.log(`üîç Listing files in: ${yearFolder.fullPath}`);
                const result = await listAll(yearFolderRef);
                
                console.log(`üìã Found ${result.items.length} items in folder`);
                console.log(`üìã Items:`, result.items.map(item => item.name));
                console.log(`üìã Prefixes (subfolders):`, result.prefixes.map(prefix => prefix.name));
                
                // Filter JSON files and map to subjects
                const jsonFiles = {};
                const subjectMap = {
                    'mathematics': ['mathematics', 'math'],
                    'physics': ['physics'],
                    'chemistry': ['chemistry', 'chem'],
                    'biology': ['biology', 'bio']
                };
                
                // Process files directly in year folder
                for (const item of result.items) {
                    const fileName = item.name.toLowerCase();
                    
                    // Only process .json files
                    if (!fileName.endsWith('.json')) {
                        console.log(`‚è≠Ô∏è Skipping non-JSON file: ${item.name}`);
                        continue;
                    }
                    
                    console.log(`üîç Checking file: ${item.name} (lowercase: ${fileName})`);
                    
                    // Check which subject this file belongs to
                    let matched = false;
                    for (const [subject, keywords] of Object.entries(subjectMap)) {
                        if (keywords.some(keyword => fileName.includes(keyword))) {
                            console.log(`‚úÖ Matched ${item.name} to subject: ${subject} (keyword: ${keywords.find(k => fileName.includes(k))})`);
                            if (!jsonFiles[subject]) {
                                // Store both reference and path info for direct URL access
                                jsonFiles[subject] = {
                                    ref: item,
                                    name: item.name,
                                    folderName: yearFolder.folderName,
                                    fullPath: `${yearFolder.fullPath}/${item.name}`,
                                    subfolder: '' // File is in root of year folder
                                };
                                matched = true;
                            }
                            break;
                        }
                    }
                    
                    if (!matched) {
                        console.log(`‚ö†Ô∏è Could not match file ${item.name} to any subject`);
                    }
                }
                
                // Also check subdirectories (prefixes) for JSON files
                console.log(`üîç Checking ${result.prefixes.length} subdirectories for JSON files...`);
                for (const prefix of result.prefixes) {
                    const subfolderPath = `${yearFolder.fullPath}/${prefix.name}`;
                    console.log(`üìÅ Checking subdirectory: ${subfolderPath}`);
                    
                    try {
                        const subfolderRef = ref(storage, subfolderPath);
                        const subfolderResult = await listAll(subfolderRef);
                        
                        console.log(`üìã Found ${subfolderResult.items.length} items in ${prefix.name}`);
                        
                        for (const item of subfolderResult.items) {
                            const fileName = item.name.toLowerCase();
                            
                            // Only process .json files
                            if (!fileName.endsWith('.json')) {
                                continue;
                            }
                            
                            console.log(`üîç Checking file in subfolder: ${prefix.name}/${item.name} (lowercase: ${fileName})`);
                            
                            // Check which subject this file belongs to
                            for (const [subject, keywords] of Object.entries(subjectMap)) {
                                if (keywords.some(keyword => fileName.includes(keyword))) {
                                    console.log(`‚úÖ Matched ${prefix.name}/${item.name} to subject: ${subject}`);
                                    // Only use subfolder file if we don't already have a file for this subject
                                    if (!jsonFiles[subject]) {
                                        jsonFiles[subject] = {
                                            ref: item,
                                            name: item.name,
                                            folderName: yearFolder.folderName,
                                            fullPath: `${subfolderPath}/${item.name}`,
                                            subfolder: prefix.name
                                        };
                                    }
                                    break;
                                }
                            }
                        }
                    } catch (subfolderError) {
                        console.warn(`‚ö†Ô∏è Error listing subdirectory ${prefix.name}:`, subfolderError);
                    }
                }
                
                console.log(`‚úÖ Found JSON files:`, jsonFiles);
                console.log(`üìä Total subjects matched: ${Object.keys(jsonFiles).length}`);
                
                // Check if we found any JSON files
                if (Object.keys(jsonFiles).length === 0) {
                    const allFileNames = result.items.map(item => item.name).join(', ');
                    const allSubfolders = result.prefixes.map(prefix => prefix.name).join(', ');
                    console.error(`‚ùå No JSON files matched to subjects.`);
                    console.error(`Files in root: ${allFileNames || 'none'}`);
                    console.error(`Subfolders found: ${allSubfolders || 'none'}`);
                    alert(`No JSON files could be matched to subjects.\n\nFiles found in folder:\n${allFileNames || 'none'}\n\nSubfolders: ${allSubfolders || 'none'}\n\nPlease ensure files contain subject keywords (mathematics, physics, chemistry, biology) in their names.`);
                    document.querySelectorAll('.year-item').forEach(item => {
                        item.classList.remove('loading');
                    });
                    return;
                }
                
                // Load JSON files from URLs
                await loadJSONFilesFromFirebase(jsonFiles);
                
                // Close year panel after loading
                closeYearPanel();
                
                // Remove loading state
                document.querySelectorAll('.year-item').forEach(item => {
                    item.classList.remove('loading');
                });
                
            } catch (error) {
                console.error('‚ùå Error loading year data:', error);
                alert(`Error loading year ${yearFolder.year}: ${error.message}`);
                
                // Remove loading state
                document.querySelectorAll('.year-item').forEach(item => {
                    item.classList.remove('loading');
                });
            }
        }
        
        // Construct direct Firebase Storage URL from path
        function getFirebaseStorageURL(filePath) {
            // Firebase Storage REST API format:
            // https://firebasestorage.googleapis.com/v0/b/{bucket}/o/{encodedPath}?alt=media
            const bucket = 'prepbharat.firebasestorage.app';
            const encodedPath = encodeURIComponent(filePath).replace(/%2F/g, '/');
            return `https://firebasestorage.googleapis.com/v0/b/${bucket}/o/${encodedPath}?alt=media`;
        }
        
        // Wait for Firebase authentication token
        async function waitForAuthToken(maxWait = 5000) {
            const startTime = Date.now();
            while (!window.firebaseStorage.getAuthToken() && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return window.firebaseStorage.getAuthToken();
        }
        
        // Load JSON files from Firebase Storage using SDK with authentication
        async function loadJSONFilesFromFirebase(jsonFiles) {
            // IMMEDIATELY hide subject-tabs-container when loading from Firebase
            forceHideSubjectTabs();
            
            // Wait for authentication token (required for SDK to work properly)
            console.log('üîê Waiting for Firebase authentication...');
            const token = await waitForAuthToken();
            
            if (!token) {
                console.warn('‚ö†Ô∏è No auth token available, but continuing anyway...');
            } else {
                console.log('‚úÖ Firebase authentication ready');
            }
            
            const subjectData = {
                mathematics: null,
                physics: null,
                chemistry: null,
                biology: null
            };
            
            // Use getDownloadURL to get signed URLs (bypasses CORS issues)
            const loadPromises = Object.keys(jsonFiles).map(async (subject) => {
                try {
                    const fileInfo = jsonFiles[subject];
                    const { getDownloadURL } = window.firebaseStorage;
                    const fileRef = fileInfo.ref;
                    
                    console.log(`üì• Getting download URL for ${subject}: ${fileInfo.name}`);
                    
                    // Get signed download URL (this should work without CORS issues)
                    const downloadURL = await getDownloadURL(fileRef);
                    console.log(`   Download URL obtained: ${downloadURL.substring(0, 80)}...`);
                    
                    // Fetch the file using the signed URL
                    const response = await fetch(downloadURL, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
                    }
                    
                    const jsonData = await response.json();
                    
                    // Handle array format
                    let data = jsonData;
                    if (Array.isArray(data) && data.length > 0) {
                        console.log(`üì¶ ${subject} is an array, extracting first object`);
                        data = data[0];
                    }
                    
                    console.log(`‚úÖ Loaded ${subject} from Firebase via signed URL:`, data);
                    subjectData[subject] = data;
                    
                } catch (error) {
                    console.error(`‚ùå Error loading ${subject} from Firebase:`, error);
                    
                    // If CORS error, provide helpful message
                    if (error.message && (error.message.includes('CORS') || error.message.includes('blocked'))) {
                        console.error(`\n‚ö†Ô∏è CORS Error: You need to run this from a web server, not file://\n` +
                            `Run: python -m http.server 8000\n` +
                            `Then open: http://localhost:8000/question_assigner.html`);
                    }
                }
            });
            
            await Promise.all(loadPromises);
            
            // Populate UI with loaded data
            if (Object.values(subjectData).some(data => data !== null)) {
                populateUIFromJSON(subjectData, true); // true = from Firebase
                markWorkAsUnsaved();
                alert(`‚úÖ Successfully loaded JSON files for year ${currentYear}!`);
            } else {
                alert('‚ö†Ô∏è No valid JSON files found in the selected year folder.');
            }
        }
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                // Clear all existing data first to ensure fresh start when loading .md file
                console.log('üßπ Clearing existing data before loading .md file...');
                clearAllData();
                
                // Track data source as .md file
                window.currentDataSource = 'md';
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    
                    // Store original content for later use
                    originalMarkdownContent = content;
                    
                    // Parse exam details from content
                    const examDetails = parseExamDetails(content, 'Mathematics');
                    updateTutorialFields(examDetails);
                    
                    // Parse questions
                    parseQuestions(content);
                    
                    // Mark work as unsaved after file upload
                    markWorkAsUnsaved();
                };
                reader.readAsText(file);
            }
        }
        
        // Handle JSON folder upload
        function handleJSONFolderSelect(event) {
            const files = event.target.files;
            if (!files || files.length === 0) {
                alert('‚ö†Ô∏è No files selected. Please select a folder containing JSON files.');
                return;
            }
            
            console.log(`üìÇ Loading ${files.length} files from folder...`);
            
            // Find JSON files for each subject
            const jsonFiles = {
                mathematics: null,
                physics: null,
                chemistry: null
            };
            
            // Scan through files to find subject JSONs
            for (let file of files) {
                const fileName = file.name.toLowerCase();
                if (fileName.endsWith('.json')) {
                    if (fileName.includes('mathematics') || fileName.includes('math')) {
                        jsonFiles.mathematics = file;
                    } else if (fileName.includes('physics')) {
                        jsonFiles.physics = file;
                    } else if (fileName.includes('chemistry') || fileName.includes('chem')) {
                        jsonFiles.chemistry = file;
                    }
                }
            }
            
            // Check if we found at least one JSON file
            const foundFiles = [jsonFiles.mathematics, jsonFiles.physics, jsonFiles.chemistry].filter(f => f !== null);
            if (foundFiles.length === 0) {
                alert('‚ö†Ô∏è No valid JSON files found. Please ensure your folder contains files with "mathematics", "physics", or "chemistry" in their names.');
                return;
            }
            
            console.log('‚úÖ Found JSON files:', {
                mathematics: jsonFiles.mathematics?.name || 'Not found',
                physics: jsonFiles.physics?.name || 'Not found',
                chemistry: jsonFiles.chemistry?.name || 'Not found'
            });
            
            // Load all found JSON files
            loadJSONFiles(jsonFiles);
        }
        
        // Load and parse JSON files
        function loadJSONFiles(jsonFiles) {
            const loadPromises = [];
            const subjectData = {
                mathematics: null,
                physics: null,
                chemistry: null
            };
            
            // Create promises for each file
            Object.keys(jsonFiles).forEach(subject => {
                if (jsonFiles[subject]) {
                    const promise = new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                let jsonData = JSON.parse(e.target.result);
                                
                                // Handle array format [{ tutorialId: ..., questions: [...] }]
                                if (Array.isArray(jsonData) && jsonData.length > 0) {
                                    console.log(`üì¶ ${subject} is an array, extracting first object`);
                                    jsonData = jsonData[0];
                                }
                                
                                console.log(`‚úÖ Loaded ${subject}:`, jsonData);
                                subjectData[subject] = jsonData;
                                resolve();
                            } catch (error) {
                                console.error(`‚ùå Error parsing ${subject} JSON:`, error);
                                reject(error);
                            }
                        };
                        reader.onerror = reject;
                        reader.readAsText(jsonFiles[subject]);
                    });
                    loadPromises.push(promise);
                }
            });
            
            // Wait for all files to load
            Promise.all(loadPromises)
                .then(() => {
                    console.log('‚úÖ All JSON files loaded successfully');
                    // populateUIFromJSON will handle Biology tab removal for local JSON folder uploads
                    populateUIFromJSON(subjectData, false); // false = not from Firebase, but also not .md
                    markWorkAsUnsaved();
                })
                .catch(error => {
                    console.error('‚ùå Error loading JSON files:', error);
                    alert('Error loading JSON files. Please check the console for details.');
                });
        }
        
        // Helper function to safely set form field values
        function safeSetValue(elementId, value) {
            const element = document.getElementById(elementId);
            if (element) {
                // For select elements, check if option exists, if not add it
                if (element.tagName === 'SELECT') {
                    // Check if the value exists as an option
                    const optionExists = Array.from(element.options).some(opt => opt.value === value);
                    if (!optionExists && value) {
                        // Add the option if it doesn't exist
                        const option = document.createElement('option');
                        option.value = value;
                        option.textContent = value;
                        element.appendChild(option);
                    }
                }
                element.value = value;
            } else {
                console.warn(`‚ö†Ô∏è Element not found: ${elementId}`);
            }
        }
        
        // Manage Biology tab visibility in subject-tabs-container
        function manageBiologyTabVisibility(show = false) {
            const subjectTabsContainer = document.getElementById('subjectTabsContainer');
            const biologyTab = document.getElementById('tab-Biology');
            
            if (!subjectTabsContainer) {
                console.warn('‚ö†Ô∏è subject-tabs-container not found');
                return;
            }
            
            if (show) {
                // Show Biology tab - restore if removed, or make visible if hidden
                if (!biologyTab) {
                    // Tab was removed, restore it
                    if (biologyTabElement) {
                        const restoredTab = biologyTabElement.cloneNode(true);
                        subjectTabsContainer.appendChild(restoredTab);
                        console.log('üîì Restored Biology tab in subject-tabs-container (from .md file)');
                    } else {
                        console.warn('‚ö†Ô∏è Cannot restore Biology tab - element not stored');
                    }
                } else {
                    // Tab exists, make sure it's visible
                    biologyTab.style.display = 'flex';
                    console.log('üîì Showing Biology tab in subject-tabs-container (from .md file)');
                }
            } else {
                // Hide Biology tab - remove from DOM
                if (biologyTab && biologyTab.parentNode) {
                    // Store a copy for restoration (only if not already stored)
                    if (!biologyTabElement) {
                        biologyTabElement = biologyTab.cloneNode(true);
                    }
                    // Remove the tab from DOM
                    biologyTab.remove();
                    console.log('üîí Removed Biology tab from subject-tabs-container (from Firebase/local JSON)');
                } else if (!biologyTab && biologyTabElement) {
                    // Tab already removed, ensure it stays removed
                    console.log('üîí Biology tab already removed from subject-tabs-container');
                }
            }
        }
        
        // Populate the UI with data from loaded JSON files
        function populateUIFromJSON(subjectData, isFromFirebase = false) {
            console.log('üé® Populating UI from JSON data...');
            
            // Track data source globally
            window.currentDataSource = isFromFirebase ? 'firebase' : 'local';
            
            // Clear existing data
            allQuestions = [];
            questionAssignments = {};
            
            // Get references to UI elements
            const sidebarStats = document.getElementById('sidebarStats');
            const sidebarDownload = document.getElementById('sidebarDownload');
            const subjectTabsContainer = document.getElementById('subjectTabsContainer');
            
            // IMPORTANT: Hide entire subject-tabs-container when loading from Firebase/local JSON
            // The tabs should only appear when loading from .md files
            if (isFromFirebase) {
                // Hide the entire tabs container when loading from Firebase
                if (subjectTabsContainer) {
                    subjectTabsContainer.style.display = 'none';
                    console.log('üîí ‚úÖ Hidden entire subject-tabs-container (loaded from Firebase)');
                }
            } else {
                // For local JSON folder uploads, also hide tabs
                if (subjectTabsContainer) {
                    subjectTabsContainer.style.display = 'none';
                    console.log('üîí ‚úÖ Hidden entire subject-tabs-container (loaded from local JSON folder)');
                }
            }
            
            // Show other UI panels
            if (sidebarStats) sidebarStats.style.display = 'block';
            if (sidebarDownload) sidebarDownload.style.display = 'block';
            
            // Don't show subject views yet - they will be shown by showSubject()
            // Just make sure they exist but are hidden
            const mathView = document.getElementById('subjectView-Mathematics');
            const physicsView = document.getElementById('subjectView-Physics');
            const chemistryView = document.getElementById('subjectView-Chemistry');
            const biologyView = document.getElementById('subjectView-Biology');
            
            if (mathView) mathView.style.display = 'none';
            if (physicsView) physicsView.style.display = 'none';
            if (chemistryView) chemistryView.style.display = 'none';
            if (biologyView) biologyView.style.display = 'none';
            
            // Load questions from each subject
            console.log('üì¶ Subject Data Structure:', {
                mathematics: subjectData.mathematics ? 'Found' : 'Missing',
                physics: subjectData.physics ? 'Found' : 'Missing',
                chemistry: subjectData.chemistry ? 'Found' : 'Missing',
                biology: subjectData.biology ? 'Found' : 'Missing'
            });
            
            ['mathematics', 'physics', 'chemistry', 'biology'].forEach((subject, subjectIndex) => {
                if (subjectData[subject]) {
                    console.log(`üìä ${subject} data:`, subjectData[subject]);
                    
                    if (subjectData[subject].questions) {
                        const questions = subjectData[subject].questions;
                        console.log(`üìù Loading ${questions.length} ${subject} questions...`);
                        
                        questions.forEach((questionData, index) => {
                            // Extract question details
                            const questionDetails = questionData.questionDetails ? questionData.questionDetails[0] : questionData;
                            const questionIndex = parseInt(questionData.questionIndex) || (subjectIndex * 25 + index + 1);
                            
                            // Convert options from object format {A: {text, image}} to array format ["text1", "text2", ...]
                            let optionsArray = ['', '', '', ''];
                            if (questionDetails.possibleAnswers) {
                                const possibleAnswers = questionDetails.possibleAnswers;
                                if (possibleAnswers.A && possibleAnswers.A.text) optionsArray[0] = `(1) ${possibleAnswers.A.text}`;
                                if (possibleAnswers.B && possibleAnswers.B.text) optionsArray[1] = `(2) ${possibleAnswers.B.text}`;
                                if (possibleAnswers.C && possibleAnswers.C.text) optionsArray[2] = `(3) ${possibleAnswers.C.text}`;
                                if (possibleAnswers.D && possibleAnswers.D.text) optionsArray[3] = `(4) ${possibleAnswers.D.text}`;
                            }
                            
                            // Create question object (using array format for options, just like .md parsing)
                            // Capitalize first letter of subject for consistency
                            const subjectCapitalized = subject.charAt(0).toUpperCase() + subject.slice(1);
                            const question = {
                                number: questionIndex,
                                subject: subject, // Keep lowercase for internal consistency
                                text: questionDetails.text || '',
                                solution: questionDetails.solution || '',
                                type: questionDetails.type || 'mcq',
                                options: optionsArray,  // Now always an array
                                answer: questionDetails.correctAnswer || '1',
                                correctAnswer: questionDetails.correctAnswer || '1',
                                correctAnswerText: questionDetails.correctAnswerText || '',
                                textImages: questionDetails.textImages || [],
                                solutionTextImages: questionDetails.solutionTextImages || [],
                                questionImages: questionDetails.textImages || [],
                                solutionImages: questionDetails.solutionTextImages || []
                            };
                            
                            
                            allQuestions.push(question);
                            questionAssignments[`Q${questionIndex}`] = subjectCapitalized; // Use capitalized for assignment
                        });
                    } else {
                        console.warn(`‚ö†Ô∏è No questions array found for ${subject}`);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è No data found for ${subject}`);
                }
            });
            
            console.log(`‚úÖ Loaded total ${allQuestions.length} questions`);
            console.log('All questions:', allQuestions);
            console.log('Question assignments:', questionAssignments);

// Sync Conducted By based on current board selections
syncConductedByAll();
            
            // Sort questions by number
            allQuestions.sort((a, b) => a.number - b.number);
            
            // Update statistics
            updateStats();
            
            // Now populate form fields FIRST (before showing subject, so values aren't overwritten)
            // Use longer timeout to ensure all views are rendered
            setTimeout(() => {
                console.log('üîç Attempting to populate form fields...');
                console.log('üì¶ Subject data available:', {
                    mathematics: !!subjectData.mathematics,
                    physics: !!subjectData.physics,
                    chemistry: !!subjectData.chemistry
                });
                
                if (subjectData.mathematics) {
                    console.log('üìã Mathematics data structure:', Object.keys(subjectData.mathematics));
                }
                
                // Use the first available subject data to populate main form fields
                // Priority: Mathematics > Physics > Chemistry > Biology
                const mainData = subjectData.mathematics || subjectData.physics || subjectData.chemistry || subjectData.biology;
                
                if (mainData) {
                    console.log('üìù Populating main form fields from JSON:', mainData);
                    console.log('   State:', mainData.state);
                    console.log('   Board:', mainData.board);
                    console.log('   Year:', mainData.year);
                    console.log('   Subject:', mainData.subject);
                    console.log('   Authority Exam ID:', mainData.authorityExamId);
                    console.log('   Day and Shift:', mainData.dayAndShift);
                    console.log('   Tutorial ID:', mainData.tutorialId);
                    console.log('   Tutorial Title:', mainData.tutorialTitle);
                    
                    // Update main form fields (used by all subjects)
                    // These fields are in the Mathematics view (first visible view)
                    const stateField = document.getElementById('state');
                    const boardField = document.getElementById('board');
                    const conductedByField = document.getElementById('conductedBy');
                    const yearField = document.getElementById('year');
                    const subjectField = document.getElementById('subject');
                    const authorityExamIdField = document.getElementById('authorityExamId');
                    const dayAndShiftField = document.getElementById('dayAndShift');
                    
                    console.log('üîç Field elements found:', {
                        state: !!stateField,
                        board: !!boardField,
                        conductedBy: !!conductedByField,
                        year: !!yearField,
                        subject: !!subjectField,
                        authorityExamId: !!authorityExamIdField,
                        dayAndShift: !!dayAndShiftField
                    });
                    
                    if (stateField && mainData.state) {
                        stateField.value = mainData.state;
                        stateField.dispatchEvent(new Event('change', { bubbles: true }));
                        console.log(`‚úÖ Set state to: ${mainData.state}`);
                    }
                    
                    if (boardField && mainData.board) {
                        boardField.value = mainData.board;
                        boardField.dispatchEvent(new Event('change', { bubbles: true }));
                        console.log(`‚úÖ Set board to: ${mainData.board}`);
                    }
                    
                    if (conductedByField && mainData.conductedBy) {
                        conductedByField.value = mainData.conductedBy;
                        conductedByField.dispatchEvent(new Event('change', { bubbles: true }));
                        console.log(`‚úÖ Set conductedBy to: ${mainData.conductedBy}`);
                    } else if (conductedByField && boardField) {
                        // Fallback: derive from board if not provided
                        setConductedByFromBoard(boardField.value, 'conductedBy');
                    }
                    
                    if (yearField && mainData.year) {
                        yearField.value = mainData.year;
                        yearField.dispatchEvent(new Event('change', { bubbles: true }));
                        console.log(`‚úÖ Set year to: ${mainData.year}`);
                    }
                    
                    if (subjectField && mainData.subject) {
                        const subjectValue = mainData.subject.charAt(0).toUpperCase() + mainData.subject.slice(1);
                        subjectField.value = subjectValue;
                        subjectField.dispatchEvent(new Event('change', { bubbles: true }));
                        console.log(`‚úÖ Set subject to: ${subjectValue}`);
                    }
                    
                    if (authorityExamIdField && mainData.authorityExamId) {
                        authorityExamIdField.value = mainData.authorityExamId;
                        authorityExamIdField.dispatchEvent(new Event('change', { bubbles: true }));
                        console.log(`‚úÖ Set authorityExamId to: ${mainData.authorityExamId}`);
                    }
                    
                    // Set dayAndShift - empty if not present
                    if (dayAndShiftField) {
                        dayAndShiftField.value = mainData.dayAndShift || '';
                        dayAndShiftField.dispatchEvent(new Event('change', { bubbles: true }));
                        console.log(`‚úÖ Set dayAndShift to: ${mainData.dayAndShift || '(empty)'}`);
                    }
                    
                    // Update Tutorial Title field
                    const tutorialTitleField = document.getElementById('tutorialTitle');
                    if (tutorialTitleField && mainData.tutorialTitle) {
                        tutorialTitleField.value = mainData.tutorialTitle;
                        tutorialTitleField.dispatchEvent(new Event('change', { bubbles: true }));
                        console.log(`‚úÖ Set tutorialTitle to: ${mainData.tutorialTitle}`);
                    }
                    
                    // Update Tutorial ID field (main field, not subject-specific)
                    const tutorialIdField = document.getElementById('tutorialId');
                    if (tutorialIdField && mainData.tutorialId) {
                        tutorialIdField.value = mainData.tutorialId;
                        tutorialIdField.dispatchEvent(new Event('change', { bubbles: true }));
                        console.log(`‚úÖ Set tutorialId to: ${mainData.tutorialId}`);
                    }
                    
                    // Verify fields were set
                    setTimeout(() => {
                        console.log('‚úÖ Field values after setting:');
                        console.log('   State:', document.getElementById('state')?.value);
                        console.log('   Board:', document.getElementById('board')?.value);
                        console.log('   Year:', document.getElementById('year')?.value);
                        console.log('   Subject:', document.getElementById('subject')?.value);
                        console.log('   Authority Exam ID:', document.getElementById('authorityExamId')?.value);
                        console.log('   Day and Shift:', document.getElementById('dayAndShift')?.value);
                        console.log('   Tutorial Title:', document.getElementById('tutorialTitle')?.value);
                        console.log('   Tutorial ID:', document.getElementById('tutorialId')?.value);
                    }, 100);
                    
                    // Update tutorial description if available
                    const tutorialDescriptionField = document.getElementById('tutorialDescription');
                    if (tutorialDescriptionField && mainData.tutorialDescription) {
                        tutorialDescriptionField.value = mainData.tutorialDescription;
                    }
                } else {
                    console.warn('‚ö†Ô∏è No subject data available to populate form fields');
                }
                
                // Update Mathematics-specific fields
                if (subjectData.mathematics) {
                    const mathData = subjectData.mathematics;
                    // Use tutorialId directly from JSON (don't regenerate)
                    safeSetValue('tutorialId', mathData.tutorialId || '');
                    safeSetValue('tutorialTitle', mathData.tutorialTitle || '');
                    safeSetValue('authorityExamId', mathData.authorityExamId || '');
                    // Set dayAndShift to empty if not present
                    safeSetValue('dayAndShift', mathData.dayAndShift || '');
                }
                
                // Update Physics-specific fields
                if (subjectData.physics) {
                    const physicsData = subjectData.physics;
                    // Use tutorialId directly from JSON (don't regenerate)
                    safeSetValue('tutorialId-physics', physicsData.tutorialId || '');
                    safeSetValue('tutorialTitle-physics', physicsData.tutorialTitle || '');
                    safeSetValue('authorityExamId-physics', physicsData.authorityExamId || '');
                    // Set dayAndShift to empty if not present
                    safeSetValue('dayAndShift-physics', physicsData.dayAndShift || '');
                }
                
                // Update Chemistry-specific fields
                if (subjectData.chemistry) {
                    const chemData = subjectData.chemistry;
                    // Use tutorialId directly from JSON (don't regenerate)
                    safeSetValue('tutorialId-chemistry', chemData.tutorialId || '');
                    safeSetValue('tutorialTitle-chemistry', chemData.tutorialTitle || '');
                    safeSetValue('authorityExamId-chemistry', chemData.authorityExamId || '');
                    // Set dayAndShift to empty if not present
                    safeSetValue('dayAndShift-chemistry', chemData.dayAndShift || '');
                }
                
                // Update Biology-specific fields
                if (subjectData.biology) {
                    const bioData = subjectData.biology;
                    // Use tutorialId directly from JSON (don't regenerate)
                    safeSetValue('tutorialId-biology', bioData.tutorialId || '');
                    safeSetValue('tutorialTitle-biology', bioData.tutorialTitle || '');
                    safeSetValue('authorityExamId-biology', bioData.authorityExamId || '');
                    // Set dayAndShift to empty if not present
                    safeSetValue('dayAndShift-biology', bioData.dayAndShift || '');
                }
                
                console.log('‚úÖ All form fields populated from JSON data');
                
                // Determine which subject has data (for Firebase loads, show that subject)
                let subjectToShow = 'Mathematics'; // default
                if (subjectData.mathematics && subjectData.mathematics.questions && subjectData.mathematics.questions.length > 0) {
                    subjectToShow = 'Mathematics';
                } else if (subjectData.physics && subjectData.physics.questions && subjectData.physics.questions.length > 0) {
                    subjectToShow = 'Physics';
                } else if (subjectData.chemistry && subjectData.chemistry.questions && subjectData.chemistry.questions.length > 0) {
                    subjectToShow = 'Chemistry';
                } else if (subjectData.biology && subjectData.biology.questions && subjectData.biology.questions.length > 0) {
                    subjectToShow = 'Biology';
                }
                
                // NOW show subject AFTER fields are populated (so values aren't overwritten)
                setTimeout(() => {
                    console.log(`üéØ Calling showSubject(${subjectToShow})...`);
                    showSubject(subjectToShow);
                    
                    // Show viewer toggle buttons (they're hidden by default)
                    const viewerToggle = document.getElementById(`viewerToggle-${subjectToShow}`);
                    if (viewerToggle) {
                        viewerToggle.style.display = 'flex';
                        console.log(`‚úÖ Showing viewer toggle for ${subjectToShow}`);
                        // Ensure Edit is selected by default
                        switchViewer(subjectToShow, 'editor');
                    }
                    
                    // Populate editor fields for the loaded subject
                    setTimeout(() => {
                        console.log(`üìù Populating editor fields for ${subjectToShow}...`);
                        populateInlineEditFields(subjectToShow);
                        
                        // Auto-select first question and load into editor
                        setTimeout(() => {
                            console.log('üéØ Auto-selecting first question...');
                            const firstQuestionBtn = document.querySelector(`#questionList-${subjectToShow} .question-item`);
                            if (firstQuestionBtn) {
                                firstQuestionBtn.click();
                                console.log('‚úÖ First question selected');
                                
                                // After question is selected, switch to Live Preview (unless skipAutoPreviewSwitch is set)
                                if (!skipAutoPreviewSwitch) {
                                    setTimeout(() => {
                                        console.log('üëÅÔ∏è Switching to Live Preview...');
                                        switchViewer(subjectToShow, 'preview');
                                        console.log('‚úÖ Live Preview loaded');
                                    }, 300);
                                } else {
                                    console.log('‚è≠Ô∏è Skipping automatic preview switch (upload context)');
                                    window.skipAutoPreviewSwitch = false; // Reset flag
                                }
                            } else {
                                console.warn('‚ö†Ô∏è First question button not found');
                                // Still try to show Live Preview even if no questions (unless skipAutoPreviewSwitch is set)
                                if (!skipAutoPreviewSwitch) {
                                    setTimeout(() => {
                                        switchViewer(subjectToShow, 'preview');
                                    }, 300);
                                } else {
                                    window.skipAutoPreviewSwitch = false; // Reset flag
                                }
                            }
                        }, 200);
                    }, 200);
                }, 100);
            }, 100);
            
            alert(`‚úÖ Successfully loaded ${allQuestions.length} questions!\n\n` +
                  `üìä Mathematics: ${allQuestions.filter(q => q.subject === 'mathematics').length} questions\n` +
                  `‚öõÔ∏è Physics: ${allQuestions.filter(q => q.subject === 'physics').length} questions\n` +
                  `‚öõÔ∏è Chemistry: ${allQuestions.filter(q => q.subject === 'chemistry').length} questions\n` +
                  `üß¨ Biology: ${allQuestions.filter(q => q.subject === 'biology').length} questions`);
        }
        
        // Function to extract image URLs from text
        function extractImageUrls(text) {
            if (!text) return [];
            
            const images = [];
            
            // Extract markdown images: ![](url) or ![alt](url)
            const markdownMatches = text.match(/!\[([^\]]*)\]\(([^)]+)\)/g);
            if (markdownMatches) {
                markdownMatches.forEach(match => {
                    const urlMatch = match.match(/!\[([^\]]*)\]\(([^)]+)\)/);
                    if (urlMatch && urlMatch[2]) {
                        images.push(urlMatch[2].trim());
                    }
                });
            }
            
            // Extract HTML img tags: <img src="url" ...>
            const htmlMatches = text.match(/<img[^>]+src=["']([^"']+)["'][^>]*>/gi);
            if (htmlMatches) {
                htmlMatches.forEach(match => {
                    const srcMatch = match.match(/src=["']([^"']+)["']/i);
                    if (srcMatch && srcMatch[1]) {
                        images.push(srcMatch[1].trim());
                    }
                });
            }
            
            // Extract direct image URLs (http/https)
            const urlMatches = text.match(/https?:\/\/[^\s<>)]+\.(jpg|jpeg|png|gif|svg|webp|bmp)(\?[^\s<>)]*)?/gi);
            if (urlMatches) {
                urlMatches.forEach(url => {
                    if (!images.includes(url.trim())) {
                        images.push(url.trim());
                    }
                });
            }
            
            // Extract data URLs (base64 images)
            const dataUrlMatches = text.match(/data:image\/[^;]+;base64,[A-Za-z0-9+/=]+/g);
            if (dataUrlMatches) {
                dataUrlMatches.forEach(url => {
                    if (!images.includes(url.trim())) {
                        images.push(url.trim());
                    }
                });
            }
            
            return images;
        }
        
        // Function to clean image tags and URLs from text
        function cleanImageReferences(text) {
            if (!text) return text;
            
            // Remove HTML img tags (both self-closing and with closing tag)
            text = text.replace(/<img[^>]*\/?>/gi, '[Image]');
            
            // Remove markdown image syntax ![](url)
            text = text.replace(/!\[\]\([^)]+\)/g, '[Image]');
            
            // Remove markdown image syntax ![alt](url)
            text = text.replace(/!\[[^\]]*\]\([^)]+\)/g, '[Image]');
            
            // Remove any remaining image URLs (http/https)
            text = text.replace(/https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|svg|webp|bmp)(\?[^\s]*)?/gi, '[Image]');
            
            // Remove data URLs (base64 images)
            text = text.replace(/data:image\/[^;]+;base64,[A-Za-z0-9+/=]+/g, '[Image]');
            
            // Clean up multiple consecutive [Image] placeholders
            text = text.replace(/\[Image\]\s*\[Image\]/g, '[Image]');
            
            // Clean up extra whitespace
            text = text.replace(/\s+/g, ' ').trim();
            
            return text;
        }
        
        // Function that extracts images and cleans text simultaneously
        function extractAndCleanImages(text) {
            if (!text) return { text: '', images: [] };
            
            const images = extractImageUrls(text);
            const cleanedText = cleanImageReferences(text);
            
            // Convert image URLs to objects with image property (format expected by UI)
            const imageObjects = images.map(url => ({ image: url, text: '' }));
            
            return { text: cleanedText, images: imageObjects };
        }
        
        // Function to remove [Image] placeholder text when images are actually present
        function removeImagePlaceholders(text, images) {
            if (!text) return text;
            
            // If images exist, remove [Image] placeholders from text
            if (images && Array.isArray(images) && images.length > 0) {
                // Check if images array has actual image data
                const hasImages = images.some(img => {
                    if (!img) return false;
                    if (typeof img === 'string') return img.length > 0; // URL string
                    if (typeof img === 'object') return img.image && img.image.length > 0; // Object with image property
                    return false;
                });
                
                if (hasImages) {
                    // Remove [Image] placeholder text (case-insensitive, all occurrences)
                    text = text.replace(/\[Image\]/gi, '');
                    // Clean up extra whitespace that might result
                    text = text.replace(/\s+/g, ' ').trim();
                }
            }
            
            return text;
        }
        
        // Function to remove [Image] text from preview display (always removes, regardless of images)
        function removeImageTextFromPreview(text) {
            if (!text) return text;
            // Remove [Image] placeholder text (case-insensitive, all occurrences)
            text = text.replace(/\[Image\]/gi, '');
            // Clean up extra whitespace that might result
            text = text.replace(/\s+/g, ' ').trim();
            return text;
        }
        
        function parseExamDetails(content, currentSubject = 'Mathematics') {
            const lines = content.split('\n');
            let examDetails = {
                examType: 'JEE Main',
                board: 'JEE Main',
                state: 'Center',
                conductedBy: 'National Testing Agency (NTA)',
                date: '',
                shift: '',
                dayAndShift: '2 April 2025 Shift - 2',
                tutorialTitle: `JEE Main, ${currentSubject} - 2 April 2025 Shift - 2`
            };
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Stop scanning when we reach "## IMPORTANT INSTRUCTIONS:"
                if (line.includes('## IMPORTANT INSTRUCTIONS:')) {
                    break;
                }
                
                // Check for JEE Main pattern
                if (line.includes('JEE (Main)') || line.includes('JEE Main')) {
                    examDetails.examType = 'JEE Main';
                    examDetails.board = 'JEE Main';
                    examDetails.state = 'Center';
                    examDetails.conductedBy = 'National Testing Agency (NTA)';
                }
                
                // Check for JEE Advanced pattern
                if (line.includes('JEE (Advanced)') || line.includes('JEE Advanced')) {
                    examDetails.examType = 'JEE Advanced';
                    examDetails.board = 'JEE Advanced';
                    examDetails.state = 'Center';
                    examDetails.conductedBy = 'Indian Institute of Technology (IIT)';
                }
                
                // Check for NEET pattern
                if (line.includes('NEET') || line.includes('National Eligibility cum Entrance Test')) {
                    examDetails.examType = 'NEET';
                    examDetails.board = 'NEET';
                    examDetails.state = 'Center';
                    examDetails.conductedBy = 'National Testing Agency (NTA)';
                }
                
                // Check for KCET pattern
                if (line.includes('KCET') || line.includes('Karnataka Common Entrance Test')) {
                    examDetails.examType = 'KCET';
                    examDetails.board = 'KCET';
                    examDetails.state = 'Karnataka';
                    examDetails.conductedBy = 'Karnataka Examinations Authority (KEA)';
                }
                
                // Check for day and shift pattern (e.g., "## 2 April 2025 Shift - 2")
                const dayShiftMatch = line.match(/##\s*(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})\s+Shift\s*-\s*(\d+)/i);
                if (dayShiftMatch) {
                    const day = dayShiftMatch[1];
                    const month = dayShiftMatch[2];
                    const year = dayShiftMatch[3];
                    const shift = dayShiftMatch[4];
                    
                    examDetails.date = `${day} ${month} ${year}`;
                    examDetails.shift = `Shift - ${shift}`;
                    examDetails.dayAndShift = `${day} ${month} ${year} Shift - ${shift}`;
                }
                
                // Check for date pattern (e.g., "2 April 2025")
                const dateMatch = line.match(/(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})/i);
                if (dateMatch && !examDetails.date) {
                    examDetails.date = `${dateMatch[1]} ${dateMatch[2]} ${dateMatch[3]}`;
                }
                
                // Check for shift pattern (e.g., "Shift - 2")
                const shiftMatch = line.match(/Shift\s*-\s*(\d+)/i);
                if (shiftMatch && !examDetails.shift) {
                    examDetails.shift = `Shift - ${shiftMatch[1]}`;
                }
                
                // Check for session pattern (e.g., "Session-2")
                const sessionMatch = line.match(/Session\s*-\s*(\d+)/i);
                if (sessionMatch && !examDetails.shift) {
                    examDetails.shift = `Session - ${sessionMatch[1]}`;
                }
                
                // Build tutorial title with current subject
                if (examDetails.date && examDetails.shift) {
                    examDetails.tutorialTitle = `${examDetails.examType}, ${currentSubject} - ${examDetails.date} ${examDetails.shift}`;
                } else if (examDetails.date) {
                    examDetails.tutorialTitle = `${examDetails.examType}, ${currentSubject} - ${examDetails.date}`;
                } else {
                    examDetails.tutorialTitle = `${examDetails.examType}, ${currentSubject}`;
                }
            }
            
            return examDetails;
        }
        
        function updateTutorialFields(examDetails) {
            // Update Tutorial Title
            const tutorialTitleField = document.getElementById('tutorialTitle');
            if (tutorialTitleField) {
                tutorialTitleField.value = examDetails.tutorialTitle;
            }
            
            // Update Authority Exam ID
            const authorityExamIdField = document.getElementById('authorityExamId');
            if (authorityExamIdField) {
                authorityExamIdField.value = examDetails.examType;
            }
            
            // Update Board
            const boardField = document.getElementById('board');
            if (boardField) {
                boardField.value = examDetails.board;
            }
            
            // Update State
            const stateField = document.getElementById('state');
            if (stateField) {
                stateField.value = examDetails.state;
            }
            
            // Update Conducted By (fallback to board mapping if missing)
            const conductedByField = document.getElementById('conductedBy');
            if (conductedByField) {
                if (examDetails.conductedBy) {
                    conductedByField.value = examDetails.conductedBy;
                } else {
                    setConductedByFromBoard(examDetails.board || boardField.value, 'conductedBy');
                }
            }
            
            // Update Date
            const dateField = document.getElementById('date');
            if (dateField) {
                dateField.value = examDetails.date;
            }
            
            // Update Shift
            const shiftField = document.getElementById('shift');
            if (shiftField) {
                shiftField.value = examDetails.shift;
            }
            
            // Update Year (extract from date if available)
            const yearField = document.getElementById('year');
            let year = '2025'; // default year
            if (yearField && examDetails.date) {
                const yearMatch = examDetails.date.match(/(\d{4})/);
                if (yearMatch) {
                    year = yearMatch[1];
                    yearField.value = year;
                }
            }
            
            // Update Day and Shift field
            const dayAndShiftField = document.getElementById('dayAndShift');
            if (dayAndShiftField) {
                dayAndShiftField.value = examDetails.dayAndShift;
            }
            
            // Generate Tutorial ID for Mathematics (default subject on upload)
            updateTutorialId('Mathematics', examDetails.board, year);
            
            // Trigger real-time JSON update
            updateJSONInRealTime('');
        }
        
        function updateTutorialTitleOnly(subject) {
            // Get current exam details from existing fields
            const authorityExamIdField = document.getElementById('authorityExamId');
            const dateField = document.getElementById('date');
            const shiftField = document.getElementById('shift');
            const boardField = document.getElementById('board');
            const yearField = document.getElementById('year');
            const stateField = document.getElementById('state');
            const conductedByField = document.getElementById('conductedBy');
            
            // Get board and other details from form fields (don't hardcode - use existing values from JSON)
            // Use subject-specific fields if they exist, otherwise use main fields
            const boardSuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
            const stateSuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
            const conductedBySuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
            const authoritySuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
            
            // Try to get values from subject-specific fields first, then fall back to main fields
            const subjectBoardField = document.getElementById(`board${boardSuffix}`);
            const subjectStateField = document.getElementById(`state${stateSuffix}`);
            const subjectConductedByField = document.getElementById(`conductedBy${conductedBySuffix}`);
            const subjectAuthorityField = document.getElementById(`authorityExamId${authoritySuffix}`);
            
            // Get values from fields (they should already be populated from JSON)
            let board = subjectBoardField ? subjectBoardField.value : (boardField ? boardField.value : 'KCET');
            let state = subjectStateField ? subjectStateField.value : (stateField ? stateField.value : 'Karnataka');
            let conductedBy = subjectConductedByField ? subjectConductedByField.value : (conductedByField ? conductedByField.value : '');
            let examType = subjectAuthorityField ? subjectAuthorityField.value : 'kar_kect';
            
            // If fields are empty, use defaults (but prefer values from JSON)
            if (!board || board === '') {
                board = 'KCET'; // Default, but should be set from JSON
            }
            if (!state || state === '') {
                state = 'Karnataka'; // Default, but should be set from JSON
            }
            if ((!conductedBy || conductedBy === '') && board) {
                conductedBy = getConductedByForBoard(board);
                if (subjectConductedByField && conductedBy) {
                    setConductedByFromBoard(board, `conductedBy${conductedBySuffix}`);
                }
            }
            if (!examType || examType === '') {
                examType = 'kar_kect'; // Default, but should be set from JSON
            }
            
            const date = dateField ? dateField.value : '';
            const shift = shiftField ? shiftField.value : '';
            const year = yearField ? yearField.value : '2025';
            
            console.log(`Tab switch to ${subject}: Board="${board}", Year="${year}", ExamType="${examType}"`);
            
            // Update Board field (subject-specific) - only if it's different from current value
            if (subjectBoardField && subjectBoardField.value !== board) {
                subjectBoardField.value = board;
            }
            
            // Update State field (subject-specific) - only if it's different from current value
            if (subjectStateField && subjectStateField.value !== state) {
                subjectStateField.value = state;
            }
            
            // Update Conducted By field (subject-specific) - only if it's different from current value
            if (subjectConductedByField && subjectConductedByField.value !== conductedBy) {
                subjectConductedByField.value = conductedBy;
            }
            
            // Update Authority Exam ID field (subject-specific) - only if it's different from current value
            if (subjectAuthorityField && subjectAuthorityField.value !== examType) {
                subjectAuthorityField.value = examType;
            }
            
            // Update Day and Shift field (subject-specific)
            const dayShiftSuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
            const subjectDayShiftField = document.getElementById(`dayAndShift${dayShiftSuffix}`);
            if (subjectDayShiftField) {
                // Get the current day and shift value from the main field
                const mainDayShiftField = document.getElementById('dayAndShift');
                if (mainDayShiftField) {
                    subjectDayShiftField.value = mainDayShiftField.value;
                }
            }
            
            // Build new tutorial title with current subject
            let newTitle = `${examType}, ${subject}`;
            if (date && shift) {
                newTitle = `${examType}, ${subject} - ${date} ${shift}`;
            } else if (date) {
                newTitle = `${examType}, ${subject} - ${date}`;
            }
            
            // Update Tutorial Title field (subject-specific)
            const titleSuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
            const subjectTutorialTitleField = document.getElementById(`tutorialTitle${titleSuffix}`);
            if (subjectTutorialTitleField) {
                subjectTutorialTitleField.value = newTitle;
            }
            
            // Generate and update Tutorial ID based on CURRENT Board, Year, and Subject
            updateTutorialId(subject, board, year);
            
            // Trigger real-time JSON update
            updateJSONInRealTime('');
        }
        
        function updateTutorialId(subject, board, year) {
            // Get the Day and Shift field value
            const dayShiftSuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
            const dayShiftField = document.getElementById(`dayAndShift${dayShiftSuffix}`);
            
            let tutorialId = '';
            
            if (dayShiftField && dayShiftField.value) {
                // Parse the day and shift value (e.g., "2 April 2025 Shift - 2")
                const dayShiftValue = dayShiftField.value.trim();
                
                // Extract components from day and shift string
                const dayShiftMatch = dayShiftValue.match(/(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})\s+Shift\s*-\s*(\d+)/i);
                
                if (dayShiftMatch) {
                    const day = dayShiftMatch[1];
                    const month = dayShiftMatch[2].toLowerCase();
                    const year = dayShiftMatch[3];
                    const shift = dayShiftMatch[4];
                    const subjectId = subject.toLowerCase();
                    
                    // Convert board to lowercase and replace spaces with underscores
                    // Safety check: if board is undefined, try to get from form fields
                    let actualBoard = board;
                    if (!actualBoard) {
                        const boardSuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
                        const boardField = document.getElementById(`board${boardSuffix}`);
                        actualBoard = boardField ? boardField.value : 'KCET';
                    }
                    const boardId = actualBoard ? actualBoard.toLowerCase().replace(/\s+/g, '_') : 'kcet';
                    
                    // Generate tutorial ID: board_day_month_year_subject_shift_shiftNumber
                    tutorialId = `${boardId}_${day}_${month}_${year}_${subjectId}_shift_${shift}`;
                } else {
                    // Fallback to old format if parsing fails
                    // Safety check: if board or year is undefined, try to get from form fields
                    let actualBoard = board;
                    let actualYear = year;
                    
                    if (!actualBoard) {
                        const boardSuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
                        const boardField = document.getElementById(`board${boardSuffix}`);
                        actualBoard = boardField ? boardField.value : 'KCET';
                    }
                    
                    if (!actualYear) {
                        const yearSuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
                        const yearField = document.getElementById(`year${yearSuffix}`);
                        actualYear = yearField ? yearField.value : '2025';
                    }
                    
                    const boardId = actualBoard ? actualBoard.replace(/\s+/g, '_') : 'KCET';
                    const subjectId = subject.toLowerCase();
                    tutorialId = `${boardId}_${actualYear}_${subjectId}`;
                }
            } else {
                // Fallback to old format if no day and shift value
                // Safety check: if board or year is undefined, try to get from form fields
                let actualBoard = board;
                let actualYear = year;
                
                if (!actualBoard) {
                    const boardSuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
                    const boardField = document.getElementById(`board${boardSuffix}`);
                    actualBoard = boardField ? boardField.value : 'KCET';
                }
                
                if (!actualYear) {
                    const yearSuffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
                    const yearField = document.getElementById(`year${yearSuffix}`);
                    actualYear = yearField ? yearField.value : '2025';
                }
                
                const boardId = actualBoard ? actualBoard.replace(/\s+/g, '_') : 'KCET';
                const subjectId = subject.toLowerCase();
                tutorialId = `${boardId}_${actualYear}_${subjectId}`;
            }
            
            console.log(`Updating Tutorial ID for ${subject}: Board="${board}", Year="${year}", DayShift="${dayShiftField ? dayShiftField.value : 'N/A'}", ID="${tutorialId}"`);
            
            // Update Tutorial ID field based on subject
            const suffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
            const tutorialIdField = document.getElementById(`tutorialId${suffix}`);
            if (tutorialIdField) {
                tutorialIdField.value = tutorialId;
                console.log(`Updated Tutorial ID field ${tutorialIdField.id} to: ${tutorialId}`);
            } else {
                console.log(`Tutorial ID field not found: tutorialId${suffix}`);
            }
        }
        
        function parseQuestions(content) {
            console.log('Parsing questions from content...');
            
            const lines = content.split('\n');
            const questions = [];
            let currentQuestion = null;
            // Helper function to determine subject based on question number
            function getSubjectByQuestionNumber(questionNumber) {
                if (questionNumber >= 1 && questionNumber <= 25) {
                    return 'mathematics';
                } else if (questionNumber >= 26 && questionNumber <= 50) {
                    return 'physics';
                } else if (questionNumber >= 51 && questionNumber <= 75) {
                    return 'chemistry';
                }
                return 'unassigned';
            }
            let debugContent = '';
            let inSolution = false;
            // Option capture state for inline options like "... (1) ... (2) ..."
            let inOptionCapture = false;
            let currentOptionNumber = 0;
            // Track when we're in a Quick Tip section to skip content
            let inQuickTip = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Skip empty lines
                if (line === '') continue;
                
                // Skip all content when in Quick Tip section until next question
                if (inQuickTip) {
                    const nextQuestionMatch = line.match(/^(\d+)\.\s*(.*)/);
                    if (nextQuestionMatch && !line.match(/^\d+\.\d/) && !/continued/i.test(nextQuestionMatch[2] || '')) {
                        inQuickTip = false;
                        debugContent += `<div style=\"color: #6c757d; margin: 2px 0;\">Line ${i+1}: Exiting Quick Tip section, found next question ${nextQuestionMatch[1]}</div>`;
                        // Continue processing this line as a new question
                    } else {
                        debugContent += `<div style=\"color: #6c757d; margin: 2px 0;\">Line ${i+1}: Skipping Quick Tip content: ${line.substring(0, 50)}...</div>`;
                        continue;
                    }
                }
                
                const lowerLine = line.toLowerCase();
                
                // Check for new question - number followed by dot
                let questionMatch = line.match(/^(\d+)\.\s*(.*)/);
                
                // Additional check: make sure it's not a decimal number
                if (questionMatch && line.match(/^\d+\.\d/)) {
                    debugContent += `<div style="color: #ffc107; margin: 2px 0;">Line ${i+1}: Ignored decimal number: ${line.substring(0, 50)}...</div>`;
                    questionMatch = null;
                }
                
                    // Handle lines like "4. Continued." as part of previous solution, not a new question
                    if (questionMatch && /continued/i.test(questionMatch[2] || '')) {
                        if (currentQuestion) {
                            // Treat as continuation of solution
                            inSolution = true;
                            const continuedResult = extractAndCleanImages(line);
                            currentQuestion.solution += '\n' + continuedResult.text;
                            // Add extracted images to solution images
                            if (continuedResult.images.length > 0) {
                                console.log(`üì∏ Q${currentQuestion.number}: Extracted ${continuedResult.images.length} image(s) from continued solution line`);
                                currentQuestion.solutionTextImages = (currentQuestion.solutionTextImages || []).concat(continuedResult.images);
                            }
                            debugContent += `<div style="color: #ffc107; margin: 2px 0;">Line ${i+1}: Continued solution detected.</div>`;
                            continue;
                        }
                    }
                
                if (questionMatch) {
                    // Save previous question if it exists
                    if (currentQuestion) {
                        // Convert markdown tables to HTML before saving
                        if (currentQuestion.text) {
                            currentQuestion.text = convertMarkdownTablesToHTML(currentQuestion.text);
                        }
                        if (currentQuestion.solution) {
                            currentQuestion.solution = convertMarkdownTablesToHTML(currentQuestion.solution);
                        }
                        // Convert tables in options as well
                        if (currentQuestion.options && Array.isArray(currentQuestion.options)) {
                            currentQuestion.options = currentQuestion.options.map(opt => 
                                opt ? convertMarkdownTablesToHTML(opt) : opt
                            );
                        }
                        questions.push(currentQuestion);
                    }
                    
                    // Start new question
                    // Extract images from question text
                    const questionTextResult = extractAndCleanImages(questionMatch[2]);
                    if (questionTextResult.images && questionTextResult.images.length > 0) {
                        console.log(`üì∏ Q${parseInt(questionMatch[1])}: Extracted ${questionTextResult.images.length} image(s) from question text`);
                    }
                    const questionNumber = parseInt(questionMatch[1]);
                    currentQuestion = {
                        number: questionNumber,
                        text: questionTextResult.text,
                        textImages: questionTextResult.images, // Store extracted images
                        options: [],
                        optionImages: [[], [], [], []], // Initialize option images arrays
                        answer: '',
                        solution: '',
                        solutionTextImages: [], // Initialize solution images array
                        subject: getSubjectByQuestionNumber(questionNumber),
                        type: 'mcq', // Default type, will be auto-detected
                        fullContent: questionTextResult.text
                    };
                    console.log(`üìù Question ${questionNumber} assigned to subject: ${currentQuestion.subject}`);
                    inSolution = false;
                    inOptionCapture = false;
                    currentOptionNumber = 0;
                    inQuickTip = false;
                    
                    debugContent += `<div style="color: #28a745; margin: 2px 0; font-weight: bold;">Line ${i+1}: Found question ${currentQuestion.number}: ${questionMatch[2].substring(0, 100)}...</div>`;
                } else if (currentQuestion) {
                    // Check for "Correct Answer:" format
                    if (lowerLine.startsWith('correct answer')) {
                        // Accept both formats: (3) or 3
                        const caMatch = line.match(/Correct Answer:\s*(?:\(([1-4])\)|([1-4]))/i);
                        if (caMatch) {
                            currentQuestion.answer = (caMatch[1] || caMatch[2]);
                            debugContent += `<div style=\"color: #dc3545; margin: 2px 0;\">Line ${i+1}: Found correct answer: ${line}</div>`;
                        }
                        // Do not auto-enter solution mode yet; wait for explicit Solution header
                        // End option capture when correct answer encountered
                        inOptionCapture = false;
                        currentOptionNumber = 0;
                    }
                    // Check if we hit explicit Solution header
                    else if (lowerLine.startsWith('## solution') || /\\section\*\{\s*solution\s*:?\s*\}/i.test(line)) {
                        inSolution = true;
                        currentQuestion.solution = '';
                        debugContent += `<div style="color: #ffc107; margin: 2px 0;">Line ${i+1}: Started solution collection (Solution header).</div>`;
                    }
                    // Backward compatibility: older format had "Ans." then solution lines
                    else if (line.startsWith('Ans.')) {
                        // First try to match (1), (2), (3), (4) format for MCQ questions
                        const mcqAnswerMatch = line.match(/^Ans\.\s*\(([1-4])\)/);
                        if (mcqAnswerMatch) {
                            currentQuestion.answer = mcqAnswerMatch[1];
                            debugContent += `<div style="color: #dc3545; margin: 2px 0;">Line ${i+1}: Found MCQ answer: ${line}</div>`;
                        } else {
                            // For fill-in-the-blank or integer questions: Extract any number/text in parentheses
                            const fillBlankAnswerMatch = line.match(/^Ans\.\s*\((.+)\)/);
                            if (fillBlankAnswerMatch) {
                                const answerValue = fillBlankAnswerMatch[1].trim();
                                currentQuestion.answer = answerValue;
                                // Mark as fill-in-the-blank or integer type if not already set
                                if (!currentQuestion.type || currentQuestion.type === 'mcq') {
                                    // Check if question text contains fill-in-the-blank marker
                                    if (/\$\_\_\_\_\$/.test(currentQuestion.text)) {
                                        currentQuestion.type = 'fillblank';
                                    } else {
                                        // Check if answer is a number (integer type)
                                        if (/^\d+(\.\d+)?$/.test(answerValue)) {
                                            currentQuestion.type = 'integer';
                                        } else {
                                            currentQuestion.type = 'fillblank';
                                        }
                                    }
                                }
                                debugContent += `<div style="color: #dc3545; margin: 2px 0;">Line ${i+1}: Found fill-in-the-blank/integer answer: ${answerValue}</div>`;
                            }
                        }
                        
                        // Start collecting solution - but don't include "Ans. (X)" line itself
                        inSolution = true;
                        currentQuestion.solution = '';  // Start with empty, will collect from next lines
                        debugContent += `<div style="color: #ffc107; margin: 2px 0;">Line ${i+1}: Answer found, ready to collect solution from next lines.</div>`;
                    }
                    // Check for "Sol." marker - this is where solution actually starts
                    else if (line.trim().startsWith('Sol.')) {
                        inSolution = true;
                        // Don't include "Sol." marker itself, start from content after it
                        const solContent = line.replace(/^Sol\.\s*/, '').trim();
                        if (currentQuestion && solContent) {
                            const solResult = extractAndCleanImages(solContent);
                            currentQuestion.solution = solResult.text;
                            // Add extracted images to solution images array
                            if (solResult.images.length > 0) {
                                console.log(`üì∏ Q${currentQuestion.number}: Extracted ${solResult.images.length} image(s) from solution (Sol. line)`);
                                currentQuestion.solutionTextImages = (currentQuestion.solutionTextImages || []).concat(solResult.images);
                            }
                        } else if (currentQuestion) {
                            currentQuestion.solution = '';
                            currentQuestion.solutionTextImages = [];
                        }
                        debugContent += `<div style="color: #ffc107; margin: 2px 0;">Line ${i+1}: Solution marker found, started collecting.</div>`;
                    }
                    // Skip "## TEST PAPER WITH SOLUTION" lines
                    else if (/TEST\s+PAPER\s+WITH\s+SOLUTION/i.test(line)) {
                        debugContent += `<div style="color: #999; margin: 2px 0;">Line ${i+1}: Skipping unwanted header: ${line.substring(0, 50)}...</div>`;
                        continue;
                    }
                    // Check for options (1), (2), (3), (4) - only if not in solution
                    else if (!inSolution) {
                        // Check if this is a fill-in-the-blank question (has $\_\_\_\_$)
                        const isFillInTheBlank = /\$\_\_\_\_\$/.test(currentQuestion.text + '\n' + line);
                        
                        // Support inline options: (1)...(2)...(3)...(4)... possibly across lines
                        // But don't treat "Correct Answer: (3)" as option markers
                        const hasAnyOptionMarker = /(\(1\)|\(2\)|\(3\)|\(4\))/.test(line) && !lowerLine.startsWith('correct answer');
                        
                        if ((hasAnyOptionMarker || inOptionCapture) && !isFillInTheBlank) {
                            // Initialize options array to fixed 4 slots on first encounter
                            if (!inOptionCapture) {
                                inOptionCapture = true;
                                currentOptionNumber = 0;
                                currentQuestion.options = ['', '', '', ''];
                                currentQuestion.optionImages = [[], [], [], []]; // Store images for each option
                            }
                            // Process markers in this line sequentially
                            let remaining = line;
                            // Helper to consume next marker and capture text until next marker or end
                            const markers = ['(1)', '(2)', '(3)', '(4)'];
                            while (remaining.length > 0) {
                                // Find next marker index among 1..4 that is >= currentOptionNumber+1
                                let nextIdx = -1;
                                let nextWhich = -1;
                                for (let m = 0; m < 4; m++) {
                                    const idx = remaining.indexOf(markers[m]);
                                    if (idx !== -1 && (nextIdx === -1 || idx < nextIdx)) {
                                        nextIdx = idx;
                                        nextWhich = m + 1; // option number
                                    }
                                }
                                if (nextIdx === -1) {
                                    // No marker in remaining; append to current option if we started
                                    if (currentOptionNumber >= 1 && currentOptionNumber <= 4) {
                                        // Extract images before cleaning
                                        const optionResult = extractAndCleanImages(remaining);
                                        currentQuestion.options[currentOptionNumber - 1] = (currentQuestion.options[currentOptionNumber - 1] + ' ' + optionResult.text).trim();
                                        // Store extracted images
                                        if (optionResult.images.length > 0) {
                                            currentQuestion.optionImages[currentOptionNumber - 1] = (currentQuestion.optionImages[currentOptionNumber - 1] || []).concat(optionResult.images);
                                        }
                                    } else {
                                        // Before markers begin: treat as question text and extract images
                                        const textResult = extractAndCleanImages(remaining);
                                        currentQuestion.text += '\n' + textResult.text;
                                        currentQuestion.fullContent += '\n' + textResult.text;
                                        // Add extracted images to textImages array
                                        if (textResult.images.length > 0) {
                                            currentQuestion.textImages = (currentQuestion.textImages || []).concat(textResult.images);
                                        }
                                    }
                                    break;
                                }
                                // Content before next marker belongs to previous marker (if any)
                                const before = remaining.slice(0, nextIdx).trim();
                                if (before) {
                                    if (currentOptionNumber >= 1 && currentOptionNumber <= 4) {
                                        // Extract images before cleaning
                                        const optionResult = extractAndCleanImages(before);
                                        currentQuestion.options[currentOptionNumber - 1] = (currentQuestion.options[currentOptionNumber - 1] + ' ' + optionResult.text).trim();
                                        // Store extracted images
                                        if (optionResult.images.length > 0) {
                                            currentQuestion.optionImages[currentOptionNumber - 1] = (currentQuestion.optionImages[currentOptionNumber - 1] || []).concat(optionResult.images);
                                        }
                                    } else {
                                        // Extract images from question text
                                        const textResult = extractAndCleanImages(before);
                                        currentQuestion.text += '\n' + textResult.text;
                                        currentQuestion.fullContent += '\n' + textResult.text;
                                        // Add extracted images to textImages array
                                        if (textResult.images.length > 0) {
                                            currentQuestion.textImages = (currentQuestion.textImages || []).concat(textResult.images);
                                        }
                                    }
                                }
                                // Advance past marker and set current option number
                                remaining = remaining.slice(nextIdx + markers[nextWhich - 1].length);
                                currentOptionNumber = nextWhich;
                                // Now, look ahead for the next marker in the updated remaining to capture text chunk for this option
                                let following = remaining;
                                let nextIdx2 = -1;
                                let nextWhich2 = -1;
                                for (let m2 = 0; m2 < 4; m2++) {
                                    const idx2 = following.indexOf(markers[m2]);
                                    if (idx2 !== -1 && (nextIdx2 === -1 || idx2 < nextIdx2)) {
                                        nextIdx2 = idx2;
                                        nextWhich2 = m2 + 1;
                                    }
                                }
                                let chunk;
                                if (nextIdx2 === -1) {
                                    chunk = following;
                                    remaining = '';
                                } else {
                                    chunk = following.slice(0, nextIdx2);
                                    remaining = following.slice(nextIdx2);
                                }
                                if (chunk && currentOptionNumber >= 1 && currentOptionNumber <= 4) {
                                    // Extract images before cleaning
                                    const optionResult = extractAndCleanImages(chunk);
                                    currentQuestion.options[currentOptionNumber - 1] = (currentQuestion.options[currentOptionNumber - 1] + ' ' + optionResult.text).trim();
                                    // Store extracted images
                                    if (optionResult.images.length > 0) {
                                        currentQuestion.optionImages[currentOptionNumber - 1] = (currentQuestion.optionImages[currentOptionNumber - 1] || []).concat(optionResult.images);
                                    }
                                }
                            }
                        } else if (isFillInTheBlank) {
                            // For fill-in-the-blank questions, add all content to question text and extract images
                            const textResult = extractAndCleanImages(line);
                            currentQuestion.text += '\n' + textResult.text;
                            currentQuestion.fullContent += '\n' + textResult.text;
                            // Add extracted images to textImages array
                            if (textResult.images.length > 0) {
                                currentQuestion.textImages = (currentQuestion.textImages || []).concat(textResult.images);
                            }
                            debugContent += `<div style="color: #17a2b8; margin: 2px 0;">Line ${i+1}: Fill-in-the-blank question content: ${line.substring(0, 50)}...</div>`;
                        } else {
                            // If not an option and not in solution, add to question text and extract images
                            const textResult = extractAndCleanImages(line);
                            currentQuestion.text += '\n' + textResult.text;
                            currentQuestion.fullContent += '\n' + textResult.text;
                            // Add extracted images to textImages array
                            if (textResult.images.length > 0) {
                                currentQuestion.textImages = (currentQuestion.textImages || []).concat(textResult.images);
                            }
                        }
                    }
                    // If in solution, continue collecting until next question
                    else if (inSolution) {
                        // Stop solution at Quick Tip headers (both markdown and LaTeX formats)
                        if (lowerLine.startsWith('## quick tip') || /\\section\*\{\s*quick\s+tip\s*:?\s*\}/i.test(line)) {
                            inSolution = false;
                            inQuickTip = true;
                            debugContent += `<div style=\"color: #6c757d; margin: 2px 0;\">Line ${i+1}: Quick Tip header - ending solution collection and starting tip skip.</div>`;
                            continue;
                        }
                        // Check if this is the start of a new question
                        const nextQuestionMatch = line.match(/^(\d+)\.\s*(.*)/);
                        if (nextQuestionMatch && !line.match(/^\d+\.\d/) && !/continued/i.test(nextQuestionMatch[2] || '')) {
                            // This is a new question, stop collecting solution and process current question
                            inSolution = false;
                            
                            
                            
                            
                            // Save current question and start new one
                            // Convert markdown tables to HTML before saving
                            if (currentQuestion.text) {
                                currentQuestion.text = convertMarkdownTablesToHTML(currentQuestion.text);
                            }
                            if (currentQuestion.solution) {
                                currentQuestion.solution = convertMarkdownTablesToHTML(currentQuestion.solution);
                            }
                            // Convert tables in options as well
                            if (currentQuestion.options && Array.isArray(currentQuestion.options)) {
                                currentQuestion.options = currentQuestion.options.map(opt => 
                                    opt ? convertMarkdownTablesToHTML(opt) : opt
                                );
                            }
                            questions.push(currentQuestion);
                            
                            // Start new question
                            const newQuestionTextResult = extractAndCleanImages(nextQuestionMatch[2]);
                            const newQuestionNumber = parseInt(nextQuestionMatch[1]);
                            currentQuestion = {
                                number: newQuestionNumber,
                                text: newQuestionTextResult.text,
                                textImages: newQuestionTextResult.images, // Store extracted images
                                options: [],
                                optionImages: [[], [], [], []], // Initialize option images arrays
                                answer: '',
                                solution: '',
                                solutionTextImages: [], // Initialize solution images array
                                subject: getSubjectByQuestionNumber(newQuestionNumber),
                                type: 'mcq', // Default type, will be auto-detected
                                fullContent: newQuestionTextResult.text
                            };
                            console.log(`üìù Question ${newQuestionNumber} assigned to subject: ${currentQuestion.subject}`);
                            
                            debugContent += `<div style="color: #28a745; margin: 2px 0; font-weight: bold;">Line ${i+1}: Found question ${currentQuestion.number}: ${nextQuestionMatch[2].substring(0, 100)}...</div>`;
                        } else {
                            // Continue collecting solution and extract images
                            const solResult = extractAndCleanImages(line);
                            currentQuestion.solution += '\n' + solResult.text;
                            // Add extracted images to solution images array
                            if (solResult.images.length > 0) {
                                console.log(`üì∏ Q${currentQuestion.number}: Extracted ${solResult.images.length} image(s) from solution line: ${line.substring(0, 50)}...`);
                                currentQuestion.solutionTextImages = (currentQuestion.solutionTextImages || []).concat(solResult.images);
                            }
                            debugContent += `<div style="color: #ffc107; margin: 2px 0;">Line ${i+1}: Solution line: ${line.substring(0, 50)}...</div>`;
                        }
                    }
                }
            }
            
            // Ensure the last question is captured even if solution ended with a Quick Tip or EOF
            if (currentQuestion) {
                // Ensure arrays are initialized
                if (!currentQuestion.textImages) currentQuestion.textImages = [];
                if (!currentQuestion.solutionTextImages) currentQuestion.solutionTextImages = [];
                if (!currentQuestion.optionImages) currentQuestion.optionImages = [[], [], [], []];
                // Convert markdown tables to HTML before saving
                if (currentQuestion.text) {
                    currentQuestion.text = convertMarkdownTablesToHTML(currentQuestion.text);
                }
                if (currentQuestion.solution) {
                    currentQuestion.solution = convertMarkdownTablesToHTML(currentQuestion.solution);
                }
                // Convert tables in options as well
                if (currentQuestion.options && Array.isArray(currentQuestion.options)) {
                    currentQuestion.options = currentQuestion.options.map(opt => 
                        opt ? convertMarkdownTablesToHTML(opt) : opt
                    );
                }
                questions.push(currentQuestion);
            }
            
            // Show debug info
            debugContent += `<div style="color: #007bff; font-weight: bold; margin: 10px 0; font-size: 16px;">Total questions found: ${questions.length}</div>`;
            debugContent += `<div style="color: #28a745; font-weight: bold; margin: 5px 0;">Question numbers: ${questions.map(q => q.number).join(', ')}</div>`;
            
            // Show which question numbers are found (preserving original numbers from .md)
            const questionNumbers = questions.map(q => parseInt(q.number)).sort((a, b) => a - b);
            
            debugContent += `<div style="color: #6c757d; margin: 5px 0;">Found question numbers: ${questionNumbers.join(', ')}</div>`;
            debugContent += `<div style="color: #6c757d; margin: 5px 0;">Total questions parsed: ${questions.length}</div>`;
            
            // Group by subject for better overview
            const bySubject = {};
            questions.forEach(q => {
                if (!bySubject[q.subject]) bySubject[q.subject] = [];
                bySubject[q.subject].push(q.number);
            });
            
            Object.keys(bySubject).forEach(subject => {
                const subjectQuestions = bySubject[subject].sort((a, b) => a - b);
                debugContent += `<div style="color: #17a2b8; margin: 5px 0;">${subject}: Q${subjectQuestions.join(', Q')}</div>`;
            });
            
            // Debug info removed - console logging only
            console.log('Debug info:', debugContent);
            
            console.log(`Found ${questions.length} questions`);
            console.log('Question numbers:', questions.map(q => q.number).join(', '));
            
            // Log total images extracted
            let totalExtractedImages = 0;
            questions.forEach(q => {
                const qNum = q.number || q.questionNumber || q.questionIndex;
                const textImgCount = q.textImages ? q.textImages.length : 0;
                const solImgCount = q.solutionTextImages ? q.solutionTextImages.length : 0;
                const optImgCount = q.optionImages ? q.optionImages.reduce((sum, opt) => sum + (opt ? opt.length : 0), 0) : 0;
                const qTotal = textImgCount + solImgCount + optImgCount;
                totalExtractedImages += qTotal;
                
                if (qTotal > 0) {
                    console.log(`üìä Q${qNum}: ${textImgCount} text + ${solImgCount} solution + ${optImgCount} option = ${qTotal} total image(s)`);
                }
            });
            console.log(`üì∏ ========== Total ${totalExtractedImages} images extracted from .md file ==========`);
            
            allQuestions = questions;
            
            // Auto-detect question types for all questions
            allQuestions.forEach(question => {
                const detectedType = detectQuestionType(question);
                question.type = detectedType;
                
                // Initialize textImages and solutionTextImages if they don't exist
                if (!question.textImages) question.textImages = [];
                if (!question.solutionTextImages) question.solutionTextImages = [];
            });
            
            displayQuestions();
            updateStats();
            
            // Populate question lists for all subjects
            populateQuestionList('Mathematics');
            populateQuestionList('Physics');
            populateQuestionList('Chemistry');
            populateQuestionList('Biology');
            
            // Update button styling for manual editing indicators
            updateQuestionButtonStyling();
            // Update edit area styling for manual editing indicators
            updateEditAreaStyling();
            
            // Automatically upload all images to Firebase
            uploadAllExtractedImages();
        }
        
        function extractImagesFromText(text) {
            if (!text) return [];
            const imageMatches = text.match(/!\[\]\([^)]+\)/g);
            if (!imageMatches) return [];
            return imageMatches.map(match => {
                const urlMatch = match.match(/!\[\]\(([^)]+)\)/);
                return urlMatch ? urlMatch[1] : null;
            }).filter(url => url !== null);
        }
        
        function extractImagesFromOriginalText(text) {
            if (!text) return [];
            // Look for both markdown and HTML image formats
            const markdownImages = text.match(/!\[\]\([^)]+\)/g);
            const htmlImages = text.match(/<img[^>]+src="([^"]+)"[^>]*>/g);
            
            let images = [];
            if (markdownImages) {
                images = images.concat(markdownImages.map(match => {
                    const urlMatch = match.match(/!\[\]\(([^)]+)\)/);
                    return urlMatch ? urlMatch[1] : null;
                }).filter(url => url !== null));
            }
            if (htmlImages) {
                images = images.concat(htmlImages.map(match => {
                    const urlMatch = match.match(/src="([^"]+)"/);
                    return urlMatch ? urlMatch[1] : null;
                }).filter(url => url !== null));
            }
            return images;
        }
        
        function extractImagesFromHTML(text) {
            if (!text) return [];
            const imageMatches = text.match(/<img[^>]+src="([^"]+)"[^>]*>/g);
            if (!imageMatches) return [];
            return imageMatches.map(match => {
                const urlMatch = match.match(/src="([^"]+)"/);
                return urlMatch ? urlMatch[1] : null;
            }).filter(url => url !== null);
        }
        
        function extractAllImages(text) {
            if (!text) return [];
            const markdownImages = extractImagesFromText(text);
            const htmlImages = extractImagesFromHTML(text);
            return [...markdownImages, ...htmlImages];
        }
        
        function extractOptionsFromText(text) {
            if (!text) return [];
            const optionMatches = text.match(/\([1-4]\)\s*[^\n]+/g);
            if (!optionMatches) return [];
            return optionMatches.map(match => match.trim());
        }
        
        function cleanQuestionText(text) {
            // Remove options from question text
            return text.replace(/\([1-4]\)\s*[^\n]+/g, '').trim();
        }
        
        function cleanSolutionText(text) {
            if (!text) return '';
            
            // Extract solution starting from "Sol." until next question number
            const solMatch = text.match(/Sol\.\s*([\s\S]*?)(?=\n\d+\.\s|\n\d+\.|$)/m);
            if (solMatch) {
                let cleaned = solMatch[1].trim();
                
                // Remove any "## TEST PAPER WITH SOLUTION" lines
                cleaned = cleaned.split('\n')
                    .filter(line => {
                        const trimmedLine = line.trim();
                        // Skip lines with "TEST PAPER WITH SOLUTION"
                        if (/TEST\s+PAPER\s+WITH\s+SOLUTION/i.test(trimmedLine)) return false;
                        // Skip markdown headers
                        if (/^#{1,6}\s/.test(trimmedLine)) return false;
                        return true;
                    })
                    .join('\n');
                
                // Remove markdown images from solution text
                cleaned = cleaned.replace(/!\[\]\([^)]+\)/g, '').trim();
                
                // Clean up extra whitespace
                cleaned = cleaned.replace(/\n{3,}/g, '\n\n').trim();
                
                return cleaned;
            }
            
            // Fallback: if no "Sol." found, return empty
            return '';
        }
        
        function displayQuestions() {
            const container = document.getElementById('questionsList');
            container.innerHTML = '';
            
            // Ensure all questions have options and answers extracted
            allQuestions.forEach(question => {
                if (question.options.length === 0) {
                    // Extract options from question text as fallback
                    const optionMatches = question.text.match(/\([1-4]\)\s*[^\n]+/g);
                    if (optionMatches) {
                        question.options = optionMatches;
                        // Remove options from question text
                        question.text = question.text.replace(/\([1-4]\)\s*[^\n]+/g, '').trim();
                    }
                }
                
                // Extract answer from solution if not already parsed
                if (!question.answer && question.solution) {
                    const answerMatch = question.solution.match(/Ans\.\s*\(([^)]+)\)/);
                    if (answerMatch) {
                        question.answer = answerMatch[1];
                    }
                }
            });
            
            // Generate JSON structure in the required format
            const jsonStructure = [
                {
                    "tutorialId": "JEE_2025_Mathematics",
                    "tutorialTitle": "JEE 2025 Mathematics",
                    "tutorialDescription": "JEE 2025 Mathematics Questions with Solutions",
                    "authorityExamId": "jee_2025",
                    "state": "All India",
                    "board": "JEE",
                    "conductedBy": "NTA (National Testing Agency)",
                    "year": "2025",
                    "subject": "Mathematics",
                    "questions": allQuestions
                        .filter(q => q.subject === 'Mathematics' || q.subject === 'mathematics')
                        .map(question => ({
                            "questionIndex": question.number.toString(),
                            "questionId": `2025MQ${question.number}`,
                            "questionDetails": [
                                {
                                    "text": cleanQuestionText(question.text),
                                    "textImages": question.textImages || [],
                                    "possibleAnswers": {
                                        "A": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[0] && question.optionImages[0].length > 0) {
                                                    const imgObj = question.optionImages[0][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[0] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[0]?.replace(/^\(1\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })(),
                                        "B": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[1] && question.optionImages[1].length > 0) {
                                                    const imgObj = question.optionImages[1][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[1] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[1]?.replace(/^\(2\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })(),
                                        "C": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[2] && question.optionImages[2].length > 0) {
                                                    const imgObj = question.optionImages[2][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[2] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[2]?.replace(/^\(3\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })(),
                                        "D": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[3] && question.optionImages[3].length > 0) {
                                                    const imgObj = question.optionImages[3][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[3] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[3]?.replace(/^\(4\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })()
                                    },
                                    "correctAnswer": question.answer,
                                    "correctAnswerText": question.options[parseInt(question.answer) - 1]?.replace(/^\(\d+\)\s*/, '').trim() || "",
                                    "solution": cleanSolutionText(question.solution),
                                    "solutionTextImages": question.solutionTextImages || []
                                }
                            ]
                        }))
                },
                {
                    "tutorialId": "JEE_2025_Physics",
                    "tutorialTitle": "JEE 2025 Physics",
                    "tutorialDescription": "JEE 2025 Physics Questions with Solutions",
                    "authorityExamId": "jee_2025",
                    "state": "All India",
                    "board": "JEE",
                    "conductedBy": "NTA (National Testing Agency)",
                    "year": "2025",
                    "subject": "Physics",
                    "questions": allQuestions
                        .filter(q => q.subject === 'Physics' || q.subject === 'physics')
                        .map(question => ({
                            "questionIndex": question.number.toString(),
                            "questionId": `2025PQ${question.number}`,
                            "questionDetails": [
                                {
                                    "text": cleanQuestionText(question.text),
                                    "textImages": question.textImages || [],
                                    "possibleAnswers": {
                                        "A": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[0] && question.optionImages[0].length > 0) {
                                                    const imgObj = question.optionImages[0][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[0] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[0]?.replace(/^\(1\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })(),
                                        "B": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[1] && question.optionImages[1].length > 0) {
                                                    const imgObj = question.optionImages[1][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[1] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[1]?.replace(/^\(2\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })(),
                                        "C": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[2] && question.optionImages[2].length > 0) {
                                                    const imgObj = question.optionImages[2][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[2] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[2]?.replace(/^\(3\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })(),
                                        "D": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[3] && question.optionImages[3].length > 0) {
                                                    const imgObj = question.optionImages[3][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[3] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[3]?.replace(/^\(4\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })()
                                    },
                                    "correctAnswer": question.answer,
                                    "correctAnswerText": question.options[parseInt(question.answer) - 1]?.replace(/^\(\d+\)\s*/, '').trim() || "",
                                    "solution": cleanSolutionText(question.solution),
                                    "solutionTextImages": question.solutionTextImages || []
                                }
                            ]
                        }))
                },
                {
                    "tutorialId": "JEE_2025_Chemistry",
                    "tutorialTitle": "JEE 2025 Chemistry",
                    "tutorialDescription": "JEE 2025 Chemistry Questions with Solutions",
                    "authorityExamId": "jee_2025",
                    "state": "All India",
                    "board": "JEE",
                    "conductedBy": "NTA (National Testing Agency)",
                    "year": "2025",
                    "subject": "Chemistry",
                    "questions": allQuestions
                        .filter(q => q.subject === 'Chemistry' || q.subject === 'chemistry')
                        .map(question => ({
                            "questionIndex": question.number.toString(),
                            "questionId": `2025CQ${question.number}`,
                            "questionDetails": [
                                {
                                    "text": cleanQuestionText(question.text),
                                    "textImages": question.textImages || [],
                                    "possibleAnswers": {
                                        "A": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[0] && question.optionImages[0].length > 0) {
                                                    const imgObj = question.optionImages[0][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[0] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[0]?.replace(/^\(1\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })(),
                                        "B": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[1] && question.optionImages[1].length > 0) {
                                                    const imgObj = question.optionImages[1][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[1] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[1]?.replace(/^\(2\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })(),
                                        "C": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[2] && question.optionImages[2].length > 0) {
                                                    const imgObj = question.optionImages[2][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[2] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[2]?.replace(/^\(3\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })(),
                                        "D": (() => {
                                            const getOptionImage = () => {
                                                if (question.optionImages && question.optionImages[3] && question.optionImages[3].length > 0) {
                                                    const imgObj = question.optionImages[3][0];
                                                    return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                                }
                                                const images = extractImagesFromOriginalText(question.options[3] || "");
                                                return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                            };
                                            const imageUrl = getOptionImage();
                                            const option = {
                                                "text": question.options[3]?.replace(/^\(4\)\s*/, '').trim() || ""
                                            };
                                            if (imageUrl) option.image = imageUrl;
                                            return option;
                                        })()
                                    },
                                    "correctAnswer": question.answer,
                                    "correctAnswerText": question.options[parseInt(question.answer) - 1]?.replace(/^\(\d+\)\s*/, '').trim() || "",
                                    "solution": cleanSolutionText(question.solution),
                                    "solutionTextImages": question.solutionTextImages || []
                                }
                            ]
                        }))
                }
            ];
            
            // Display JSON structure in left panel
            const jsonDisplay = document.createElement('div');
            jsonDisplay.className = 'json-display';
            jsonDisplay.innerHTML = `
                <h4>üìä Question Data Structure</h4>
                <pre><code>${JSON.stringify(jsonStructure, null, 2)}</code></pre>
            `;
            container.appendChild(jsonDisplay);
            
            // Also create individual question cards for interaction
            allQuestions.forEach((question, index) => {
                const questionCard = document.createElement('div');
                questionCard.className = 'question-card';
                questionCard.onclick = () => scrollToQuestion(question.number, 'all');
                
                // Handle both array and object formats for options
                let optionsHtml = '';
                if (question.options) {
                    if (Array.isArray(question.options)) {
                        // Old array format
                        optionsHtml = question.options.map((opt, idx) => 
                            `<div class="option">(${idx + 1}) ${opt}</div>`
                ).join('\n');
                    } else {
                        // New object format {A: {text: "...", image: null}}
                        optionsHtml = ['A', 'B', 'C', 'D'].map(key => {
                            const opt = question.options[key];
                            return opt && opt.text ? `<div class="option">${key}. ${opt.text}</div>` : '';
                        }).join('\n');
                    }
                }
                
                // Set the selected value based on the detected subject
                const selectedSubject = question.subject === 'unassigned' ? '' : question.subject.charAt(0).toUpperCase() + question.subject.slice(1);
                
                questionCard.innerHTML = `
                    <div class="question-header">
                        <div class="question-number">Q${question.number}</div>
                        <select class="subject-selector" onchange="assignSubject(${index}, this.value); event.stopPropagation();">
                            <option value="">Select Subject</option>
                            <option value="Mathematics" ${selectedSubject === 'Mathematics' ? 'selected' : ''}>Mathematics</option>
                            <option value="Physics" ${selectedSubject === 'Physics' ? 'selected' : ''}>Physics</option>
                            <option value="Chemistry" ${selectedSubject === 'Chemistry' ? 'selected' : ''}>Chemistry</option>
                        </select>
                    </div>
                    <div class="question-text">${question.text}</div>
                    <div class="question-options">${optionsHtml}</div>
                    ${question.answer ? `<div class="answer">Answer: (${question.answer})</div>` : ''}
                    ${question.solution ? `<div class="solution">Solution: ${cleanSolutionText(question.solution)}</div>` : ''}
                    ${question.subject !== 'unassigned' ? `<div class="answer" style="color: #4facfe;">Detected Subject: ${selectedSubject}</div>` : ''}
                `;
                
                container.appendChild(questionCard);
            });
            
            // Render all questions in the right panel
            // Show Mathematics tab by default
            showSubject('Mathematics');
            
            // Populate edit interfaces for all subjects
            populateInlineEditFields('Mathematics');
            populateInlineEditFields('Physics');
            populateInlineEditFields('Chemistry');
            
            // Show subject-tabs-container when loading from .md files
            // displayQuestions() is ONLY called when loading from .md files
            const subjectTabsContainer = document.getElementById('subjectTabsContainer');
            if (subjectTabsContainer) {
                subjectTabsContainer.style.display = 'flex';
                console.log('üîì ‚úÖ Showing subject-tabs-container (from .md file)');
            }
        }
        
        function assignSubject(questionIndex, subject) {
            const question = allQuestions[questionIndex];
            questionAssignments[question.number] = subject;
            updateStats();
            updateAssignmentsDisplay();
        }
        
        function updateStats() {
            const total = allQuestions.length;
            
            // Count questions by subject (assigned or detected)
            const math = allQuestions.filter(q => {
                const assignedSubject = questionAssignments[q.number];
                const detectedSubject = q.subject;
                return assignedSubject === 'Mathematics' || 
                       (detectedSubject === 'mathematics' && !assignedSubject) ||
                       (detectedSubject === 'mathematics');
            }).length;
            
            const physics = allQuestions.filter(q => {
                const assignedSubject = questionAssignments[q.number];
                const detectedSubject = q.subject;
                return assignedSubject === 'Physics' || 
                       (detectedSubject === 'physics' && !assignedSubject) ||
                       (detectedSubject === 'physics');
            }).length;
            
            const chemistry = allQuestions.filter(q => {
                const assignedSubject = questionAssignments[q.number];
                const detectedSubject = q.subject;
                return assignedSubject === 'Chemistry' || 
                       (detectedSubject === 'chemistry' && !assignedSubject) ||
                       (detectedSubject === 'chemistry');
            }).length;
            
            const biology = allQuestions.filter(q => {
                const assignedSubject = questionAssignments[q.number];
                const detectedSubject = q.subject;
                return assignedSubject === 'Biology' || 
                       (detectedSubject === 'biology' && !assignedSubject) ||
                       (detectedSubject === 'biology');
            }).length;
            
            // Update sidebar statistics (if elements exist)
            const sidebarTotalEl = document.getElementById('sidebar-total-questions');
            if (sidebarTotalEl) {
                sidebarTotalEl.textContent = total;
            }
            
            // Update main tab statistics
            const mathCountEl = document.getElementById('count-Mathematics');
            if (mathCountEl) {
                mathCountEl.textContent = math;
            }
            
            const physicsCountEl = document.getElementById('count-Physics');
            if (physicsCountEl) {
                physicsCountEl.textContent = physics;
            }
            
            const chemistryCountEl = document.getElementById('count-Chemistry');
            if (chemistryCountEl) {
                chemistryCountEl.textContent = chemistry;
            }
            
            const biologyCountEl = document.getElementById('count-Biology');
            if (biologyCountEl) {
                biologyCountEl.textContent = biology;
            }
            
            // Calculate extracted questions (questions that have been assigned or detected)
            const extracted = math + physics + chemistry + biology;
            const sidebarExtractedEl = document.getElementById('sidebar-extracted-questions');
            if (sidebarExtractedEl) {
                sidebarExtractedEl.textContent = extracted;
            }
            
            // Show sidebar stats and download section (if elements exist)
            const sidebarStatsEl = document.getElementById('sidebarStats');
            if (sidebarStatsEl) {
                sidebarStatsEl.style.display = 'block';
            }
            
            const sidebarDownloadEl = document.getElementById('sidebarDownload');
            if (sidebarDownloadEl) {
                sidebarDownloadEl.style.display = 'block';
            }
        }
        
        function updateAssignmentsDisplay() {
            // Assignment display removed - console logging only
            const subjects = ['Mathematics', 'Physics', 'Chemistry'];
            
            subjects.forEach(subject => {
                const questions = Object.entries(questionAssignments)
                    .filter(([num, sub]) => sub === subject)
                    .map(([num]) => num)
                    .sort((a, b) => parseInt(a) - parseInt(b));
                
                console.log(`${subject}: ${questions.length} questions - ${questions.join(', ')}`);
            });
        }
        
        function generateJSON() {
            const subjects = ['Mathematics', 'Physics', 'Chemistry'];
            const result = {};
            
            subjects.forEach(subject => {
                const subjectQuestions = allQuestions
                    .filter(q => questionAssignments[q.number] === subject)
                    .map((q, index) => ({
                        questionIndex: q.number.toString(),
                        questionId: `Q${q.number}`,
                        questionDetails: [{
                            text: q.text,
                            textImages: [],
                            possibleAnswers: q.options.reduce((acc, opt) => {
                                const letter = String.fromCharCode(64 + parseInt(opt.number));
                                acc[letter] = { text: opt.text, image: null };
                                return acc;
                            }, {}),
                            correctAnswer: String.fromCharCode(64 + parseInt(q.answer)),
                            correctAnswerText: q.options.find(opt => opt.number === q.answer)?.text || ''
                        }],
                        subject: subject,
                        solution: q.solution,
                        marks: '4'
                    }));
                
                result[subject] = {
                    subject: subject,
                    totalQuestions: subjectQuestions.length,
                    questions: subjectQuestions
                };
            });
            
            console.log('Generated JSON:', result);
            
            // Show JSON in a new window
            const jsonWindow = window.open('', '_blank');
            jsonWindow.document.write(`
                <html>
                <head><title>Generated JSON</title></head>
                <body>
                    <h1>Generated JSON Output</h1>
                    <pre style="background: #f5f5f5; padding: 20px; border-radius: 5px; overflow-x: auto;">${JSON.stringify(result, null, 2)}</pre>
                </body>
                </html>
            `);
        }
        
        function downloadAssignments() {
            const data = {
                assignments: questionAssignments,
                questions: allQuestions.map(q => ({
                    number: q.number,
                    text: q.text,
                    subject: questionAssignments[q.number] || 'Unassigned'
                }))
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'question_assignments.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function resetAssignments() {
            questionAssignments = {};
            document.querySelectorAll('.subject-selector').forEach(select => {
                select.value = '';
            });
            updateStats();
            updateAssignmentsDisplay();
        }
        
        function showSubject(subject) {
            console.log(`Switching to subject: ${subject}`);
            
            // Debug: Check current active subject
            const currentActiveTab = document.querySelector('.subject-tab.active');
            const currentActiveSubject = currentActiveTab ? currentActiveTab.id.replace('tab-', '') : 'none';
            console.log(`Current active subject: ${currentActiveSubject}, switching to: ${subject}`);
            
            // Debug: Show all questions and their subjects
            console.log(`=== DEBUGGING ALL QUESTIONS ===`);
            console.log(`Total questions: ${allQuestions.length}`);
            console.log(`All subjects found:`, [...new Set(allQuestions.map(q => q.subject))]);
            console.log(`Questions by subject:`, {
                mathematics: allQuestions.filter(q => q.subject === 'mathematics').length,
                physics: allQuestions.filter(q => q.subject === 'physics').length,
                chemistry: allQuestions.filter(q => q.subject === 'chemistry').length,
                unassigned: allQuestions.filter(q => q.subject === 'unassigned').length
            });
            console.log(`Sample questions:`, allQuestions.slice(0, 5).map(q => ({number: q.number, subject: q.subject})));
            
            // Update main tab buttons (if tabs are visible)
            const tabButton = document.getElementById(`tab-${subject}`);
            if (tabButton) {
                document.querySelectorAll('.subject-tab').forEach(btn => {
                    btn.classList.remove('active');
                });
                tabButton.classList.add('active');
            } else {
                console.log(`Tab button for ${subject} not found (tabs may be hidden)`);
            }
            
            // Hide all subject views
            document.querySelectorAll('.subject-view').forEach(view => {
                view.style.display = 'none';
                view.classList.remove('active');
            });
            
            // Show subject split view
            document.getElementById('questionsContainer').style.display = 'none';
            
            const subjectViewElement = document.getElementById(`subjectView-${subject}`);
            console.log(`Looking for element: subjectView-${subject}`);
            console.log(`Element found:`, subjectViewElement);
            
            if (subjectViewElement) {
                subjectViewElement.style.display = 'block';
                subjectViewElement.classList.add('active');
                console.log(`Activated subject view for ${subject}`);
                
                // Update only the tutorial title when switching tabs (keep other fields unchanged)
                updateTutorialTitleOnly(subject);
                
                // Populate the question list for the selected subject (if not already populated)
                const questionListContainer = document.getElementById(`questionList-${subject}`);
                if (questionListContainer && questionListContainer.children.length <= 1) {
                    populateQuestionList(subject);
                }
                
                // Note: generateSubjectView() creates the old card-based view, not needed for inline edit mode
                // If you need that view, call it separately
                // generateSubjectView(subject);
                
                // Ensure the render panel is visible and properly initialized
                const renderPanel = document.getElementById(`questionRender-${subject}`);
                if (renderPanel) {
                    renderPanel.style.display = 'block';
                    console.log(`Set render panel display to block for ${subject}`);
                    
                    // Force the same initialization as Mathematics
                    const renderContainer = document.getElementById(
                        subject === 'Mathematics' ? 'inlineMathRender' : 
                        subject === 'Physics' ? 'inlinePhysicsRender' : 
                        subject === 'Chemistry' ? 'inlineChemistryRender' :
                        'inlineBiologyRender'
                    );
                    if (renderContainer) {
                        // Force layout recalculation
                        renderContainer.offsetHeight;
                        console.log(`Forced layout recalculation for ${subject} container`);
                    }
                }
                
                // Generate the full Live Preview with all questions for this subject
                console.log(`Generating question render for ${subject} with question index 0`);
                generateQuestionRender(subject, 0); // Start with question 0
                
                // Auto-select the first question in the sidebar
                setTimeout(() => {
                    const firstQuestionItem = document.querySelector(`#questionList-${subject} .question-item`);
                    if (firstQuestionItem) {
                        firstQuestionItem.click();
                        console.log(`Auto-selected first question for ${subject}`);
                    } else {
                        console.log(`No question items found for ${subject}`);
                    }
                }, 100);
            } else {
                console.error(`Element subjectView-${subject} not found!`);
            }
        }
        
        function renderAllQuestions(context) {
            const renderElement = document.getElementById(context === 'all' ? 'allQuestionsRender' : 
                                                      context === 'Mathematics' ? 'inlineMathRender' :
                                                      context === 'Physics' ? 'inlinePhysicsRender' : 'inlineChemistryRender');
            
            if (!renderElement) return;
            
            // Get questions to render
            let questionsToRender = allQuestions;
            if (context !== 'all') {
                questionsToRender = allQuestions.filter(q => {
                    const assignedSubject = questionAssignments[q.number];
                    const detectedSubject = q.subject;
                    return assignedSubject === context || 
                           (detectedSubject && detectedSubject.toLowerCase() === context.toLowerCase());
                });
            }
            
            let renderHtml = '';
            questionsToRender.forEach((question, index) => {
                // Generate options HTML (options are always in array format now)
                const optionsHtml = question.options.map((opt, optIndex) => {
                    const letter = String.fromCharCode(65 + optIndex); // A, B, C, D
                    const cleanText = opt ? opt.replace(/^\(\d+\)\s*/, '').trim() : '';
                    return `<div class="option-render"><strong>${letter}.</strong> ${cleanText}</div>`;
                }).join('\n');
                
                // Find correct answer text using helper function
                const answerText = getCorrectAnswerText(question);
                const answerLetter = question.answer ? String.fromCharCode(64 + parseInt(question.answer)) : '';
                
                renderHtml += `
                    <div class="question-render" id="render-q${question.number}">
                        <h4>Question ${question.number}</h4>
                        <div class="question-text">${question.text}</div>
                        <div class="options-render">${optionsHtml}</div>
                        ${answerText ? `<div class="answer-render">Answer: ${answerLetter}. ${answerText}</div>` : ''}
                        ${question.solution ? `<div class="solution-render">Solution: ${cleanSolutionText(question.solution)}</div>` : ''}
                        <hr style="margin: 20px 0; border: 1px solid #eee;">
                    </div>
                `;
            });
            
            renderElement.innerHTML = renderHtml;
            
            // Re-render MathJax
            if (window.MathJax) {
                MathJax.typesetPromise([renderElement]).catch((err) => console.log('MathJax error:', err));
            }
        }
        
        function scrollToQuestion(questionNumber, context) {
            const renderElement = document.getElementById(context === 'all' ? 'allQuestionsRender' : 
                                                      context === 'Mathematics' ? 'inlineMathRender' :
                                                      context === 'Physics' ? 'inlinePhysicsRender' : 'inlineChemistryRender');
            
            if (!renderElement) return;
            
            const targetElement = document.getElementById(`render-q${questionNumber}`);
            if (targetElement) {
                // Scroll the target question into view
                targetElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start',
                    inline: 'nearest'
                });
                
                // Add a highlight effect
                targetElement.style.backgroundColor = '#fff3cd';
                targetElement.style.border = '2px solid #ffc107';
                targetElement.style.borderRadius = '8px';
                targetElement.style.transition = 'all 0.3s ease';
                
                // Remove highlight after 2 seconds
                setTimeout(() => {
                    targetElement.style.backgroundColor = '';
                    targetElement.style.border = '';
                }, 2000);
            }
        }
        
        function generateSubjectView(subject) {
            // Get questions for this subject
            const subjectQuestions = allQuestions.filter(q => {
                const assignedSubject = questionAssignments[q.number];
                const detectedSubject = q.subject;
                
                return assignedSubject === subject || 
                       (detectedSubject && detectedSubject.toLowerCase() === subject.toLowerCase());
            });
            
            console.log(`Generating view for ${subject}: ${subjectQuestions.length} questions`);
            console.log(`Subject questions:`, subjectQuestions);
            
            // Get the questions list container for this subject
            const questionsListId = `questionList-${subject}`;
            const container = document.getElementById(questionsListId);
            
            if (!container) {
                console.error(`Container ${questionsListId} not found!`);
                return;
            }
            
            // Clear existing content but keep the header
            const header = container.querySelector('h4');
            container.innerHTML = '';
            if (header) {
                container.appendChild(header);
            } else {
                const newHeader = document.createElement('h4');
                newHeader.textContent = 'üìã Questions';
                container.appendChild(newHeader);
            }
            
            if (subjectQuestions.length === 0) {
                const noQuestionsMsg = document.createElement('p');
                noQuestionsMsg.textContent = `No questions found`;
                noQuestionsMsg.style.padding = '20px';
                noQuestionsMsg.style.textAlign = 'center';
                noQuestionsMsg.style.color = '#999';
                container.appendChild(noQuestionsMsg);
                return;
            }
            
            // Create question number buttons
            subjectQuestions.forEach((question) => {
                const button = document.createElement('button');
                button.className = 'question-item';
                button.textContent = question.number;
                button.title = `Question ${question.number}`;
                button.onclick = () => selectQuestion(subject, subjectQuestions.findIndex(q => q.number === question.number));
                
                // Check if question needs manual editing (contains table markup - images are handled automatically now)
                const needsEditing = (question.text && question.text.includes('| :---: |')) ||
                                   (question.solution && question.solution.includes('| :---: |')) ||
                                   (question.options && Object.values(question.options).some(opt => 
                                       (opt.text && opt.text.includes('| :---: |'))));
                
                if (needsEditing) {
                    button.classList.add('needs-edit');
                    button.style.background = '#ef4444';
                    button.style.color = 'white';
                }
                
                container.appendChild(button);
            });
            
            console.log(`‚úÖ Generated ${subjectQuestions.length} question buttons for ${subject}`);
            
            // Create question cards for this subject
            subjectQuestions.forEach((question, index) => {
                const questionCard = document.createElement('div');
                questionCard.className = 'question-card';
                questionCard.onclick = () => scrollToQuestion(question.number, subject);
                
                // Generate options HTML (options are always in array format now)
                const optionsHtml = question.options.map((opt, optIndex) => {
                    const letter = String.fromCharCode(65 + optIndex); // A, B, C, D
                    const cleanText = opt ? opt.replace(/^\(\d+\)\s*/, '').trim() : '';
                    return `<div class="option">
                        <strong>${letter}.</strong> 
                        <input type="text" class="option-input" value="${cleanText}" 
                               data-question="${question.number}" data-option="${optIndex}"
                               onclick="event.stopPropagation()" 
                               onchange="updateQuestionOption(${question.number}, ${optIndex}, this.value, '${subject}')">
                    </div>`;
                }).join('\n');
                
                questionCard.innerHTML = `
                    <div class="question-header">
                        <div class="question-number">Q${question.number}</div>
                        <div class="question-actions">
                            <button class="edit-btn" onclick="event.stopPropagation(); toggleQuestionEdit(${question.number}, '${subject}')">‚úèÔ∏è Edit</button>
                        </div>
                    </div>
                    <div class="question-content">
                        <div class="question-text">
                            <textarea class="question-textarea" data-question="${question.number}" 
                                      onclick="event.stopPropagation()" 
                                      onchange="updateQuestionText(${question.number}, this.value, '${subject}')">${removeImagePlaceholders(question.text || '', question.textImages || [])}</textarea>
                        </div>
                        <div class="question-options">${optionsHtml}</div>
                        <div class="answer-section">
                            <label>Correct Answer:</label>
                            ${question.type === 'fillblank' || question.type === 'integer' ? 
                                `<input type="text" value="${question.answer || ''}" 
                                       data-question="${question.number}"
                                       onchange="updateQuestionAnswer(${question.number}, this.value, '${subject}')"
                                       style="padding: 8px; border: 1px solid #ccc; border-radius: 4px;">` :
                                `<select class="answer-select" data-question="${question.number}" 
                                    onclick="event.stopPropagation()" 
                                    onchange="updateQuestionAnswer(${question.number}, this.value, '${subject}')">
                                <option value="1" ${question.answer === '1' ? 'selected' : ''}>A</option>
                                <option value="2" ${question.answer === '2' ? 'selected' : ''}>B</option>
                                <option value="3" ${question.answer === '3' ? 'selected' : ''}>C</option>
                                <option value="4" ${question.answer === '4' ? 'selected' : ''}>D</option>
                                </select>`
                            }
                        </div>
                        <div class="solution-section">
                            <label>Solution:</label>
                            <textarea class="solution-textarea" data-question="${question.number}" 
                                      onclick="event.stopPropagation()" 
                                      onchange="updateQuestionSolution(${question.number}, this.value, '${subject}')">${removeImagePlaceholders(question.solution || '', question.solutionTextImages || [])}</textarea>
                        </div>
                    </div>
                `;
                
                container.appendChild(questionCard);
            });
            
            // Display JSON in the right panel
            displaySubjectJSON(subject);
            
            // Render all questions in the right panel
            renderAllQuestions(subject);
            
            // Update edit area styling for manual editing indicators
            updateEditAreaStyling();
        }
        
        function displaySubjectJSON(subject) {
            // Get questions for this subject
            const subjectQuestions = allQuestions.filter(q => {
                const assignedSubject = questionAssignments[q.number];
                const detectedSubject = q.subject;
                return assignedSubject === subject || 
                       (detectedSubject && detectedSubject.toLowerCase() === subject.toLowerCase());
            });
            
            if (subjectQuestions.length === 0) {
                return;
            }
            
            // Get values from form inputs
            const getFormValue = (fieldId) => {
                const element = document.getElementById(fieldId);
                return element ? element.value : '';
            };
            
            const tutorialId = getFormValue(`tutorialId${subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry'}`);
            const tutorialTitle = getFormValue(`tutorialTitle${subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry'}`);
            const tutorialDescription = getFormValue(`tutorialDescription${subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry'}`);
            const authorityExamId = getFormValue(`authorityExamId${subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry'}`);
            const state = getFormValue(`state${subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry'}`);
            const board = getFormValue(`board${subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry'}`);
            const conductedBy = getFormValue(`conductedBy${subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry'}`);
            const year = getFormValue(`year${subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry'}`);
            const subjectValue = getFormValue(`subject${subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry'}`);
            const dayAndShift = getFormValue(`dayAndShift${subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry'}`);
            
            // Generate JSON structure
            const jsonData = [{
                "tutorialId": tutorialId || `JEE_2025_${subject}`,
                "tutorialTitle": tutorialTitle || `JEE 2025 ${subject}`,
                "tutorialDescription": tutorialDescription || `JEE 2025 ${subject} Questions with Solutions`,
                "authorityExamId": authorityExamId || "jee_2025",
                "state": state || "All India",
                "board": board || "JEE",
                "conductedBy": conductedBy || "NTA (National Testing Agency)",
                "year": year || "2025",
                "subject": subjectValue || subject,
                "dayAndShift": dayAndShift || "2 April 2025 Shift - 2",
                "questions": subjectQuestions.map(question => ({
                    "questionIndex": question.number.toString(),
                    "questionId": `2025${subject.charAt(0)}Q${question.number}`,
                    "questionDetails": [{
                        "text": cleanQuestionText(question.text),
                        "textImages": question.textImages || [], // Use already extracted images
                        "possibleAnswers": {
                            "A": (() => {
                                const getOptionImage = () => {
                                    if (question.optionImages && question.optionImages[0] && question.optionImages[0].length > 0) {
                                        const imgObj = question.optionImages[0][0];
                                        return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                    }
                                    const images = extractImagesFromOriginalText(question.options[0] || "");
                                    return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                };
                                const imageUrl = getOptionImage();
                                const option = {
                                    "text": question.options[0]?.replace(/^\(1\)\s*/, '').trim() || ""
                                };
                                if (imageUrl) option.image = imageUrl;
                                return option;
                            })(),
                            "B": (() => {
                                const getOptionImage = () => {
                                    if (question.optionImages && question.optionImages[1] && question.optionImages[1].length > 0) {
                                        const imgObj = question.optionImages[1][0];
                                        return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                    }
                                    const images = extractImagesFromOriginalText(question.options[1] || "");
                                    return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                };
                                const imageUrl = getOptionImage();
                                const option = {
                                    "text": question.options[1]?.replace(/^\(2\)\s*/, '').trim() || ""
                                };
                                if (imageUrl) option.image = imageUrl;
                                return option;
                            })(),
                            "C": (() => {
                                const getOptionImage = () => {
                                    if (question.optionImages && question.optionImages[2] && question.optionImages[2].length > 0) {
                                        const imgObj = question.optionImages[2][0];
                                        return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                    }
                                    const images = extractImagesFromOriginalText(question.options[2] || "");
                                    return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                };
                                const imageUrl = getOptionImage();
                                const option = {
                                    "text": question.options[2]?.replace(/^\(3\)\s*/, '').trim() || ""
                                };
                                if (imageUrl) option.image = imageUrl;
                                return option;
                            })(),
                            "D": (() => {
                                const getOptionImage = () => {
                                    if (question.optionImages && question.optionImages[3] && question.optionImages[3].length > 0) {
                                        const imgObj = question.optionImages[3][0];
                                        return (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                    }
                                    const images = extractImagesFromOriginalText(question.options[3] || "");
                                    return images.length > 0 ? (typeof images[0] === 'object' && images[0].image ? images[0].image : images[0]) : null;
                                };
                                const imageUrl = getOptionImage();
                                const option = {
                                    "text": question.options[3]?.replace(/^\(4\)\s*/, '').trim() || ""
                                };
                                if (imageUrl) option.image = imageUrl;
                                return option;
                            })()
                        },
                        "correctAnswer": question.answer,
                        "correctAnswerText": question.options[parseInt(question.answer) - 1]?.replace(/^\(\d+\)\s*/, '').trim() || "",
                        "solution": cleanSolutionText(question.solution),
                        "solutionTextImages": question.solutionTextImages || [] // Use already extracted images
                    }]
                }))
            }];
            
            // Display JSON in the right panel
            const jsonContainerId = subject === 'Mathematics' ? 'mathQuestionsList' :
                                   subject === 'Physics' ? 'physicsQuestionsList' : 'chemistryQuestionsList';
            const jsonContainer = document.getElementById(jsonContainerId);
            if (jsonContainer) {
                jsonContainer.innerHTML = `
                    <div class="json-container">
                        <div class="json-display">
                            <h4>Question Data Structure</h4>
                            <pre><code>${JSON.stringify(jsonData, null, 2)}</code></pre>
                        </div>
                    </div>
                `;
            }
            
            // Add event listeners to form inputs to update JSON in real-time
            const suffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry';
            const formInputs = [
                `tutorialId${suffix}`, `tutorialTitle${suffix}`, `tutorialDescription${suffix}`,
                `authorityExamId${suffix}`, `state${suffix}`, `board${suffix}`,
                `conductedBy${suffix}`, `year${suffix}`, `subject${suffix}`, `dayAndShift${suffix}`
            ];
            
            formInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', () => {
                        // If this is a dayAndShift field, also update the Tutorial ID
                        if (inputId.includes('dayAndShift')) {
                            const currentSubject = subject;
                            const boardField = document.getElementById(`board${suffix}`);
                            const yearField = document.getElementById(`year${suffix}`);
                            
                            const board = boardField ? boardField.value : 'JEE Main';
                            const year = yearField ? yearField.value : '2025';
                            
                            updateTutorialId(currentSubject, board, year);
                        }
                        
                        // Regenerate JSON with updated values
                        displaySubjectJSON(subject);
                    });
                }
            });
        }
        
        // Question editing functions
        function updateQuestionText(questionNumber, newText, subject) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (question) {
                question.text = newText;
                // Update the render view
                renderAllQuestions(subject);
                // Update JSON
                displaySubjectJSON(subject);
                // Update button styling
                updateQuestionButtonStyling();
                // Update edit area styling
                updateEditAreaStyling();
            }
        }
        
        function updateQuestionOption(questionNumber, optionIndex, newText, subject) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (question && question.options[optionIndex]) {
                // Update the option text while preserving the numbering
                const optionNumber = optionIndex + 1;
                question.options[optionIndex] = `(${optionNumber}) ${newText}`;
                // Update the render view
                renderAllQuestions(subject);
                // Update JSON
                displaySubjectJSON(subject);
            }
        }
        
        function updateQuestionAnswer(questionNumber, newAnswer, subject) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (question) {
                question.answer = newAnswer;
                // Update the render view
                renderAllQuestions(subject);
                // Update JSON
                displaySubjectJSON(subject);
            }
        }
        
        function updateQuestionSolution(questionNumber, newSolution, subject) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (question) {
                question.solution = newSolution;
                // Update the render view
                renderAllQuestions(subject);
                // Update JSON
                displaySubjectJSON(subject);
                // Update button styling
                updateQuestionButtonStyling();
                // Update edit area styling
                updateEditAreaStyling();
            }
        }
        
        function updateQuestion(questionId, field, value, optionIndex = null) {
            console.log('updateQuestion called:', { questionId, field, value, optionIndex });
            const question = allQuestions.find(q => q.number === questionId);
            if (!question) {
                console.log('Question not found with number:', questionId);
                console.log('Available questions:', allQuestions.map(q => q.number));
                return;
            }
            
            console.log('Found question:', question);
            
            if (field === 'text') {
                question.text = value;
                console.log('Updated text to:', value);
                // Auto-detect question type when text changes
                updateQuestionType(questionId);
                // Update button styling
                updateQuestionButtonStyling();
                // Update edit area styling
                updateEditAreaStyling();
            } else if (field === 'option' && optionIndex !== null) {
                // Ensure options array exists
                if (!question.options) {
                    question.options = ['', '', '', ''];
                }
                // Update option text while preserving the numbering
                const optionNumber = optionIndex + 1;
                question.options[optionIndex] = `(${optionNumber}) ${value}`;
                console.log(`Updated option ${optionIndex} to:`, question.options[optionIndex]);
                // Auto-detect question type when options change
                updateQuestionType(questionId);
            } else if (field === 'solution') {
                question.solution = value;
                console.log('Updated solution to:', value);
                // Update button styling
                updateQuestionButtonStyling();
                // Update edit area styling
                updateEditAreaStyling();
            } else if (field === 'answer') {
                question.answer = value;
                console.log('Updated answer to:', value);
            } else if (field === 'type') {
                question.type = value;
                console.log('Updated type to:', value);
            }
            
            // Update the Live Preview immediately
            console.log('Calling updateLivePreview...');
            updateLivePreview();
        }
        
        function updateLivePreview() {
            console.log('updateLivePreview called');
            const currentSubject = getCurrentSubject();
            const currentQuestionIndex = getCurrentQuestionIndex();
            
            console.log('Current subject:', currentSubject);
            console.log('Current question index:', currentQuestionIndex);
            
            if (currentSubject && currentQuestionIndex !== null) {
                console.log('Calling generateQuestionRender...');
                generateQuestionRender(currentSubject, currentQuestionIndex);
                
                // Also update JSON content if JSON viewer is active
                const jsonPanel = document.getElementById(`jsonViewer-${currentSubject}`);
                if (jsonPanel && jsonPanel.style.display === 'flex') {
                    generateJSONContent(currentSubject);
                }
            } else {
                console.log('Cannot update Live Preview - missing subject or question index');
            }
        }
        
        function getCurrentSubject() {
            // First try to find which tab is active
            const activeTab = document.querySelector('.subject-tab.active');
            if (activeTab) {
                const tabText = activeTab.textContent.trim();
                console.log('Active tab text:', tabText);
                // Check if the text contains the subject name (handles emoji and numbers)
                if (tabText.includes('Mathematics')) return 'Mathematics';
                if (tabText.includes('Physics')) return 'Physics';
                if (tabText.includes('Chemistry')) return 'Chemistry';
            }
            
            // Fallback: Find which subject interface is currently visible
            const activeInterface = document.querySelector('.inline-edit-interface[style*="display: block"], .inline-edit-interface:not([style*="display: none"])');
            console.log('Active interface found:', activeInterface);
            if (activeInterface) {
                const id = activeInterface.id;
                console.log('Interface ID:', id);
                if (id.includes('Mathematics')) return 'Mathematics';
                if (id.includes('Physics')) return 'Physics';
                if (id.includes('Chemistry')) return 'Chemistry';
            }
            return null;
        }
        
        function getCurrentQuestionIndex() {
            // Find the currently selected question
            const activeQuestion = document.querySelector('.question-item.active');
            console.log('Active question found:', activeQuestion);
            if (activeQuestion) {
                const text = activeQuestion.textContent;
                const index = parseInt(text) - 1; // Convert to 0-based index
                console.log('Question text:', text, 'Index:', index);
                return index;
            }
            console.log('No active question found, returning 0');
            return 0;
        }
        
        function toggleQuestionEdit(questionNumber, subject) {
            // This function can be used to toggle edit mode if needed
            console.log(`Toggling edit mode for question ${questionNumber} in ${subject}`);
        }
        
        let currentEditSubject = '';
        let originalQuestions = [];
        
        
        
        function populateInlineEditFields(subject) {
            // Don't populate if we're in single question view mode
            if (isSingleQuestionViewMode) {
                console.log(`Skipping populateInlineEditFields for ${subject} - single question view mode is active`);
                return;
            }
            
            const subjectQuestions = allQuestions.filter(q => {
                const assignedSubject = questionAssignments[q.number];
                const detectedSubject = q.subject;
                return assignedSubject === subject || 
                       (detectedSubject && detectedSubject.toLowerCase() === subject.toLowerCase());
            });
            
            const editQuestionsList = document.getElementById(`editQuestionsList-${subject}`);
            editQuestionsList.innerHTML = '';
            
            subjectQuestions.forEach(question => {
                const questionEditItem = document.createElement('div');
                questionEditItem.className = 'question-edit-item';
                
                // Generate options HTML (options are always in array format now)
                const optionsHtml = question.options.map((opt, optIndex) => {
                    const letter = String.fromCharCode(65 + optIndex);
                    let cleanText = opt ? opt.replace(/^\(\d+\)\s*/, '').trim() : '';
                    // Remove [Image] placeholder if images are present
                    if (question.optionImages && question.optionImages[optIndex] && question.optionImages[optIndex].length > 0) {
                        cleanText = removeImagePlaceholders(cleanText, question.optionImages[optIndex]);
                    }
                    return `
                        <div class="option-edit-item">
                            <label>${letter}:</label>
                            <input type="text" class="option-edit-input" 
                                   data-question="${question.number}" data-option="${optIndex}"
                                   value="${cleanText}" oninput="updateInlineQuestionOption(${question.number}, ${optIndex}, this.value, '${subject}')">
                            
                            <!-- Option Image Upload - Only show if there's an image or allow adding -->
                            ${(() => {
                                const optionImageUrl = (question.optionImages && question.optionImages[optIndex] && question.optionImages[optIndex].length > 0) 
                                    ? (typeof question.optionImages[optIndex][0] === 'object' && question.optionImages[optIndex][0].image 
                                        ? question.optionImages[optIndex][0].image 
                                        : question.optionImages[optIndex][0])
                                    : null;
                                
                                if (optionImageUrl) {
                                    // Show image if it exists
                                    const optionImgObj = question.optionImages && question.optionImages[optIndex] && question.optionImages[optIndex].length > 0 
                                        ? question.optionImages[optIndex][0] 
                                        : null;
                                    const isFirebaseUrl = optionImageUrl.includes('firebasestorage.googleapis.com');
                                    const hasUploadFailed = optionImgObj && optionImgObj.uploadFailed;
                                    const uploadError = hasUploadFailed ? (optionImgObj.uploadError || 'Upload failed') : '';
                                    
                                    return `
                                    <div class="option-image-upload">
                                        <div class="uploaded-images" id="option-images-${question.number}-${optIndex}">
                                            <div class="uploaded-image" style="position: relative;">
                                                <img src="${optionImageUrl}" alt="Option ${letter} image" style="max-width: 200px; max-height: 150px; border-radius: 4px;" onload="checkAndMarkUploadedImage(this)">
                                                ${isFirebaseUrl ? '<div class="upload-checkmark">‚úÖ</div>' : (hasUploadFailed ? `<div class="upload-error" title="${uploadError}">‚ùå</div>` : '')}
                                                <button class="remove-image" onclick="removeOptionImage(${question.number}, ${optIndex})">√ó</button>
                                            </div>
                                        </div>
                                        <input type="file" id="option-image-input-${question.number}-${optIndex}" 
                                               style="display: none;" 
                                               accept="image/*"
                                               onchange="handleOptionImageUpload(event, ${question.number}, ${optIndex})">
                                        <button type="button" style="margin-top: 5px; padding: 5px 10px; font-size: 12px; cursor: pointer;" 
                                                onclick="document.getElementById('option-image-input-${question.number}-${optIndex}').click()">
                                            Replace Image
                                        </button>
                                    </div>`;
                                } else {
                                    // Only show upload area if no image exists (optional - can be collapsed)
                                    return `
                                    <div class="option-image-upload" style="display: none;">
                                        <div class="image-upload-area" 
                                             data-question="${question.number}" 
                                             data-option="${optIndex}"
                                             data-type="option"
                                             onclick="document.getElementById('option-image-input-${question.number}-${optIndex}').click()"
                                             ondrop="handleImageDrop(event, ${question.number}, 'option', ${optIndex})"
                                             ondragover="handleDragOver(event)"
                                             ondragleave="handleDragLeave(event)">
                                            <div class="image-upload-icon">üì∑</div>
                                            <div class="image-upload-text">Click or drag image</div>
                                            <div class="image-upload-hint">Single image for option ${letter}</div>
                                        </div>
                                        <input type="file" id="option-image-input-${question.number}-${optIndex}" 
                                               style="display: none;" 
                                               accept="image/*"
                                               onchange="handleOptionImageUpload(event, ${question.number}, ${optIndex})">
                                        <div class="uploaded-images" id="option-images-${question.number}-${optIndex}">
                                            <!-- Uploaded image will appear here -->
                                        </div>
                                    </div>
                                    <button type="button" style="margin-top: 10px; background: #10b981; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 16px; align-self: flex-start; width: fit-content;" 
                                            onclick="this.previousElementSibling.style.display='block'; this.style.display='none';"
                                            class="add-image-btn-${question.number}-${optIndex}">
                                        + Add Image (Optional)
                                    </button>`;
                                }
                            })()}
                        </div>
                    `;
                }).join('');
                
                questionEditItem.innerHTML = `
                    <div class="question-edit-header">
                        <div class="question-edit-number">Question ${question.number}</div>
                    </div>
                    <div class="question-edit-fields">
                        <div class="edit-field-group">
                            <label>Question Text:</label>
                            <textarea class="question-edit-textarea" 
                                      data-question="${question.number}" 
                                      oninput="updateInlineQuestionText(${question.number}, this.value, '${subject}')">${removeImagePlaceholders(question.text || '', question.textImages || [])}</textarea>
                            
                            <!-- Question Images Upload -->
                            <div class="image-upload-section">
                                <label>Question Images (Multiple):</label>
                                <div class="image-upload-area" 
                                     data-question="${question.number}" 
                                     data-type="question"
                                     onclick="document.getElementById('question-image-input-${question.number}').click()"
                                     ondrop="handleImageDrop(event, ${question.number}, 'question')"
                                     ondragover="handleDragOver(event)"
                                     ondragleave="handleDragLeave(event)">
                                    <div class="image-upload-icon">üì∑</div>
                                    <div class="image-upload-text">Click or drag images here</div>
                                    <div class="image-upload-hint">Multiple images allowed</div>
                        </div>
                                <input type="file" id="question-image-input-${question.number}" 
                                       style="display: none;" 
                                       multiple 
                                       accept="image/*"
                                       onchange="handleQuestionImageUpload(event, ${question.number})">
                                <div class="uploaded-images" id="question-images-${question.number}">
                                    <!-- Uploaded images will appear here -->
                                </div>
                            </div>
                        </div>
                        
                        <div class="edit-field-group">
                            <label>Options:</label>
                            <div class="options-edit-grid">
                                ${optionsHtml}
                            </div>
                        </div>
                        
                        <div class="edit-field-group">
                            <label>Correct Answer:</label>
                            ${question.type === 'fillblank' || question.type === 'integer' ? 
                                `<input type="text" value="${question.answer || ''}" 
                                       data-question="${question.number}"
                                       oninput="updateInlineQuestionAnswer(${question.number}, this.value, '${subject}')"
                                       style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">` :
                                `<select class="answer-edit-select" 
                                    data-question="${question.number}" 
                                    onchange="updateInlineQuestionAnswer(${question.number}, this.value, '${subject}')">
                                <option value="1" ${question.answer === '1' ? 'selected' : ''}>A</option>
                                <option value="2" ${question.answer === '2' ? 'selected' : ''}>B</option>
                                <option value="3" ${question.answer === '3' ? 'selected' : ''}>C</option>
                                <option value="4" ${question.answer === '4' ? 'selected' : ''}>D</option>
                                </select>`
                            }
                        </div>
                        
                        <div class="edit-field-group">
                            <label>Solution:</label>
                            <textarea class="solution-edit-textarea" 
                                      data-question="${question.number}" 
                                      oninput="updateInlineQuestionSolution(${question.number}, this.value, '${subject}')">${removeImagePlaceholders(question.solution || '', question.solutionTextImages || [])}</textarea>
                            
                            <!-- Solution Images Upload -->
                            <div class="image-upload-section">
                                <label>Solution Images (Multiple):</label>
                                <div class="image-upload-area" 
                                     data-question="${question.number}" 
                                     data-type="solution"
                                     onclick="document.getElementById('solution-image-input-${question.number}').click()"
                                     ondrop="handleImageDrop(event, ${question.number}, 'solution')"
                                     ondragover="handleDragOver(event)"
                                     ondragleave="handleDragLeave(event)">
                                    <div class="image-upload-icon">üì∑</div>
                                    <div class="image-upload-text">Click or drag images here</div>
                                    <div class="image-upload-hint">Multiple images allowed</div>
                                </div>
                                <input type="file" id="solution-image-input-${question.number}" 
                                       style="display: none;" 
                                       multiple 
                                       accept="image/*"
                                       onchange="handleSolutionImageUpload(event, ${question.number})">
                                <div class="uploaded-images" id="solution-images-${question.number}">
                                    <!-- Uploaded images will appear here -->
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                editQuestionsList.appendChild(questionEditItem);
            });
            
            // Populate the render view
            populateInlineRenderView(subject);
        }
        
        function updateInlinePreview(subject) {
            // Update the questions data with current form values
            const editFields = document.querySelectorAll(`#editQuestionsList-${subject} .question-edit-item`);
            
            editFields.forEach(editField => {
                const questionNumber = parseInt(editField.querySelector('[data-question]').getAttribute('data-question'));
                const question = allQuestions.find(q => q.number === questionNumber);
                
                if (question) {
                    // Update question text
                    const questionTextarea = editField.querySelector('.question-edit-textarea');
                    if (questionTextarea) {
                        question.text = questionTextarea.value;
                    }
                    
                    // Update options
                    const optionInputs = editField.querySelectorAll('.option-edit-input');
                    optionInputs.forEach((input, index) => {
                        const optionNumber = index + 1;
                        question.options[index] = `(${optionNumber}) ${input.value}`;
                    });
                    
                    // Update answer
                    const answerSelect = editField.querySelector('.answer-edit-select');
                    if (answerSelect) {
                        question.answer = answerSelect.value;
                    }
                    
                    // Update solution
                    const solutionTextarea = editField.querySelector('.solution-edit-textarea');
                    if (solutionTextarea) {
                        question.solution = solutionTextarea.value;
                    }
                }
            });
            
            // Update the main view
            displaySubjectJSON(subject);
            renderAllQuestions(subject);
        }
        
        function saveAllInlineChanges(subject) {
            // Auto-save is now handled by individual field updates
            // This function is kept for compatibility but does nothing
            console.log('Auto-save is enabled - changes are saved automatically');
        }
        
        function updateInlineQuestionText(questionNumber, newText, subject) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (question) {
                question.text = newText;
                populateInlineRenderView(subject);
                // Update button styling
                updateQuestionButtonStyling();
                // Update edit area styling
                updateEditAreaStyling();
            }
        }
        
        function updateInlineQuestionOption(questionNumber, optionIndex, newValue, subject) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (question) {
                const optionNumber = optionIndex + 1;
                question.options[optionIndex] = `(${optionNumber}) ${newValue}`;
                populateInlineRenderView(subject);
            }
        }
        
        function updateInlineQuestionAnswer(questionNumber, newAnswer, subject) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (question) {
                question.answer = newAnswer;
                populateInlineRenderView(subject);
            }
        }
        
        function updateInlineQuestionSolution(questionNumber, newSolution, subject) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (question) {
                question.solution = newSolution;
                populateInlineRenderView(subject);
                // Update button styling
                updateQuestionButtonStyling();
                // Update edit area styling
                updateEditAreaStyling();
            }
        }
        
        function populateInlineRenderView(subject) {
            const subjectQuestions = allQuestions.filter(q => {
                const assignedSubject = questionAssignments[q.number];
                const detectedSubject = q.subject;
                return assignedSubject === subject || 
                       (detectedSubject && detectedSubject.toLowerCase() === subject.toLowerCase());
            });
            
            let renderHtml = '';
            subjectQuestions.forEach(question => {
                // Generate options HTML (options are always in array format now)
                const optionsHtml = question.options.map((opt, optIndex) => {
                    const letter = String.fromCharCode(65 + optIndex);
                    const cleanText = opt ? opt.replace(/^\(\d+\)\s*/, '').trim() : '';
                    return `<div class="option-render"><strong>${letter}.</strong> ${cleanText}</div>`;
                }).join('\n');
                
                // Find correct answer text using helper function
                const answerText = getCorrectAnswerText(question);
                const answerLetter = question.answer ? String.fromCharCode(64 + parseInt(question.answer)) : '';
                
                renderHtml += `
                    <div class="question-render" id="inline-render-q${question.number}">
                        <h4>Question ${question.number}</h4>
                        <div class="question-text">${question.text}</div>
                        <div class="options-render">${optionsHtml}</div>
                        ${answerText ? `<div class="answer-render">Answer: ${answerLetter}. ${answerText}</div>` : ''}
                        ${question.solution ? `<div class="solution-render">Solution: ${cleanSolutionText(question.solution)}</div>` : ''}
                        <hr style="margin: 20px 0; border: 1px solid #eee;">
                    </div>
                `;
            });
            
            const renderContainerId = subject === 'Mathematics' ? 'inlineMathRender' :
                                    subject === 'Physics' ? 'inlinePhysicsRender' : 
                                    subject === 'Chemistry' ? 'inlineChemistryRender' :
                                    'inlineBiologyRender';
            document.getElementById(renderContainerId).innerHTML = renderHtml;
            
            
            // Re-render MathJax
            if (typeof MathJax !== 'undefined') {
                MathJax.typesetPromise([document.getElementById(renderContainerId)]);
            }
        }
        
        function switchTab(subject, tabType) {
            // Tab switching is no longer needed - both panels are always visible
            console.log(`Inline layout - both panels always visible for ${subject}`);
        }
        
        function populateQuestionList(subject) {
            const questionListContainer = document.getElementById(`questionList-${subject}`);
            const subjectQuestions = allQuestions.filter(q => q.subject === subject.toLowerCase());
            
            console.log(`Populating question list for ${subject}`);
            console.log(`Total questions: ${allQuestions.length}`);
            console.log(`Questions for ${subject.toLowerCase()}: ${subjectQuestions.length}`);
            console.log(`All subjects found:`, [...new Set(allQuestions.map(q => q.subject))]);
            
            questionListContainer.innerHTML = '<h4>üìã Questions</h4>';
            
            if (subjectQuestions.length === 0) {
                questionListContainer.innerHTML += '<p style="text-align: center; color: #6c757d; margin-top: 20px;">No questions found</p>';
                return;
            }
            
            // Sort questions by number to detect gaps
            const sortedQuestions = [...subjectQuestions].sort((a, b) => a.number - b.number);
            
            sortedQuestions.forEach((question, index) => {
                // Create container for question item with buttons
                const questionContainer = document.createElement('div');
                questionContainer.className = 'question-item-container';
                
                // Question header with number and expand button
                const questionHeader = document.createElement('div');
                questionHeader.className = 'question-header';
                
                // Question number button
                const questionItem = document.createElement('button');
                questionItem.className = 'question-item';
                questionItem.style.cssText = 'flex: 1; margin-bottom: 0;';
                
                // Add red styling if question needs manual editing
                if (needsManualEditing(question)) {
                    questionItem.classList.add('manual-edit-needed');
                    questionItem.title = 'This question needs manual editing (images or tables)';
                }
                
                questionItem.textContent = `${question.number}`;
                // Use the index from forEach directly - it's already correct for the sorted array
                questionItem.onclick = () => {
                    console.log(`Clicked question ${question.number}, using index ${index} from sorted array`);
                    selectQuestion(subject, index);
                };
                questionHeader.appendChild(questionItem);
                
                // Expand/collapse button
                const expandButton = document.createElement('button');
                expandButton.className = 'question-expand-btn';
                expandButton.innerHTML = '‚ñº';
                expandButton.title = 'Show options';
                
                // Button container for Add and Delete (hidden by default)
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'question-actions-container';
                
                expandButton.onclick = (e) => {
                    e.stopPropagation();
                    const isExpanded = buttonContainer.classList.contains('expanded');
                    if (isExpanded) {
                        buttonContainer.classList.remove('expanded');
                        expandButton.innerHTML = '‚ñº';
                    } else {
                        buttonContainer.classList.add('expanded');
                        expandButton.innerHTML = '‚ñ≤';
                    }
                };
                questionHeader.appendChild(expandButton);
                questionContainer.appendChild(questionHeader);
                
                // Add button
                const addButton = document.createElement('button');
                addButton.textContent = '+ Add';
                addButton.className = 'question-action-btn add-btn';
                addButton.title = `Add question ${question.number + 1} after question ${question.number}`;
                addButton.onclick = (e) => {
                    e.stopPropagation();
                    addQuestionAfter(subject, question.number);
                };
                buttonContainer.appendChild(addButton);
                
                // Delete button
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.className = 'question-action-btn delete-btn';
                deleteButton.title = `Delete question ${question.number}`;
                deleteButton.onclick = (e) => {
                    e.stopPropagation();
                    deleteQuestion(subject, question.number);
                };
                buttonContainer.appendChild(deleteButton);
                
                questionContainer.appendChild(buttonContainer);
                questionListContainer.appendChild(questionContainer);
                
                // Check for gap after this question
                if (index < sortedQuestions.length - 1) {
                    const currentNumber = question.number;
                    const nextNumber = sortedQuestions[index + 1].number;
                    
                    // If there's a gap (e.g., 55 -> 57, or 55 -> 60), add insert buttons for all missing numbers
                    if (nextNumber - currentNumber > 1) {
                        // Add insert buttons for all missing numbers in the gap
                        for (let missingNum = currentNumber + 1; missingNum < nextNumber; missingNum++) {
                            const insertBtn = document.createElement('button');
                            insertBtn.className = 'insert-question-btn';
                            insertBtn.textContent = `+ Add Q${missingNum}`;
                            insertBtn.title = `Insert question ${missingNum} between ${currentNumber} and ${nextNumber}`;
                            insertBtn.onclick = (e) => {
                                e.stopPropagation();
                                insertQuestion(subject, missingNum);
                            };
                            questionListContainer.appendChild(insertBtn);
                        }
                    }
                }
                
                // Debug: Log the mapping between question number and index
                if (index < 5 || index >= sortedQuestions.length - 5) { // Log first 5 and last 5
                    console.log(`Sidebar mapping: index=${index}, questionNumber=${question.number}, subject=${subject}`);
                }
            });
        }
        
        // Function to add a new question after a specific question number
        function addQuestionAfter(subject, afterQuestionNumber) {
            const newQuestionNumber = afterQuestionNumber + 1;
            const subjectLower = subject.toLowerCase();
            
            console.log(`‚ûï Adding question ${newQuestionNumber} after question ${afterQuestionNumber} for ${subject}`);
            
            // Create new question object with default values
            const newQuestion = {
                number: newQuestionNumber,
                subject: subjectLower,
                text: '',
                solution: '',
                type: 'mcq',
                options: ['', '', '', ''],
                answer: '1',
                correctAnswer: '1',
                correctAnswerText: '',
                textImages: [],
                solutionTextImages: [],
                questionImages: [],
                solutionImages: [],
                optionImages: [[], [], [], []]
            };
            
            // Find the index where to insert (after the question with afterQuestionNumber)
            const subjectQuestions = allQuestions.filter(q => q.subject === subjectLower);
            const afterQuestionIndex = allQuestions.findIndex(q => q.number === afterQuestionNumber && q.subject === subjectLower);
            
            if (afterQuestionIndex !== -1) {
                // Insert after the found question
                allQuestions.splice(afterQuestionIndex + 1, 0, newQuestion);
            } else {
                // If not found, add at the end of subject questions
                let lastSubjectQuestionIndex = -1;
                for (let i = allQuestions.length - 1; i >= 0; i--) {
                    if (allQuestions[i].subject === subjectLower) {
                        lastSubjectQuestionIndex = i;
                        break;
                    }
                }
                if (lastSubjectQuestionIndex !== -1) {
                    allQuestions.splice(lastSubjectQuestionIndex + 1, 0, newQuestion);
                } else {
                    // No questions for this subject, just append
                    allQuestions.push(newQuestion);
                }
            }
            
            // Check if question number already exists and renumber if needed
            const existingQuestion = allQuestions.find(q => q.number === newQuestionNumber && q !== newQuestion);
            if (existingQuestion) {
                // Renumber all questions after this one (including the new question)
                const questionsToRenumber = allQuestions.filter(q => q.number >= newQuestionNumber && q !== newQuestion);
                questionsToRenumber.forEach(q => {
                    const oldNumber = q.number;
                    q.number = q.number + 1;
                    // Update question assignments
                    questionAssignments[`Q${q.number}`] = q.subject;
                    delete questionAssignments[`Q${oldNumber}`];
                });
            }
            
            // Update question assignments for the new question
            questionAssignments[`Q${newQuestionNumber}`] = subjectLower;
            
            // Sort all questions by number
            allQuestions.sort((a, b) => a.number - b.number);
            
            // Update statistics
            updateStats();
            
            // Refresh the question list
            populateQuestionList(subject);
            
            // Find and select the new question
            const newSubjectQuestions = allQuestions.filter(q => q.subject === subjectLower);
            const newQuestionIndex = newSubjectQuestions.findIndex(q => q.number === newQuestionNumber);
            
            if (newQuestionIndex !== -1) {
                // Select the new question and show editor
                setTimeout(() => {
                    selectQuestion(subject, newQuestionIndex);
                }, 100);
            }
            
            // Mark as unsaved
            markWorkAsUnsaved();
        }
        
        // Function to insert a question at a specific question number (for gap filling)
        function insertQuestion(subject, questionNumber) {
            console.log(`Inserting question ${questionNumber} for subject ${subject}`);
            
            // Create a new question object with default values
            const newQuestion = {
                number: questionNumber,
                subject: subject.toLowerCase(),
                text: '',
                solution: '',
                type: 'mcq',
                options: ['(1) ', '(2) ', '(3) ', '(4) '],
                answer: '1',
                correctAnswer: '1',
                correctAnswerText: '',
                textImages: [],
                solutionTextImages: [],
                questionImages: [],
                solutionImages: [],
                optionImages: [[], [], [], []]
            };
            
            // Find the correct position to insert (maintain sorted order by number)
            const subjectQuestions = allQuestions.filter(q => q.subject === subject.toLowerCase());
            const insertIndex = allQuestions.findIndex(q => {
                if (q.subject === subject.toLowerCase()) {
                    return q.number > questionNumber;
                }
                return false;
            });
            
            // If no question with higher number found, insert at the end of subject questions
            if (insertIndex === -1) {
                // Find the last question of this subject
                let lastSubjectIndex = -1;
                for (let i = allQuestions.length - 1; i >= 0; i--) {
                    if (allQuestions[i].subject === subject.toLowerCase()) {
                        lastSubjectIndex = i;
                        break;
                    }
                }
                if (lastSubjectIndex !== -1) {
                    allQuestions.splice(lastSubjectIndex + 1, 0, newQuestion);
                } else {
                    allQuestions.push(newQuestion);
                }
            } else {
                allQuestions.splice(insertIndex, 0, newQuestion);
            }
            
            // Update question assignments
            questionAssignments[`Q${questionNumber}`] = subject.toLowerCase();
            
            // Re-sort all questions by number
            allQuestions.sort((a, b) => {
                // First sort by subject
                if (a.subject !== b.subject) {
                    const subjectOrder = { 'mathematics': 0, 'physics': 1, 'chemistry': 2 };
                    return (subjectOrder[a.subject] || 99) - (subjectOrder[b.subject] || 99);
                }
                // Then sort by number within subject
                return a.number - b.number;
            });
            
            // Refresh the question list
            populateQuestionList(subject);
            
            // Find the index of the newly inserted question in the subject's question list
            const updatedSubjectQuestions = allQuestions.filter(q => q.subject === subject.toLowerCase());
            const newQuestionIndex = updatedSubjectQuestions.findIndex(q => q.number === questionNumber);
            
            // Select the newly inserted question
            if (newQuestionIndex !== -1) {
                // selectQuestion will handle displaying the editor
                selectQuestion(subject, newQuestionIndex);
                
                // Ensure Edit tab is active
                const toggleButtons = document.querySelectorAll(`#viewerToggle-${subject} .viewer-toggle-btn`);
                if (toggleButtons.length > 0) {
                    // Remove active class from all buttons
                    toggleButtons.forEach(btn => btn.classList.remove('active'));
                    // Add active class to Edit button (first button)
                    if (toggleButtons[0]) {
                        toggleButtons[0].classList.add('active');
                    }
                }
            }
            
            // Update statistics
            updateStats();
            
            console.log(`‚úÖ Successfully inserted question ${questionNumber} for ${subject}`);
        }
        
        // Function to delete a question
        function deleteQuestion(subject, questionNumber) {
            const subjectLower = subject.toLowerCase();
            
            // Confirm deletion
            if (!confirm(`Are you sure you want to delete question ${questionNumber}?`)) {
                return;
            }
            
            console.log(`üóëÔ∏è Deleting question ${questionNumber} from ${subject}`);
            
            // Find and remove the question
            const questionIndex = allQuestions.findIndex(q => q.number === questionNumber && q.subject === subjectLower);
            
            if (questionIndex !== -1) {
                allQuestions.splice(questionIndex, 1);
                
                // Remove from question assignments
                delete questionAssignments[`Q${questionNumber}`];
                
                // Update statistics
                updateStats();
                
                // Refresh the question list
                populateQuestionList(subject);
                
                // Select the first question if available, or clear the editor
                const subjectQuestions = allQuestions.filter(q => q.subject === subjectLower);
                if (subjectQuestions.length > 0) {
                    const firstQuestionIndex = subjectQuestions.findIndex(q => q.subject === subjectLower);
                    if (firstQuestionIndex !== -1) {
                        setTimeout(() => {
                            selectQuestion(subject, 0);
                        }, 100);
                    }
                } else {
                    // No questions left, clear the editor
                    clearQuestionEditor(subject);
                }
                
                // Mark as unsaved
                markWorkAsUnsaved();
            } else {
                console.warn(`Question ${questionNumber} not found for ${subject}`);
            }
        }
        
        // Function to clear question editor when no questions are available
        function clearQuestionEditor(subject) {
            const subjectView = document.getElementById(`subjectView-${subject}`);
            if (subjectView) {
                // Clear question editor fields
                const questionTextarea = subjectView.querySelector('.question-edit-textarea, .question-edit-input');
                const solutionTextarea = subjectView.querySelector('.solution-edit-textarea, .solution-edit-input');
                
                if (questionTextarea) questionTextarea.value = '';
                if (solutionTextarea) solutionTextarea.value = '';
                
                // Clear live preview
                const renderPanel = document.getElementById(`questionRender-${subject}`);
                if (renderPanel) {
                    renderPanel.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 20px;">No question selected</p>';
                }
            }
        }
        
        function selectQuestion(subject, questionIndex) {
            console.log(`=== SELECTING QUESTION ===`);
            console.log(`Subject: ${subject}, Question Index: ${questionIndex}`);
            console.log(`Total allQuestions: ${allQuestions.length}`);
            
            // Filter and sort questions the same way as populateQuestionList does
            const subjectLower = subject.toLowerCase();
            const subjectQuestions = allQuestions.filter(q => {
                const qSubject = q.subject ? q.subject.toLowerCase() : '';
                const matches = qSubject === subjectLower;
                if (!matches && questionIndex === 0) {
                    // Debug first few questions to see what subjects they have
                    console.log(`Question ${q.number} has subject: "${q.subject}" (looking for "${subjectLower}")`);
                }
                return matches;
            });
            const sortedSubjectQuestions = [...subjectQuestions].sort((a, b) => a.number - b.number);
            
            console.log(`Filtered ${subjectQuestions.length} questions for ${subject}`);
            console.log(`Sorted questions:`, sortedSubjectQuestions.map(q => ({number: q.number, subject: q.subject})));
            
            // Validate index
            if (questionIndex < 0 || questionIndex >= sortedSubjectQuestions.length) {
                console.error(`Invalid question index ${questionIndex} for ${subject}. Total questions: ${sortedSubjectQuestions.length}`);
                console.error(`Available indices: 0 to ${sortedSubjectQuestions.length - 1}`);
                return;
            }
            
            const question = sortedSubjectQuestions[questionIndex];
            const questionNumber = question.number;
            
            console.log(`‚úÖ Selected question details:`, {
                index: questionIndex,
                questionNumber: questionNumber,
                totalQuestions: sortedSubjectQuestions.length,
                questionText: question.text ? question.text.substring(0, 50) + '...' : 'No text',
                question: question
            });
            
            // Remove active class from all question items
            const questionItems = document.querySelectorAll(`#questionList-${subject} .question-item`);
            console.log(`Found ${questionItems.length} question items for ${subject}`);
            questionItems.forEach(item => item.classList.remove('active'));
            
            // Find the button by question number instead of index (more reliable)
            const questionButton = Array.from(questionItems).find(btn => parseInt(btn.textContent.trim()) === questionNumber);
            if (questionButton) {
                questionButton.classList.add('active');
                console.log(`Activated question item for Question ${questionNumber}`);
            } else {
                // Fallback: try by index
                if (questionItems[questionIndex]) {
                    questionItems[questionIndex].classList.add('active');
                    console.log(`Activated question item at index ${questionIndex} (fallback)`);
                } else {
                    console.warn(`Question item for Question ${questionNumber} not found!`);
                }
            }
            
            // Show the viewer toggle and render panels
            const viewerToggle = document.getElementById(`viewerToggle-${subject}`);
            const renderPanel = document.getElementById(`questionRender-${subject}`);
            
            if (viewerToggle) {
                viewerToggle.style.display = 'flex';
                console.log(`Set viewer toggle display to flex for ${subject}`);
            } else {
                console.log(`Viewer toggle not found for ${subject}`);
            }
            
            if (renderPanel) {
                renderPanel.style.display = 'block';
                console.log(`Set render panel display to block for ${subject}`);
                console.log(`Render panel properties:`, {
                    display: renderPanel.style.display,
                    offsetHeight: renderPanel.offsetHeight,
                    clientHeight: renderPanel.clientHeight
                });
            } else {
                console.log(`Render panel not found for ${subject}`);
            }
            
            // Check which viewer is currently active and show only that one
            const editorPanel = document.getElementById(`questionEditor-${subject}`);
            const jsonPanel = document.getElementById(`jsonViewer-${subject}`);
            // renderPanel already declared above
            const toggleButtons = document.querySelectorAll(`#viewerToggle-${subject} .viewer-toggle-btn`);
            
            // Check which viewer is active
            const isJsonViewerActive = toggleButtons[1] && toggleButtons[1].classList.contains('active');
            const isPreviewActive = toggleButtons[2] && toggleButtons[2].classList.contains('active');
            const isEditorActive = toggleButtons[0] && toggleButtons[0].classList.contains('active');
            
            // If skipAutoPreviewSwitch is set, force Edit view and reset flag
            const skipAuto = window.skipAutoPreviewSwitch || false;
            if (skipAuto) {
                switchViewer(subject, 'editor');
                window.skipAutoPreviewSwitch = false; // Reset flag
                // Still need to generate the editor content
                editorPanel.style.display = 'block';
                jsonPanel.style.display = 'none';
                if (renderPanel) renderPanel.style.display = 'block';
                generateQuestionEditor(subject, questionIndex);
            } else if (!isJsonViewerActive && !isPreviewActive && !isEditorActive) {
                // If no viewer is active, default to Edit (editor)
                switchViewer(subject, 'editor');
                editorPanel.style.display = 'block';
                jsonPanel.style.display = 'none';
                if (renderPanel) renderPanel.style.display = 'block';
                generateQuestionEditor(subject, questionIndex);
            } else if (isJsonViewerActive) {
                // JSON viewer is active - show JSON panel and render panel
                editorPanel.style.display = 'none';
                jsonPanel.style.display = 'flex';
                if (renderPanel) renderPanel.style.display = 'block';
                generateJSONContent(subject);
            } else if (isPreviewActive) {
                // Preview is active
                editorPanel.style.display = 'none';
                jsonPanel.style.display = 'none';
                if (renderPanel) renderPanel.style.display = 'block';
                generateFullPreview(subject);
            } else {
                // Question editor is active - show editor panel and render panel
                editorPanel.style.display = 'block';
                jsonPanel.style.display = 'none';
                if (renderPanel) renderPanel.style.display = 'block';
                generateQuestionEditor(subject, questionIndex);
            }
            
            // Always generate the render (Live Preview)
            console.log(`Calling generateQuestionRender for ${subject}, questionIndex: ${questionIndex}`);
            generateQuestionRender(subject, questionIndex);
            
            // Update edit area styling for the selected question
            setTimeout(() => {
                updateEditAreaStyling();
            }, 100);
        }
        
        // Debug function to check question data
        function debugQuestions() {
            console.log(`=== QUESTION DEBUG INFO ===`);
            console.log(`Total questions: ${allQuestions.length}`);
            console.log(`All subjects:`, [...new Set(allQuestions.map(q => q.subject))]);
            
            const subjects = ['mathematics', 'physics', 'chemistry'];
            subjects.forEach(subject => {
                const questions = allQuestions.filter(q => q.subject === subject);
                console.log(`${subject}: ${questions.length} questions`);
                if (questions.length > 0) {
                    console.log(`  Sample:`, questions.slice(0, 3).map(q => ({number: q.number, subject: q.subject})));
                }
            });
            
            // Check containers
            const containers = ['inlineMathRender', 'inlinePhysicsRender', 'inlineChemistryRender'];
            containers.forEach(containerId => {
                const container = document.getElementById(containerId);
                console.log(`${containerId}:`, container ? 'Found' : 'NOT FOUND');
            });
        }
        
        // Make debug function available globally
        window.debugQuestions = debugQuestions;
        
        // JSON Viewer Functions
        function switchViewer(subject, viewerType) {
            const editorPanel = document.getElementById(`questionEditor-${subject}`);
            const jsonPanel = document.getElementById(`jsonViewer-${subject}`);
            const renderPanel = document.getElementById(`questionRender-${subject}`);
            const toggleButtons = document.querySelectorAll(`#viewerToggle-${subject} .viewer-toggle-btn`);
            const questionSidebar = document.getElementById(`questionList-${subject}`);
            
            // Remove active class from all toggle buttons
            toggleButtons.forEach(btn => btn.classList.remove('active'));
            
            if (viewerType === 'editor') {
                editorPanel.style.display = 'block';
                jsonPanel.style.display = 'none';
                renderPanel.style.display = 'block';
                if (questionSidebar) questionSidebar.style.display = 'block'; // Show sidebar for editor
                toggleButtons[0].classList.add('active');
            } else if (viewerType === 'json') {
                editorPanel.style.display = 'none';
                jsonPanel.style.display = 'flex';
                renderPanel.style.display = 'none'; // Hide Live Preview when JSON viewer is active
                if (questionSidebar) questionSidebar.style.display = 'none'; // Hide sidebar for JSON viewer
                toggleButtons[1].classList.add('active');
                
                // Generate JSON content when switching to JSON viewer
                generateJSONContent(subject);
            } else if (viewerType === 'preview') {
                editorPanel.style.display = 'none';
                jsonPanel.style.display = 'none';
                renderPanel.style.display = 'block'; // Show Live Preview
                if (questionSidebar) questionSidebar.style.display = 'none'; // Hide sidebar for preview
                toggleButtons[2].classList.add('active');
                
                // Generate full preview with all questions
                generateFullPreview(subject);
            }
        }
        
        function generateFullPreview(subject) {
            console.log(`=== GENERATING FULL PREVIEW FOR ${subject} ===`);
            
            const subjectQuestions = allQuestions.filter(q => q.subject === subject.toLowerCase());
            console.log(`Total questions for ${subject}: ${subjectQuestions.length}`);
            
            if (subjectQuestions.length === 0) {
                console.log(`No questions found for ${subject}`);
                return;
            }
            
            // Map subject names to correct container IDs
            const containerIdMap = {
                'Mathematics': 'inlineMathRender',
                'Physics': 'inlinePhysicsRender', 
                'Chemistry': 'inlineChemistryRender',
                'Biology': 'inlineBiologyRender'
            };
            
            const renderContainerId = containerIdMap[subject];
            if (!renderContainerId) {
                console.error(`No container ID mapped for subject: ${subject}`);
                return;
            }
            
            const renderContainer = document.getElementById(renderContainerId);
            console.log(`Container ID: ${renderContainerId} for subject ${subject}`);
            console.log(`Render container found:`, renderContainer);
            
            if (!renderContainer) {
                console.error(`ERROR: Render container "${renderContainerId}" not found for ${subject}!`);
                return;
            }
            
            // Generate HTML for all questions
            let allQuestionsHTML = '';
            subjectQuestions.forEach((question, index) => {
                allQuestionsHTML += `
                    <div class="question-render-item" id="render-question-${index}">
                        <h5>Question ${question.number}</h5>
                        <div class="question-type" style="margin-bottom: 12px; padding: 6px 12px; background: var(--primary-color); color: white; border-radius: var(--radius-sm); display: inline-block; font-size: 12px; font-weight: 600; text-transform: uppercase;">
                            Type: ${question.type || 'mcq'}
                        </div>
                        <div class="question-text">${removeImageTextFromPreview(question.text || '')}</div>
                    
                    ${(question.questionImages || []).map(img => `<img src="${img}" alt="Question image" style="max-width: 100%; margin: 10px 0;">`).join('')}
                    
                    <div class="options">
                        ${['A', 'B', 'C', 'D'].map((option, idx) => `
                            <div class="option">
                                <strong>${option}.</strong> ${removeImageTextFromPreview(question.options && question.options[idx] ? question.options[idx].replace(/^\(\d+\)\s*/, '').trim() : '')}
                                ${(() => {
                                    if (question.optionImages && question.optionImages[idx] && question.optionImages[idx].length > 0) {
                                        const imgObj = question.optionImages[idx][0];
                                        const imageUrl = (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                                        if (imageUrl) {
                                            return `<img src="${imageUrl}" alt="Option image" style="max-width: 100px; margin-left: 10px;" onload="checkAndMarkUploadedImage(this)">`;
                                        }
                                    }
                                    return '';
                                })()}
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="answer" style="color: green; font-weight: bold; margin: 15px 0;">
                        Answer: ${question.type === 'fillblank' || question.type === 'integer' ? (question.answer || '') : (question.answer ? String.fromCharCode(64 + parseInt(question.answer)) : '')}
                    </div>
                    
                    <div class="solution">
                        <strong>Solution:</strong>
                        <div>${removeImageTextFromPreview(question.solution || '')}</div>
                        ${(question.solutionTextImages || []).map(item => `
                            ${item.image ? `<img src="${item.image}" alt="Solution image" style="max-width: 100%; margin: 10px 0;">` : ''}
                            ${item.text ? `<div style="margin: 10px 0;">${removeImageTextFromPreview(item.text || '')}</div>` : ''}
                        `).join('')}
                    </div>
                </div>
                `;
            });
            
            renderContainer.innerHTML = allQuestionsHTML;
            console.log(`Rendered ${subjectQuestions.length} questions for ${subject}`);
            
            // Re-render MathJax
            if (typeof MathJax !== 'undefined') {
                MathJax.typesetPromise([renderContainer]);
            }
        }
        
        function generateJSONContent(subject) {
            const subjectQuestions = allQuestions.filter(q => q.subject === subject.toLowerCase());
            const jsonContent = document.getElementById(`jsonContent-${subject}`);
            
            if (subjectQuestions.length === 0) {
                jsonContent.textContent = 'No questions found for this subject.';
                return;
            }
            
            // Get metadata values from form inputs
            const getFormValue = (id) => {
                const element = document.getElementById(id);
                return element ? element.value : '';
            };
            
            const suffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry';
            const tutorialId = getFormValue(`tutorialId${suffix}`);
            const tutorialTitle = getFormValue(`tutorialTitle${suffix}`);
            const tutorialDescription = getFormValue(`tutorialDescription${suffix}`);
            const authorityExamId = getFormValue(`authorityExamId${suffix}`);
            const state = getFormValue(`state${suffix}`);
            const board = getFormValue(`board${suffix}`);
            const conductedBy = getFormValue(`conductedBy${suffix}`);
            const year = getFormValue(`year${suffix}`);
            const subjectValue = getFormValue(`subject${suffix}`);
            const dayAndShift = getFormValue(`dayAndShift${suffix}`);
            
            // Create JSON in the specified format
            const jsonData = [
                {
                    "tutorialId": tutorialId || `${board || 'KCET'}_${year || '2025'}_${subject}`,
                    "tutorialTitle": tutorialTitle || `${board || 'KCET'} ${year || '2025'} ${subject}`,
                    "tutorialDescription": tutorialDescription || "",
                    "authorityExamId": authorityExamId || "kar_kect",
                    "state": state || "Karnataka",
                    "board": board || "KCET",
                    "conductedBy": conductedBy || "KEA (Karnataka Examinations Authority)",
                    "year": year || "2025",
                    "subject": subjectValue || subject,
                    "dayAndShift": dayAndShift || "2 April 2025 Shift - 2",
                    "questions": subjectQuestions.map((question, index) => {
                        // Clean [Image] text from textImages array
                        const cleanedTextImages = (question.textImages || []).map(item => {
                            if (typeof item === 'string') {
                                return item;
                            } else if (item && typeof item === 'object') {
                                return {
                                    ...item,
                                    text: item.text ? removeImageTextFromPreview(item.text) : item.text
                                };
                            }
                            return item;
                        });
                        
                        // Clean [Image] text from solutionTextImages array
                        const cleanedSolutionTextImages = (question.solutionTextImages || []).map(item => {
                            if (typeof item === 'string') {
                                return item;
                            } else if (item && typeof item === 'object') {
                                return {
                                    ...item,
                                    text: item.text ? removeImageTextFromPreview(item.text) : item.text
                                };
                            }
                            return item;
                        });
                        
                        return {
                        "questionIndex": question.number.toString(),
                        "questionId": `2025${subject.charAt(0)}Q${question.number}`,
                        "questionDetails": [
                            {
                                "text": removeImageTextFromPreview(question.text || ''),
                                "textImages": cleanedTextImages,
                                "possibleAnswers": {
                                    "A": {
                                        "text": removeImageTextFromPreview(question.options && question.options[0] ? question.options[0].replace(/^\(\d+\)\s*/, '').trim() : ''),
                                        "image": question.optionImages && question.optionImages[0] ? question.optionImages[0] : null
                                    },
                                    "B": {
                                        "text": removeImageTextFromPreview(question.options && question.options[1] ? question.options[1].replace(/^\(\d+\)\s*/, '').trim() : ''),
                                        "image": question.optionImages && question.optionImages[1] ? question.optionImages[1] : null
                                    },
                                    "C": {
                                        "text": removeImageTextFromPreview(question.options && question.options[2] ? question.options[2].replace(/^\(\d+\)\s*/, '').trim() : ''),
                                        "image": question.optionImages && question.optionImages[2] ? question.optionImages[2] : null
                                    },
                                    "D": {
                                        "text": removeImageTextFromPreview(question.options && question.options[3] ? question.options[3].replace(/^\(\d+\)\s*/, '').trim() : ''),
                                        "image": question.optionImages && question.optionImages[3] ? question.optionImages[3] : null
                                    }
                                },
                                "correctAnswer": question.answer || '',
                                "correctAnswerText": removeImageTextFromPreview(question.options && question.answer && question.options[parseInt(question.answer) - 1] ? 
                                    question.options[parseInt(question.answer) - 1].replace(/^\(\d+\)\s*/, '').trim() : ''),
                                "solution": removeImageTextFromPreview(question.solution || ''),
                                "solutionTextImages": cleanedSolutionTextImages,
                                "type": question.type || "mcq",
                                "metadata": {
                                    "subject": subject.toLowerCase(),
                                    "number": question.number || (index + 1)
                                }
                            }
                        ]
                    }})
                }
            ];
            
            // Format JSON with proper indentation
            jsonContent.textContent = JSON.stringify(jsonData, null, 2);
        }
        
        function copyJSON(subject) {
            const jsonContent = document.getElementById(`jsonContent-${subject}`);
            const text = jsonContent.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                // Show success feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '‚úÖ Copied!';
                button.style.background = 'var(--success-color)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy JSON:', err);
                alert('Failed to copy JSON to clipboard');
            });
        }
        
        function downloadJSON(subject) {
            const jsonContent = document.getElementById(`jsonContent-${subject}`);
            const text = jsonContent.textContent;
            
            // Get metadata values from form inputs
            const getFormValue = (id) => {
                const element = document.getElementById(id);
                return element ? element.value : '';
            };
            
            const suffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry';
            const yearValue = getFormValue(`year${suffix}`) || '2025';
            const boardValue = getFormValue(`board${suffix}`) || 'KCET';
            const dayAndShift = getFormValue(`dayAndShift${suffix}`) || '2 April 2025 Shift - 2';
            const subjectLower = subject.toLowerCase();
            
            // Parse day and shift from dayAndShift field
            let dayShiftSuffix = '';
            if (dayAndShift) {
                const dayShiftMatch = dayAndShift.match(/(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})\s+Shift\s*-\s*(\d+)/i);
                if (dayShiftMatch) {
                    const day = dayShiftMatch[1];
                    const month = dayShiftMatch[2].toLowerCase();
                    const shift = dayShiftMatch[4];
                    dayShiftSuffix = `_${day}_${month}_shift_${shift}`;
                }
            }
            
            const filename = `${yearValue}_${boardValue.toLowerCase().replace(/\s+/g, '_')}_${subjectLower}${dayShiftSuffix}.json`;
            
            const blob = new Blob([text], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function refreshJSON(subject) {
            generateJSONContent(subject);
            
            // Show success feedback
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '‚úÖ Refreshed!';
            button.style.background = 'var(--success-color)';
            
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '';
            }, 2000);
        }
        
        function generateQuestionEditor(subject, questionIndex) {
            console.log(`=== GENERATING QUESTION EDITOR ===`);
            console.log(`Subject: ${subject}, Question Index: ${questionIndex}`);
            
            // Filter and sort questions the same way as populateQuestionList and selectQuestion
            const subjectLower = subject.toLowerCase();
            const subjectQuestions = allQuestions.filter(q => {
                const qSubject = q.subject ? q.subject.toLowerCase() : '';
                return qSubject === subjectLower;
            });
            const sortedSubjectQuestions = [...subjectQuestions].sort((a, b) => a.number - b.number);
            
            console.log(`Filtered ${subjectQuestions.length} questions for editor in ${subject}`);
            console.log(`Sorted questions for editor:`, sortedSubjectQuestions.map(q => q.number));
            
            if (questionIndex < 0 || questionIndex >= sortedSubjectQuestions.length) {
                console.error(`Invalid question index ${questionIndex} for editor. Total: ${sortedSubjectQuestions.length}`);
                return;
            }
            
            const question = sortedSubjectQuestions[questionIndex];
            
            if (!question) {
                console.error(`Question not found at index ${questionIndex} for subject ${subject}. Total questions: ${sortedSubjectQuestions.length}`);
                return;
            }
            
            console.log(`‚úÖ Generating editor for Question ${question.number} (index ${questionIndex}) in ${subject}`);
            console.log(`Question text preview:`, question.text ? question.text.substring(0, 100) : 'No text');
            
            const editorContainer = document.getElementById(`editQuestionsList-${subject}`);
            if (!editorContainer) {
                console.error(`‚ùå Editor container not found: editQuestionsList-${subject}`);
                return;
            }
            
            // Set flag to prevent populateInlineEditFields from overwriting
            isSingleQuestionViewMode = true;
            
            // Clear the container completely before adding the single question
            editorContainer.innerHTML = '';
            console.log(`Cleared editor container, about to add Question ${question.number}`);
            
            // Generate HTML for only the selected question
            editorContainer.innerHTML = `
                <div class="question-edit-item">
                    <h5>Question ${question.number}</h5>
                    <div class="edit-field">
                        <label>Question Type:</label>
                        <select class="answer-edit-select" 
                                onchange="updateQuestion(${question.number}, 'type', this.value)">
                            <option value="mcq" ${question.type === 'mcq' ? 'selected' : ''}>MCQ</option>
                            <option value="integer" ${question.type === 'integer' ? 'selected' : ''}>Integer</option>
                            <option value="truefalse" ${question.type === 'truefalse' ? 'selected' : ''}>True/False</option>
                            <option value="fillblank" ${question.type === 'fillblank' ? 'selected' : ''}>Fill in the Blank</option>
                        </select>
                    </div>
                    
                    <div class="edit-field">
                        <label>Question Text:</label>
                        <textarea class="question-edit-input" oninput="updateQuestion(${question.number}, 'text', this.value)">${removeImagePlaceholders(question.text || '', question.textImages || [])}</textarea>
                    </div>
                    
                    <div class="image-upload-section">
                        <label>Question Content (Text & Images):</label>
                        <div id="question-content-rows-${question.number}" style="display: flex; flex-direction: column; gap: 15px;">
                            ${(question.textImages || []).map((item, idx) => `
                                <div class="content-row" data-row-index="${idx}" style="display: flex; gap: 10px; align-items: stretch;">
                                    ${item.image ? `
                                        <div style="flex: 1; min-height: 100px; border: 2px dashed #ccc; border-radius: 8px; padding: 8px; display: flex; align-items: center; justify-content: center; position: relative;">
                                            <img src="${item.image}" alt="Question image" style="max-width: 100%; max-height: 120px; border-radius: 4px;" onload="checkAndMarkUploadedImage(this)">
                                            ${item.image && item.image.includes('firebasestorage.googleapis.com') ? '<div class="upload-checkmark">‚úÖ</div>' : (item.uploadFailed ? `<div class="upload-error" title="${item.uploadError || 'Upload failed'}">‚ùå</div>` : '')}
                                        </div>
                                    ` : `
                                        <div style="flex: 1; min-height: 100px; border: 2px dashed #ccc; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; background: #f8f9fa;" 
                                             onclick="uploadImageForRow(${question.number}, ${idx})"
                                             ondrop="handleRowImageDrop(event, ${question.number}, ${idx})"
                                             ondragover="event.preventDefault(); event.currentTarget.style.background='#e3f2fd';"
                                             ondragleave="event.currentTarget.style.background='#f8f9fa';">
                                            <div style="text-align: center; color: #6c757d;">
                                                <div style="font-size: 32px;">üì∑</div>
                                                <div style="font-size: 14px; margin-top: 8px;">Click or drag image here</div>
                                            </div>
                                        </div>
                                    `}
                                    <textarea 
                                        placeholder="Enter text..."
                                        oninput="updateTextImageRow(${question.number}, ${idx}, 'text', this.value)"
                                        style="flex: 1; min-height: 100px; padding: 12px; border: 2px solid #ccc; border-radius: 8px; resize: vertical; font-family: inherit;">${item.text || ''}</textarea>
                                    <button onclick="removeTextImageRow(${question.number}, ${idx})" 
                                            style="background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 18px; height: 40px; width: 40px;" 
                                            title="Remove row">‚àí</button>
                                </div>
                            `).join('')}
                        </div>
                        <button onclick="addTextImageRow(${question.number})" style="margin-top: 10px; background: #10b981; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 16px;">+ Add Row</button>
                        <input type="file" id="image-upload-${question.number}" style="display: none;" accept="image/*" onchange="handleRowImageUpload(event, ${question.number})">
                    </div>
                    
                    <div class="edit-field" style="display: none;">
                        <label>Question Images (Multiple) - OLD:</label>
                    </div>
                    
                    <div class="edit-field">
                        <label>Options:</label>
                        <div class="options-edit-grid">
                            ${['A', 'B', 'C', 'D'].map((option, idx) => {
                                // Handle both array and object formats
                                let optionText = '';
                                if (question.options) {
                                    if (Array.isArray(question.options)) {
                                        // Array format from .md files: ["text1", "text2", ...]
                                        optionText = question.options[idx] ? question.options[idx].replace(/^\(\d+\)\s*/, '').trim() : '';
                                    } else if (question.options[option] && question.options[option].text) {
                                        // Object format from JSON: {A: {text: "...", image: null}}
                                        optionText = question.options[option].text;
                                    }
                                }
                                // Remove [Image] placeholder if images are present
                                if (question.optionImages && question.optionImages[idx] && question.optionImages[idx].length > 0) {
                                    optionText = removeImagePlaceholders(optionText, question.optionImages[idx]);
                                }
                                return `
                                <div class="option-edit-item">
                                    <label>${option}:</label>
                                    <input type="text" class="option-edit-input" value="${optionText}" oninput="updateQuestion(${question.number}, 'option', this.value, ${idx})">
                                    ${(() => {
                                        const optionImageUrl = (question.optionImages && question.optionImages[idx] && question.optionImages[idx].length > 0) 
                                            ? (typeof question.optionImages[idx][0] === 'object' && question.optionImages[idx][0].image 
                                                ? question.optionImages[idx][0].image 
                                                : question.optionImages[idx][0])
                                            : null;
                                        
                                        if (optionImageUrl) {
                                            // Show image if it exists
                                            const optionImgObj = question.optionImages && question.optionImages[idx] && question.optionImages[idx].length > 0 
                                                ? question.optionImages[idx][0] 
                                                : null;
                                            const isFirebaseUrl = optionImageUrl.includes('firebasestorage.googleapis.com');
                                            const hasUploadFailed = optionImgObj && optionImgObj.uploadFailed;
                                            const uploadError = hasUploadFailed ? (optionImgObj.uploadError || 'Upload failed') : '';
                                            
                                            return `
                                            <div class="option-image-upload">
                                                <div class="uploaded-images" id="option-images-${question.number}-${idx}">
                                                    <div class="uploaded-image" style="position: relative;">
                                                        <img src="${optionImageUrl}" alt="Option ${option} image" style="max-width: 200px; max-height: 150px; border-radius: 4px;" onload="checkAndMarkUploadedImage(this)">
                                                        ${isFirebaseUrl ? '<div class="upload-checkmark">‚úÖ</div>' : (hasUploadFailed ? `<div class="upload-error" title="${uploadError}">‚ùå</div>` : '')}
                                                        <button class="remove-image" onclick="removeOptionImage(${question.number}, ${idx})">√ó</button>
                                                    </div>
                                                </div>
                                                <input type="file" id="option-image-input-${question.number}-${idx}" 
                                                       style="display: none;" 
                                                       accept="image/*"
                                                       onchange="handleOptionImageUpload(event, ${question.number}, ${idx})">
                                                <button type="button" style="margin-top: 5px; padding: 5px 10px; font-size: 12px; cursor: pointer;" 
                                                        onclick="document.getElementById('option-image-input-${question.number}-${idx}').click()">
                                                    Replace Image
                                                </button>
                                            </div>`;
                                        } else {
                                            // Hide upload area if no image exists - only show small button
                                            return `
                                            <div class="option-image-upload" style="display: none;">
                                                <div class="image-upload-area" 
                                                     onclick="document.getElementById('option-image-input-${question.number}-${idx}').click()" 
                                                     ondrop="handleImageDrop(event, ${question.number}, 'option', ${idx})" 
                                                     ondragover="handleDragOver(event)" 
                                                     ondragleave="handleDragLeave(event)">
                                                    <div class="image-upload-icon">üì∑</div>
                                                    <div class="image-upload-text">Option Image</div>
                                                </div>
                                                <input type="file" id="option-image-input-${question.number}-${idx}" 
                                                       accept="image/*" 
                                                       onchange="handleOptionImageUpload(event, ${question.number}, ${idx})" 
                                                       style="display: none;">
                                                <div class="uploaded-images" id="option-images-${question.number}-${idx}">
                                                </div>
                                            </div>
                                            <button type="button" 
                                                    style="margin-top: 10px; background: #10b981; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 16px; align-self: flex-start; width: fit-content;" 
                                                    class="add-image-btn-${question.number}-${idx}"
                                                    onclick="const uploadDiv = this.previousElementSibling; uploadDiv.style.display='block'; this.style.display='none';">
                                                + Add Image (Optional)
                                            </button>`;
                                        }
                                    })()}
                                </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    
                    <div class="edit-field">
                        <label>Correct Answer:</label>
                        ${question.type === 'fillblank' || question.type === 'integer' ? 
                            `<input type="text" value="${question.answer || ''}" 
                                   oninput="updateQuestion(${question.number}, 'answer', this.value)"
                                   style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%;">` :
                            `<select class="answer-edit-select" onchange="updateQuestion(${question.number}, 'answer', this.value)">
                                <option value="1" ${question.answer === '1' ? 'selected' : ''}>A</option>
                                <option value="2" ${question.answer === '2' ? 'selected' : ''}>B</option>
                                <option value="3" ${question.answer === '3' ? 'selected' : ''}>C</option>
                                <option value="4" ${question.answer === '4' ? 'selected' : ''}>D</option>
                            </select>`
                        }
                    </div>
                    
                    <div class="edit-field">
                        <label>Solution:</label>
                        <textarea class="solution-edit-input" oninput="updateQuestion(${question.number}, 'solution', this.value)">${removeImagePlaceholders(question.solution || '', question.solutionTextImages || [])}</textarea>
                        <button class="ai-analyzer-btn" id="ai-btn-${question.number}" onclick="analyzeAndFormatSolution(${question.number})">
                            ü§ñ AI Analyzer - Format Step by Step
                        </button>
                        <div class="ai-status" id="ai-status-${question.number}"></div>
                    </div>
                    
                    <div class="image-upload-section">
                        <label>Solution Content (Text & Images):</label>
                        <div id="solution-content-rows-${question.number}" style="display: flex; flex-direction: column; gap: 15px;">
                            ${(question.solutionTextImages || []).map((item, idx) => `
                                <div class="content-row" data-row-index="${idx}" style="display: flex; gap: 10px; align-items: stretch;">
                                    ${item.image ? `
                                        <div style="flex: 1; min-height: 100px; border: 2px dashed #ccc; border-radius: 8px; padding: 8px; display: flex; align-items: center; justify-content: center; position: relative;">
                                            <img src="${item.image}" alt="Solution image" style="max-width: 100%; max-height: 120px; border-radius: 4px;" onload="checkAndMarkUploadedImage(this)">
                                            ${item.image && item.image.includes('firebasestorage.googleapis.com') ? '<div class="upload-checkmark">‚úÖ</div>' : (item.uploadFailed ? `<div class="upload-error" title="${item.uploadError || 'Upload failed'}">‚ùå</div>` : '')}
                                        </div>
                                    ` : `
                                        <div style="flex: 1; min-height: 100px; border: 2px dashed #ccc; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; background: #f8f9fa;" 
                                             onclick="uploadSolutionImageForRow(${question.number}, ${idx})"
                                             ondrop="handleSolutionRowImageDrop(event, ${question.number}, ${idx})"
                                             ondragover="event.preventDefault(); event.currentTarget.style.background='#e3f2fd';"
                                             ondragleave="event.currentTarget.style.background='#f8f9fa';">
                                            <div style="text-align: center; color: #6c757d;">
                                                <div style="font-size: 32px;">üì∑</div>
                                                <div style="font-size: 14px; margin-top: 8px;">Click or drag image here</div>
                                            </div>
                                        </div>
                                    `}
                                    <textarea 
                                        placeholder="Enter text..."
                                        oninput="updateSolutionTextImageRow(${question.number}, ${idx}, 'text', this.value)"
                                        style="flex: 1; min-height: 100px; padding: 12px; border: 2px solid #ccc; border-radius: 8px; resize: vertical; font-family: inherit;">${item.text || ''}</textarea>
                                    <button onclick="removeSolutionTextImageRow(${question.number}, ${idx})" 
                                            style="background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 18px; height: 40px; width: 40px;" 
                                            title="Remove row">‚àí</button>
                                </div>
                            `).join('')}
                        </div>
                        <button onclick="addSolutionTextImageRow(${question.number})" style="margin-top: 10px; background: #10b981; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 16px;">+ Add Row</button>
                        <input type="file" id="solution-image-upload-${question.number}" style="display: none;" accept="image/*" onchange="handleSolutionRowImageUpload(event, ${question.number})">
                    </div>
                </div>
            `;
            
            console.log(`‚úÖ Editor HTML set for Question ${question.number}. Container has ${editorContainer.children.length} children.`);
            console.log(`Editor container innerHTML length: ${editorContainer.innerHTML.length} characters`);
        }
        
        function generateQuestionRender(subject, questionIndex) {
            console.log(`=== GENERATING SINGLE QUESTION RENDER ===`);
            console.log(`Subject: ${subject}, Question Index: ${questionIndex}`);
            
            // Filter and sort questions the same way as populateQuestionList and selectQuestion
            const subjectQuestions = allQuestions.filter(q => q.subject === subject.toLowerCase());
            const sortedSubjectQuestions = [...subjectQuestions].sort((a, b) => a.number - b.number);
            console.log(`Filtered questions for ${subject}: ${sortedSubjectQuestions.length}`);
            
            if (sortedSubjectQuestions.length === 0) {
                console.log(`No questions found for ${subject}, returning early`);
                return;
            }
            
            if (questionIndex < 0 || questionIndex >= sortedSubjectQuestions.length) {
                console.log(`Invalid question index ${questionIndex} for ${subject}, using index 0`);
                questionIndex = 0;
            }
            
            const question = sortedSubjectQuestions[questionIndex];
            console.log(`Rendering single question: ${question.number} at index ${questionIndex}`);
            
            // Map subject names to correct container IDs
            const containerIdMap = {
                'Mathematics': 'inlineMathRender',
                'Physics': 'inlinePhysicsRender', 
                'Chemistry': 'inlineChemistryRender',
                'Biology': 'inlineBiologyRender'
            };
            
            const renderContainerId = containerIdMap[subject];
            if (!renderContainerId) {
                console.error(`No container ID mapped for subject: ${subject}`);
                return;
            }
            
            const renderContainer = document.getElementById(renderContainerId);
            console.log(`Container ID: ${renderContainerId} for subject ${subject}`);
            console.log(`Render container found:`, renderContainer);
            
            if (!renderContainer) {
                console.error(`ERROR: Render container "${renderContainerId}" not found for ${subject}!`);
                return;
            }
            
            // Get current values from edit boxes if they exist (so Live Preview shows exactly what's in edit boxes)
            let questionText = question.text || '';
            let questionSolution = question.solution || '';
            
            // Try to get the actual textarea value if it exists
            const solutionTextarea = document.querySelector(`textarea.solution-edit-input[data-question="${question.number}"], textarea.solution-edit-textarea[data-question="${question.number}"]`);
            if (solutionTextarea) {
                questionSolution = solutionTextarea.value || questionSolution;
            }
            
            const questionTextarea = document.querySelector(`textarea.question-edit-textarea[data-question="${question.number}"], textarea[data-question="${question.number}"].question-edit-input`);
            if (questionTextarea) {
                questionText = questionTextarea.value || questionText;
            }
            
            // Generate HTML for only the selected question
            const singleQuestionHTML = `
                <div class="question-render-item active-question" id="render-question-${questionIndex}">
                    <h5>Question ${question.number}</h5>
                    <div class="question-type" style="margin-bottom: 12px; padding: 6px 12px; background: var(--primary-color); color: white; border-radius: var(--radius-sm); display: inline-block; font-size: 12px; font-weight: 600; text-transform: uppercase;">
                        Type: ${question.type || 'mcq'}
                    </div>
                    <div class="question-text">${removeImageTextFromPreview(questionText)}</div>
                
                ${(question.textImages || []).map(item => `
                    ${item.image ? `<img src="${item.image}" alt="Question image" style="max-width: 100%; margin: 10px 0;">` : ''}
                    ${item.text ? `<div style="margin: 10px 0;">${removeImageTextFromPreview(item.text || '')}</div>` : ''}
                `).join('')}
                
                <div class="options">
                    ${['A', 'B', 'C', 'D'].map((option, idx) => {
                        // Handle both array and object formats
                        let optionText = '';
                        let optionImage = null;
                        
                        if (question.options) {
                            if (Array.isArray(question.options)) {
                                // Array format from .md files: ["text1", "text2", ...]
                                optionText = question.options[idx] ? question.options[idx].replace(/^\(\d+\)\s*/, '').trim() : '';
                            } else if (question.options[option]) {
                                // Object format from JSON: {A: {text: "...", image: null}}
                                optionText = question.options[option].text || '';
                                optionImage = question.options[option].image || null;
                            }
                        }
                        
                        // Remove [Image] placeholder if images are present
                        if (question.optionImages && question.optionImages[idx] && question.optionImages[idx].length > 0) {
                            optionText = removeImagePlaceholders(optionText, question.optionImages[idx]);
                        }
                        // Always remove [Image] text from preview display
                        optionText = removeImageTextFromPreview(optionText);
                        
                        // Get option image from optionImages array (primary source)
                        let optionImageUrl = null;
                        if (question.optionImages && question.optionImages[idx] && question.optionImages[idx].length > 0) {
                            const imgObj = question.optionImages[idx][0];
                            optionImageUrl = (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                        }
                        // Fallback to optionImage from question.options if optionImages is not available
                        if (!optionImageUrl && optionImage) {
                            optionImageUrl = optionImage;
                        }
                        
                        return `
                        <div class="option">
                            <strong>${option}.</strong> ${optionText}
                            ${optionImageUrl ? `<img src="${optionImageUrl}" alt="Option image" style="max-width: 100px; margin-left: 10px;" onload="checkAndMarkUploadedImage(this)">` : ''}
                        </div>
                        `;
                    }).join('')}
                </div>
                
                <div class="answer" style="color: green; font-weight: bold; margin: 15px 0;">
                    Answer: ${question.type === 'fillblank' || question.type === 'integer' ? (question.answer || '') : (question.answer ? String.fromCharCode(64 + parseInt(question.answer)) : '')}
                </div>
                
                <div class="solution">
                    <strong>Solution:</strong>
                    <div>${removeImageTextFromPreview(questionSolution)}</div>
                    ${(question.solutionTextImages || []).map(item => `
                        ${item.image ? `<img src="${item.image}" alt="Solution image" style="max-width: 100%; margin: 10px 0;">` : ''}
                        ${item.text ? `<div style="margin: 10px 0;">${removeImageTextFromPreview(item.text || '')}</div>` : ''}
                    `).join('')}
                </div>
            </div>
            `;
            
            renderContainer.innerHTML = singleQuestionHTML;
            console.log(`Rendered single question: ${question.number} in ${subject}`);
            
            // Re-render MathJax
            if (typeof MathJax !== 'undefined') {
                MathJax.typesetPromise([renderContainer]);
            }
        }
        
        function generateSubjectJSON(subject) {
            console.log(`generateSubjectJSON called for ${subject}`);
            console.log(`Total questions: ${allQuestions.length}`);
            
            // Filter questions for this subject
            const subjectQuestions = allQuestions.filter(q => {
                const assignedSubject = questionAssignments[q.number];
                const detectedSubject = q.subject;
                return assignedSubject === subject || 
                       (detectedSubject && detectedSubject.toLowerCase() === subject.toLowerCase()) ||
                       (subject === 'Mathematics' && (!assignedSubject && !detectedSubject)) ||
                       (subject === 'Physics' && (!assignedSubject && !detectedSubject)) ||
                       (subject === 'Chemistry' && (!assignedSubject && !detectedSubject));
            });
            
            console.log(`Filtered questions for ${subject}: ${subjectQuestions.length}`);
            
            if (subjectQuestions.length === 0) {
                const jsonOutput = document.getElementById(`json-output-${subject}`);
                if (jsonOutput) {
                    jsonOutput.value = 'No questions found.';
                } else {
                    console.error(`JSON output element not found for ${subject}`);
                }
                return;
            }
            
            // Get values from form inputs
            const getFormValue = (fieldId) => {
                const element = document.getElementById(fieldId);
                return element ? element.value : '';
            };
            
            const suffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry';
            const tutorialId = getFormValue(`tutorialId${suffix}`);
            const tutorialTitle = getFormValue(`tutorialTitle${suffix}`);
            const tutorialDescription = getFormValue(`tutorialDescription${suffix}`);
            const authorityExamId = getFormValue(`authorityExamId${suffix}`);
            const state = getFormValue(`state${suffix}`);
            const board = getFormValue(`board${suffix}`);
            const conductedBy = getFormValue(`conductedBy${suffix}`);
            const year = getFormValue(`year${suffix}`);
            const subjectValue = getFormValue(`subject${suffix}`);
            
            // Generate JSON structure in the required format
            const jsonData = [{
                "tutorialId": `JEE_2025_${subject}`,
                "tutorialTitle": `JEE 2025 ${subject}`,
                "tutorialDescription": `JEE 2025 ${subject} Questions with Solutions`,
                "authorityExamId": "jee_main",
                "state": "All India",
                "board": "JEE",
                "conductedBy": "NTA (National Testing Agency)",
                "year": "2025",
                "subject": subject,
                "questions": subjectQuestions.map(question => ({
                    "questionIndex": question.number.toString(),
                    "questionId": `2025${subject.charAt(0)}Q${question.number}`,
                    "questionDetails": [{
                        "text": question.text || "No text",
                        "textImages": [],
                        "possibleAnswers": {
                            "A": {
                                "text": question.options[0]?.replace(/^\(\d+\)\s*/, '').trim() || "",
                                "image": null
                            },
                            "B": {
                                "text": question.options[1]?.replace(/^\(\d+\)\s*/, '').trim() || "",
                                "image": null
                            },
                            "C": {
                                "text": question.options[2]?.replace(/^\(\d+\)\s*/, '').trim() || "",
                                "image": null
                            },
                            "D": {
                                "text": question.options[3]?.replace(/^\(\d+\)\s*/, '').trim() || "",
                                "image": null
                            }
                        },
                        "correctAnswer": question.answer ? String.fromCharCode(64 + parseInt(question.answer)) : "",
                        "correctAnswerText": question.options[parseInt(question.answer) - 1]?.replace(/^\(\d+\)\s*/, '').trim() || ""
                    }]
                }))
            }];
            
            // Display JSON in the main textarea
            const jsonOutput = document.getElementById(`json-output-${subject}`);
            console.log(`JSON output element found:`, jsonOutput);
            
            if (jsonOutput) {
                const jsonString = JSON.stringify(jsonData, null, 2);
                console.log(`JSON string length: ${jsonString.length}`);
                console.log(`JSON content preview:`, jsonString.substring(0, 200));
                jsonOutput.value = jsonString;
                console.log(`JSON set in textarea for ${subject}`);
                
                // Force a visual update
                jsonOutput.style.backgroundColor = '#f0f0f0';
                setTimeout(() => {
                    jsonOutput.style.backgroundColor = '#ffffff';
                }, 100);
            } else {
                console.error(`JSON output element not found for ${subject}`);
            }
            
        }
        
        
        function generateAllJSON() {
            const subjects = ['Mathematics', 'Physics', 'Chemistry'];
            const allJsonData = [];
            
            subjects.forEach(subject => {
                // Get questions assigned to this subject OR detected as this subject
                const subjectQuestions = allQuestions.filter(q => {
                    const assignedSubject = questionAssignments[q.number];
                    const detectedSubject = q.subject;
                    return assignedSubject === subject || 
                           (detectedSubject === subject.toLowerCase() && !assignedSubject) ||
                           (detectedSubject === 'mathematics' && subject === 'Mathematics') ||
                           (detectedSubject === 'physics' && subject === 'Physics') ||
                           (detectedSubject === 'chemistry' && subject === 'Chemistry');
                });
                
                if (subjectQuestions.length > 0) {
                    allJsonData.push({
                        "tutorialId": `JEE_2025_${subject}`,
                        "tutorialTitle": `JEE 2025 ${subject}`,
                        "tutorialDescription": `JEE (Main) 2025 ${subject} Questions`,
                        "authorityExamId": "jee_main",
                        "state": "All India",
                        "board": "JEE",
                        "conductedBy": "NTA (National Testing Agency)",
                        "year": "2025",
                        "subject": subject,
                        "questions": subjectQuestions.map((q, index) => ({
                            "questionIndex": q.number.toString(),
                            "questionId": `2025${subject.charAt(0)}Q${q.number}`,
                            "questionDetails": [{
                                "text": q.text,
                                "textImages": [],
                                "possibleAnswers": q.options.reduce((acc, opt) => {
                                    const letter = String.fromCharCode(64 + parseInt(opt.number));
                                    acc[letter] = { 
                                        "text": opt.text, 
                                        "image": null 
                                    };
                                    return acc;
                                }, {}),
                                "correctAnswer": q.answer ? String.fromCharCode(64 + parseInt(q.answer)) : "",
                                "correctAnswerText": q.options.find(opt => opt.number === q.answer)?.text || ""
                            }]
                        }))
                    });
                }
            });
            
            // Show JSON in a new window
            const jsonWindow = window.open('', '_blank');
            jsonWindow.document.write(`
                <html>
                <head>
                    <title>All Subjects JSON - JEE 2025</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        pre { background: #f5f5f5; padding: 20px; border-radius: 5px; overflow-x: auto; }
                        .header { background: #4facfe; color: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>All Subjects - JEE 2025</h1>
                        <p>Total Subjects: ${allJsonData.length}</p>
                    </div>
                    <pre>${JSON.stringify(allJsonData, null, 2)}</pre>
                </body>
                </html>
            `);
        }
        
        function downloadSubjectJSON(subject) {
            console.log(`Downloading JSON for ${subject}`);
            
            // Filter questions for this subject
            const subjectQuestions = allQuestions.filter(q => q.subject === subject.toLowerCase());
            
            if (subjectQuestions.length === 0) {
                alert(`No questions found for ${subject}. Please assign some questions to this subject first.`);
                return;
            }
            
            // Get metadata values from form inputs
            const getFormValue = (id) => {
                const element = document.getElementById(id);
                return element ? element.value : '';
            };
            
            const suffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry';
            const tutorialId = getFormValue(`tutorialId${suffix}`);
            const tutorialTitle = getFormValue(`tutorialTitle${suffix}`);
            const tutorialDescription = getFormValue(`tutorialDescription${suffix}`);
            const authorityExamId = getFormValue(`authorityExamId${suffix}`);
            const state = getFormValue(`state${suffix}`);
            const board = getFormValue(`board${suffix}`);
            const conductedBy = getFormValue(`conductedBy${suffix}`);
            const year = getFormValue(`year${suffix}`);
            const subjectValue = getFormValue(`subject${suffix}`);
            const dayAndShift = getFormValue(`dayAndShift${suffix}`);
            
            // Generate JSON structure in the specified format
            const jsonData = [
                {
                    "tutorialId": tutorialId || `${board || 'KCET'}_${year || '2025'}_${subject}`,
                    "tutorialTitle": tutorialTitle || `${board || 'KCET'} ${year || '2025'} ${subject}`,
                    "tutorialDescription": tutorialDescription || "",
                    "authorityExamId": authorityExamId || "kar_kect",
                    "state": state || "Karnataka",
                    "board": board || "KCET",
                    "conductedBy": conductedBy || "KEA (Karnataka Examinations Authority)",
                    "year": year || "2025",
                    "subject": subjectValue || subject,
                    "dayAndShift": dayAndShift || "2 April 2025 Shift - 2",
                    "questions": subjectQuestions.map((question, index) => ({
                        "questionIndex": question.number.toString(),
                        "questionId": `2025${subject.charAt(0)}Q${question.number}`,
                        "questionDetails": [
                            {
                                "text": question.text || '',
                                "textImages": question.textImages || [],
                                "possibleAnswers": {
                                    "A": {
                                        "text": question.options && question.options[0] ? question.options[0].replace(/^\(\d+\)\s*/, '').trim() : '',
                                        "image": question.optionImages && question.optionImages[0] ? question.optionImages[0] : null
                                    },
                                    "B": {
                                        "text": question.options && question.options[1] ? question.options[1].replace(/^\(\d+\)\s*/, '').trim() : '',
                                        "image": question.optionImages && question.optionImages[1] ? question.optionImages[1] : null
                                    },
                                    "C": {
                                        "text": question.options && question.options[2] ? question.options[2].replace(/^\(\d+\)\s*/, '').trim() : '',
                                        "image": question.optionImages && question.optionImages[2] ? question.optionImages[2] : null
                                    },
                                    "D": {
                                        "text": question.options && question.options[3] ? question.options[3].replace(/^\(\d+\)\s*/, '').trim() : '',
                                        "image": question.optionImages && question.optionImages[3] ? question.optionImages[3] : null
                                    }
                                },
                                "correctAnswer": question.answer || '',
                                "correctAnswerText": question.options && question.answer && question.options[parseInt(question.answer) - 1] ? 
                                    question.options[parseInt(question.answer) - 1].replace(/^\(\d+\)\s*/, '').trim() : '',
                                "solution": question.solution || '',
                                "solutionTextImages": question.solutionTextImages || [],
                                "type": question.type || "mcq",
                                "metadata": {
                                    "subject": subject.toLowerCase(),
                                    "number": question.number || (index + 1)
                                }
                            }
                        ]
                    }))
                }
            ];
            
                // Create and download the file
                const jsonString = JSON.stringify(jsonData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Generate dynamic filename based on form values including day and shift
                const yearValue = year || '2025';
                const boardValue = board || 'KCET';
                const subjectLower = subject.toLowerCase();
                
                // Parse day and shift from dayAndShift field
                let dayShiftSuffix = '';
                if (dayAndShift) {
                    const dayShiftMatch = dayAndShift.match(/(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})\s+Shift\s*-\s*(\d+)/i);
                    if (dayShiftMatch) {
                        const day = dayShiftMatch[1];
                        const month = dayShiftMatch[2].toLowerCase();
                        const shift = dayShiftMatch[4];
                        dayShiftSuffix = `_${day}_${month}_shift_${shift}`;
                    }
                }
                
                const filename = `${yearValue}_${boardValue.toLowerCase().replace(/\s+/g, '_')}_${subjectLower}${dayShiftSuffix}.json`;
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            
            console.log(`Downloaded JSON for ${subject} with ${subjectQuestions.length} questions`);
        }
        
        async function downloadAllSubjectsJSON() {
            console.log('Downloading JSON for all subjects as ZIP');
            
            const subjects = ['Mathematics', 'Physics', 'Chemistry'];
            
            // Get metadata values from form inputs
            const getFormValue = (id) => {
                const element = document.getElementById(id);
                return element ? element.value : '';
            };
            
            // Get values for folder name (from Mathematics tab)
            const yearValue = getFormValue('year') || '2025';
            const boardValue = getFormValue('board') || 'KCET';
            const dayAndShift = getFormValue('dayAndShift') || '2 April 2025 Shift - 2';
            
            // Parse day and shift to create folder name: JEE_Main_2_April_2025_Shift_2
            let folderName = '';
            if (dayAndShift) {
                const dayShiftMatch = dayAndShift.match(/(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})\s+Shift\s*-\s*(\d+)/i);
                if (dayShiftMatch) {
                    const day = dayShiftMatch[1];
                    const month = dayShiftMatch[2];
                    const year = dayShiftMatch[3];
                    const shift = dayShiftMatch[4];
                    folderName = `${boardValue.replace(/\s+/g, '_')}_${day}_${month}_${year}_Shift_${shift}`;
                } else {
                    folderName = `${boardValue.replace(/\s+/g, '_')}_${yearValue}`;
                }
            } else {
                folderName = `${boardValue.replace(/\s+/g, '_')}_${yearValue}`;
            }
            
            // Create a new JSZip instance
            const zip = new JSZip();
            const folder = zip.folder(folderName);
            
            let fileCount = 0;
            
            subjects.forEach(subject => {
                const subjectQuestions = allQuestions.filter(q => q.subject === subject.toLowerCase());
                
                if (subjectQuestions.length > 0) {
                    const suffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : '-chemistry';
                    const tutorialId = getFormValue(`tutorialId${suffix}`);
                    const tutorialTitle = getFormValue(`tutorialTitle${suffix}`);
                    const tutorialDescription = getFormValue(`tutorialDescription${suffix}`);
                    const authorityExamId = getFormValue(`authorityExamId${suffix}`);
                    const state = getFormValue(`state${suffix}`);
                    const board = getFormValue(`board${suffix}`);
                    const conductedBy = getFormValue(`conductedBy${suffix}`);
                    const year = getFormValue(`year${suffix}`);
                    const subjectValue = getFormValue(`subject${suffix}`);
                    const dayAndShiftValue = getFormValue(`dayAndShift${suffix}`);
                    
                    const jsonData = [{
                        "tutorialId": tutorialId || `${board || 'KCET'}_${year || '2025'}_${subject}`,
                        "tutorialTitle": tutorialTitle || `${board || 'KCET'} ${year || '2025'} ${subject}`,
                        "tutorialDescription": tutorialDescription || "",
                        "authorityExamId": authorityExamId || "kar_kect",
                        "state": state || "Karnataka",
                        "board": board || "KCET",
                        "conductedBy": conductedBy || "KEA (Karnataka Examinations Authority)",
                        "year": year || "2025",
                        "subject": subjectValue || subject,
                        "dayAndShift": dayAndShiftValue || "2 April 2025 Shift - 2",
                        "questions": subjectQuestions.map((question, index) => ({
                            "questionIndex": (index + 1).toString(),
                            "questionId": `2025${subject.charAt(0)}Q${index + 1}`,
                            "questionDetails": [
                                {
                                    "text": question.text || '',
                                    "textImages": question.questionImages || [],
                                    "possibleAnswers": {
                                        "A": {
                                            "text": getOptionText(question, 'A'),
                                            "image": question.optionImages && question.optionImages[0] ? question.optionImages[0] : null
                                        },
                                        "B": {
                                            "text": getOptionText(question, 'B'),
                                            "image": question.optionImages && question.optionImages[1] ? question.optionImages[1] : null
                                        },
                                        "C": {
                                            "text": getOptionText(question, 'C'),
                                            "image": question.optionImages && question.optionImages[2] ? question.optionImages[2] : null
                                        },
                                        "D": {
                                            "text": getOptionText(question, 'D'),
                                            "image": question.optionImages && question.optionImages[3] ? question.optionImages[3] : null
                                        }
                                    },
                                    "correctAnswer": question.answer || '',
                                    "correctAnswerText": getCorrectAnswerText(question),
                                    "solution": question.solution || '',
                                    "solutionTextImages": question.solutionTextImages || [],
                                    "type": question.type || 'mcq',
                                    "metadata": {
                                        "subject": subject.toLowerCase(),
                                        "number": question.number || (index + 1)
                                    }
                                }
                            ]
                        }))
                    }];
                    
                    // Generate filename for this subject
                    let subjectFilename = '';
                    if (dayAndShiftValue) {
                        const dayShiftMatch = dayAndShiftValue.match(/(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})\s+Shift\s*-\s*(\d+)/i);
                        if (dayShiftMatch) {
                            const day = dayShiftMatch[1];
                            const month = dayShiftMatch[2].toLowerCase();
                            const shift = dayShiftMatch[4];
                            subjectFilename = `${year}_${board.toLowerCase().replace(/\s+/g, '_')}_${subject.toLowerCase()}_${day}_${month}_shift_${shift}.json`;
                        } else {
                            subjectFilename = `${year}_${board.toLowerCase().replace(/\s+/g, '_')}_${subject.toLowerCase()}.json`;
                        }
                    } else {
                        subjectFilename = `${year}_${board.toLowerCase().replace(/\s+/g, '_')}_${subject.toLowerCase()}.json`;
                    }
                    
                    // Add file to ZIP
                    const jsonString = JSON.stringify(jsonData, null, 2);
                    folder.file(subjectFilename, jsonString);
                    fileCount++;
                }
            });
            
            if (fileCount === 0) {
                alert('No questions found for any subject. Please assign some questions first.');
                return;
            }
            
            // Generate and download ZIP file
            try {
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                saveAs(zipBlob, `${folderName}.zip`);
                console.log(`Downloaded ZIP with ${fileCount} JSON files in folder: ${folderName}`);
            } catch (error) {
                console.error('Error generating ZIP:', error);
                alert('Error creating ZIP file. Please try again.');
            }
        }
        
        // Image Upload Functions
        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }
        
        function handleDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }
        
        function handleImageDrop(event, questionNumber, type, optionIndex = null) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                if (type === 'option' && optionIndex !== null) {
                    handleOptionImageUpload({ target: { files: [files[0]] } }, questionNumber, optionIndex);
                } else if (type === 'question') {
                    handleQuestionImageUpload({ target: { files: files } }, questionNumber);
                } else if (type === 'solution') {
                    handleSolutionImageUpload({ target: { files: files } }, questionNumber);
                }
            }
        }
        
        // Content row management functions for textImages (Questions)
        let currentUploadRowIndex = null;
        let currentUploadQuestionNumber = null;
        
        // Solution text images management
        let currentSolutionUploadRowIndex = null;
        let currentSolutionUploadQuestionNumber = null;
        
        function addTextImageRow(questionNumber) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question) return;
            
            if (!question.textImages) {
                question.textImages = [];
            }
            
            // Add new empty row to textImages array
            question.textImages.push({ text: '', image: null });
            
            // Refresh the UI
            refreshTextImageRows(questionNumber);
        }
        
        function removeTextImageRow(questionNumber, rowIndex) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question || !question.textImages) return;
            
            const item = question.textImages[rowIndex];
            
            // Delete image from Firebase if exists
            if (item.image) {
                deleteImageFromFirebase(item.image).then(() => {
                    console.log('Image deleted from Firebase:', item.image);
                }).catch(error => {
                    console.error('Error deleting image:', error);
                });
            }
            
            // Remove from textImages array
            question.textImages.splice(rowIndex, 1);
            
            // Refresh the UI
            refreshTextImageRows(questionNumber);
            
            // Update live preview and JSON
            updateLivePreview();
            const currentSubject = getCurrentSubject();
            if (currentSubject) {
                displaySubjectJSON(currentSubject);
            }
        }
        
        function updateTextImageRow(questionNumber, rowIndex, field, value) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question || !question.textImages) return;
            
            // Auto-save: Update textImages array immediately
            question.textImages[rowIndex][field] = value;
            
            // Update live preview and JSON
            updateLivePreview();
            const currentSubject = getCurrentSubject();
            if (currentSubject) {
                displaySubjectJSON(currentSubject);
            }
        }
        
        function deleteImageFromFirebase(imageUrl) {
            return new Promise((resolve, reject) => {
                try {
                    // Extract the path from the Firebase URL
                    const decodedUrl = decodeURIComponent(imageUrl);
                    const pathMatch = decodedUrl.match(/\/o\/(.+?)\?/);
                    
                    if (!pathMatch) {
                        reject(new Error('Could not extract path from URL'));
                        return;
                    }
                    
                    const imagePath = pathMatch[1];
                    const imageRef = ref(storage, imagePath);
                    
                    deleteObject(imageRef)
                        .then(() => resolve())
                        .catch(error => reject(error));
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // Solution TextImages Functions
        function addSolutionTextImageRow(questionNumber) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question) return;
            
            if (!question.solutionTextImages) {
                question.solutionTextImages = [];
            }
            
            // Add new empty row to solutionTextImages array
            question.solutionTextImages.push({ text: '', image: null });
            
            // Refresh the UI
            refreshSolutionTextImageRows(questionNumber);
        }
        
        function removeSolutionTextImageRow(questionNumber, rowIndex) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question || !question.solutionTextImages) return;
            
            const item = question.solutionTextImages[rowIndex];
            
            // Delete image from Firebase if exists
            if (item.image) {
                deleteImageFromFirebase(item.image).then(() => {
                    console.log('Solution image deleted from Firebase:', item.image);
                }).catch(error => {
                    console.error('Error deleting solution image:', error);
                });
            }
            
            // Remove from solutionTextImages array
            question.solutionTextImages.splice(rowIndex, 1);
            
            // Refresh the UI
            refreshSolutionTextImageRows(questionNumber);
            
            // Update live preview and JSON
            updateLivePreview();
            const currentSubject = getCurrentSubject();
            if (currentSubject) {
                displaySubjectJSON(currentSubject);
            }
        }
        
        function updateSolutionTextImageRow(questionNumber, rowIndex, field, value) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question || !question.solutionTextImages) return;
            
            // Auto-save: Update solutionTextImages array immediately
            question.solutionTextImages[rowIndex][field] = value;
            
            // Update live preview and JSON
            updateLivePreview();
            const currentSubject = getCurrentSubject();
            if (currentSubject) {
                displaySubjectJSON(currentSubject);
            }
        }
        
        function uploadSolutionImageForRow(questionNumber, rowIndex) {
            currentSolutionUploadRowIndex = rowIndex;
            currentSolutionUploadQuestionNumber = questionNumber;
            document.getElementById(`solution-image-upload-${questionNumber}`).click();
        }
        
        function handleSolutionRowImageDrop(event, questionNumber, rowIndex) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.style.background = '#f8f9fa';
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                currentSolutionUploadRowIndex = rowIndex;
                currentSolutionUploadQuestionNumber = questionNumber;
                handleSolutionRowImageUpload({ target: { files: [files[0]] } }, questionNumber);
            }
        }
        
        function handleSolutionRowImageUpload(event, questionNumber) {
            const file = event.target.files[0];
            if (!file) return;
            
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question) return;
            
            const rowIndex = currentSolutionUploadRowIndex;
            
            // Initialize solutionTextImages if not exists
            if (!question.solutionTextImages) {
                question.solutionTextImages = [];
            }
            
            // Show loading state
            const container = document.getElementById(`solution-content-rows-${questionNumber}`);
            const rowElement = container.querySelector(`[data-row-index="${rowIndex}"]`);
            
            if (rowElement) {
                const uploadDiv = rowElement.querySelector('div[style*="flex: 1"]');
                if (uploadDiv) {
                    uploadDiv.innerHTML = `
                        <div style="text-align: center; color: #6c757d;">
                            <div class="upload-status uploading">Uploading...</div>
                        </div>
                    `;
                }
            }
            
            // Get the current active subject from tab
            let currentSubject = getCurrentSubject();
            
            // If getCurrentSubject() fails, determine from question number
            if (!currentSubject) {
                if (questionNumber >= 1 && questionNumber <= 25) {
                    currentSubject = 'Mathematics';
                } else if (questionNumber >= 26 && questionNumber <= 50) {
                    currentSubject = 'Physics';
                } else if (questionNumber >= 51 && questionNumber <= 75) {
                    currentSubject = 'Chemistry';
                }
            }
            
            const year = '2025';
            const suffix = `_SR${rowIndex}`;
            
            console.log('=== SOLUTION IMAGE UPLOAD DEBUG ===');
            console.log('Current Subject (from tab/question):', currentSubject);
            console.log('Question Number:', questionNumber);
            console.log('Question subject property:', question.subject);
            console.log('Solution Row Index:', rowIndex);
            
            // Generate custom filename using tutorial ID format
            const tutorialId = getTutorialIdForUpload(currentSubject);
            console.log('Tutorial ID for subject', currentSubject, ':', tutorialId);
            
            // Debug: Check what the actual tutorial ID fields contain
            const mathId = document.getElementById('tutorialId')?.value;
            const physicsId = document.getElementById('tutorialId-physics')?.value;
            const chemId = document.getElementById('tutorialId-chemistry')?.value;
            console.log('All Tutorial IDs - Math:', mathId, 'Physics:', physicsId, 'Chemistry:', chemId);
            
            const customFileName = `${tutorialId}_Q${questionNumber}_sol_${rowIndex + 1}`;
            console.log('Uploading solution with filename:', customFileName);
            
            uploadImageToFirebase(
                file, 
                currentSubject, 
                year, 
                questionNumber - 1, 
                suffix, 
                (percent) => {
                    console.log('Solution upload progress:', percent);
                    if (rowElement) {
                        const uploadDiv = rowElement.querySelector('div[style*="flex: 1"]');
                        if (uploadDiv) {
                            uploadDiv.innerHTML = `
                                <div style="text-align: center; color: #6c757d;">
                                    <div class="upload-status uploading">Uploading... ${percent}%</div>
                                </div>
                            `;
                        }
                    }
                }, 
                customFileName
            ).then(url => {
                console.log('Solution upload successful:', url);
                // Auto-save: Update solutionTextImages array with the image URL
                if (!question.solutionTextImages[rowIndex]) {
                    question.solutionTextImages[rowIndex] = { text: '', image: null };
                }
                question.solutionTextImages[rowIndex].image = url;
                
                // Refresh UI
                refreshSolutionTextImageRows(questionNumber);
                
                // Update live preview and JSON
                updateLivePreview();
                const currentSubject = getCurrentSubject();
                if (currentSubject) {
                    displaySubjectJSON(currentSubject);
                }
            }).catch(error => {
                console.error('Solution upload failed:', error);
                alert('Solution image upload failed: ' + error.message);
                refreshSolutionTextImageRows(questionNumber);
            });
            
            event.target.value = '';
        }
        
        function refreshSolutionTextImageRows(questionNumber) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question) return;
            
            const container = document.getElementById(`solution-content-rows-${questionNumber}`);
            if (!container) return;
            
            container.innerHTML = (question.solutionTextImages || []).map((item, idx) => `
                <div class="content-row" data-row-index="${idx}" style="display: flex; gap: 10px; align-items: stretch;">
                    ${item.image ? `
                        <div style="flex: 1; min-height: 100px; border: 2px dashed #ccc; border-radius: 8px; padding: 8px; display: flex; align-items: center; justify-content: center; position: relative;">
                            <img src="${item.image}" alt="Solution image" style="max-width: 100%; max-height: 120px; border-radius: 4px;" onload="checkAndMarkUploadedImage(this)">
                            ${item.image && item.image.includes('firebasestorage.googleapis.com') ? '<div class="upload-checkmark">‚úÖ</div>' : (item.uploadFailed ? `<div class="upload-error" title="${item.uploadError || 'Upload failed'}">‚ùå</div>` : '')}
                        </div>
                    ` : `
                        <div style="flex: 1; min-height: 100px; border: 2px dashed #ccc; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; background: #f8f9fa;" 
                             onclick="uploadSolutionImageForRow(${questionNumber}, ${idx})"
                             ondrop="handleSolutionRowImageDrop(event, ${questionNumber}, ${idx})"
                             ondragover="event.preventDefault(); event.currentTarget.style.background='#e3f2fd';"
                             ondragleave="event.currentTarget.style.background='#f8f9fa';">
                            <div style="text-align: center; color: #6c757d;">
                                <div style="font-size: 32px;">üì∑</div>
                                <div style="font-size: 14px; margin-top: 8px;">Click or drag image here</div>
                            </div>
                        </div>
                    `}
                    <textarea 
                        placeholder="Enter text..."
                        oninput="updateSolutionTextImageRow(${questionNumber}, ${idx}, 'text', this.value)"
                        style="flex: 1; min-height: 100px; padding: 12px; border: 2px solid #ccc; border-radius: 8px; resize: vertical; font-family: inherit;">${item.text || ''}</textarea>
                    <button onclick="removeSolutionTextImageRow(${questionNumber}, ${idx})" 
                            style="background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 18px; height: 40px; width: 40px;" 
                            title="Remove row">‚àí</button>
                </div>
            `).join('');
            
            // Scan for checkmarks after rendering
            setTimeout(() => {
                scanAndMarkImages(container);
            }, 100);
        }
        
        function uploadImageForRow(questionNumber, rowIndex) {
            currentUploadRowIndex = rowIndex;
            currentUploadQuestionNumber = questionNumber;
            document.getElementById(`image-upload-${questionNumber}`).click();
        }
        
        function handleRowImageDrop(event, questionNumber, rowIndex) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.style.background = '#f8f9fa';
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                currentUploadRowIndex = rowIndex;
                currentUploadQuestionNumber = questionNumber;
                handleRowImageUpload({ target: { files: [files[0]] } }, questionNumber);
            }
        }
        
        function handleRowImageUpload(event, questionNumber) {
            const file = event.target.files[0];
            if (!file) return;
            
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question) return;
            
            const rowIndex = currentUploadRowIndex;
            
            // Initialize textImages if not exists
            if (!question.textImages) {
                question.textImages = [];
            }
            
            // Show loading state
            const container = document.getElementById(`question-content-rows-${questionNumber}`);
            const rowElement = container.querySelector(`[data-row-index="${rowIndex}"]`);
            
            if (rowElement) {
                const uploadDiv = rowElement.querySelector('div[style*="flex: 1"]');
                if (uploadDiv) {
                    uploadDiv.innerHTML = `
                        <div style="text-align: center; color: #6c757d;">
                            <div class="upload-status uploading">Uploading...</div>
                        </div>
                    `;
                }
            }
            
            // Get the current active subject from tab
            let currentSubject = getCurrentSubject();
            
            // If getCurrentSubject() fails, determine from question number
            if (!currentSubject) {
                if (questionNumber >= 1 && questionNumber <= 25) {
                    currentSubject = 'Mathematics';
                } else if (questionNumber >= 26 && questionNumber <= 50) {
                    currentSubject = 'Physics';
                } else if (questionNumber >= 51 && questionNumber <= 75) {
                    currentSubject = 'Chemistry';
                }
            }
            
            const year = '2025';
            const suffix = `_QR${rowIndex}`;
            
            console.log('=== QUESTION IMAGE UPLOAD DEBUG ===');
            console.log('Current Subject (from tab/question):', currentSubject);
            console.log('Question Number:', questionNumber);
            console.log('Row Index:', rowIndex);
            
            // Generate custom filename using tutorial ID format
            const tutorialId = getTutorialIdForUpload(currentSubject);
            console.log('Tutorial ID for subject', currentSubject, ':', tutorialId);
            
            // Debug: Check what the actual tutorial ID fields contain
            const mathId = document.getElementById('tutorialId')?.value;
            const physicsId = document.getElementById('tutorialId-physics')?.value;
            const chemId = document.getElementById('tutorialId-chemistry')?.value;
            console.log('All Tutorial IDs - Math:', mathId, 'Physics:', physicsId, 'Chemistry:', chemId);
            
            const customFileName = `${tutorialId}_Q${questionNumber}_image${rowIndex}`;
            console.log('Uploading with filename:', customFileName);
            
            uploadImageToFirebase(
                file, 
                currentSubject, 
                year, 
                questionNumber - 1, 
                suffix, 
                (percent) => {
                    console.log('Upload progress:', percent);
                    if (rowElement) {
                        const uploadDiv = rowElement.querySelector('div[style*="flex: 1"]');
                        if (uploadDiv) {
                            uploadDiv.innerHTML = `
                                <div style="text-align: center; color: #6c757d;">
                                    <div class="upload-status uploading">Uploading... ${percent}%</div>
                                </div>
                            `;
                        }
                    }
                }, 
                customFileName
            ).then(url => {
                console.log('Upload successful:', url);
                // Auto-save: Update textImages array with the image URL
                if (!question.textImages[rowIndex]) {
                    question.textImages[rowIndex] = { text: '', image: null };
                }
                question.textImages[rowIndex].image = url;
                
                // Refresh UI
                refreshTextImageRows(questionNumber);
                
                // Update live preview and JSON
                updateLivePreview();
                const currentSubject = getCurrentSubject();
                if (currentSubject) {
                    displaySubjectJSON(currentSubject);
                }
            }).catch(error => {
                console.error('Upload failed:', error);
                alert('Image upload failed: ' + error.message);
                refreshTextImageRows(questionNumber);
            });
            
            event.target.value = '';
        }
        
        function refreshTextImageRows(questionNumber) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question) return;
            
            const container = document.getElementById(`question-content-rows-${questionNumber}`);
            if (!container) return;
            
            container.innerHTML = (question.textImages || []).map((item, idx) => `
                <div class="content-row" data-row-index="${idx}" style="display: flex; gap: 10px; align-items: stretch;">
                    ${item.image ? `
                        <div style="flex: 1; min-height: 100px; border: 2px dashed #ccc; border-radius: 8px; padding: 8px; display: flex; align-items: center; justify-content: center; position: relative;">
                            <img src="${item.image}" alt="Question image" style="max-width: 100%; max-height: 120px; border-radius: 4px;" onload="checkAndMarkUploadedImage(this)">
                            ${item.image && item.image.includes('firebasestorage.googleapis.com') ? '<div class="upload-checkmark">‚úÖ</div>' : (item.uploadFailed ? `<div class="upload-error" title="${item.uploadError || 'Upload failed'}">‚ùå</div>` : '')}
                        </div>
                    ` : `
                        <div style="flex: 1; min-height: 100px; border: 2px dashed #ccc; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; background: #f8f9fa;" 
                             onclick="uploadImageForRow(${questionNumber}, ${idx})"
                             ondrop="handleRowImageDrop(event, ${questionNumber}, ${idx})"
                             ondragover="event.preventDefault(); event.currentTarget.style.background='#e3f2fd';"
                             ondragleave="event.currentTarget.style.background='#f8f9fa';">
                            <div style="text-align: center; color: #6c757d;">
                                <div style="font-size: 32px;">üì∑</div>
                                <div style="font-size: 14px; margin-top: 8px;">Click or drag image here</div>
                            </div>
                        </div>
                    `}
                    <textarea 
                        placeholder="Enter text..."
                        oninput="updateTextImageRow(${questionNumber}, ${idx}, 'text', this.value)"
                        style="flex: 1; min-height: 100px; padding: 12px; border: 2px solid #ccc; border-radius: 8px; resize: vertical; font-family: inherit;">${item.text || ''}</textarea>
                    <button onclick="removeTextImageRow(${questionNumber}, ${idx})" 
                            style="background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 18px; height: 40px; width: 40px;" 
                            title="Remove row">‚àí</button>
                </div>
            `).join('');
            
            // Scan for checkmarks after rendering
            setTimeout(() => {
                scanAndMarkImages(container);
            }, 100);
        }
        
        // Update image text description
        function updateImageText(questionNumber, imageType, imageIndex, text) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (!question) return;
            
            if (imageType === 'question') {
                if (!question.questionImageTexts) {
                    question.questionImageTexts = [];
                }
                question.questionImageTexts[imageIndex] = text;
            } else if (imageType === 'solution') {
                if (!question.solutionImageTexts) {
                    question.solutionImageTexts = [];
                }
                question.solutionImageTexts[imageIndex] = text;
            }
            
            // Update JSON display
            const currentSubject = getCurrentSubject();
            if (currentSubject) {
                displaySubjectJSON(currentSubject);
            }
        }
        
        function handleQuestionImageUpload(event, questionNumber) {
            const files = event.target.files;
            const container = document.getElementById(`question-images-${questionNumber}`);
            const question = allQuestions.find(q => q.number === questionNumber);
            
            if (!question) {
                console.error('Question not found:', questionNumber);
                return;
            }
            
            // Initialize questionImages array if it doesn't exist
            if (!question.questionImages) {
                question.questionImages = [];
            }
            
            Array.from(files).forEach((file, fileIndex) => {
                if (file.type.startsWith('image/')) {
                    const imgIndex = question.questionImages.length;
                    const suffix = `_Q${imgIndex + 1}`;
                    
                    // Create progress container
                    const progressContainer = document.createElement('div');
                    progressContainer.className = 'upload-progress';
                    progressContainer.innerHTML = `
                        <div class="progress-bar">
                            <div class="progress-fill"></div>
                        </div>
                        <div class="progress-text">0%</div>
                        <div class="upload-status uploading">Uploading...</div>
                    `;
                    container.appendChild(progressContainer);
                    
                    const progressFill = progressContainer.querySelector('.progress-fill');
                    const progressText = progressContainer.querySelector('.progress-text');
                    const uploadStatus = progressContainer.querySelector('.upload-status');
                    
                    // Get current subject and year for Firebase path
                    const currentSubject = getCurrentSubject();
                    const year = '2025';
                    
                    // Generate custom filename using tutorial ID format
                    const tutorialId = getTutorialIdForUpload(currentSubject);
                    const customFileName = `${tutorialId}_Q${questionNumber}_image${imgIndex}`;
                    
                    // Upload to Firebase with custom filename
                    uploadImageToFirebase(file, currentSubject, year, questionNumber - 1, suffix, (percent) => {
                        progressFill.style.width = percent + '%';
                        progressText.textContent = percent + '%';
                    }, customFileName).then(url => {
                        // Upload successful
                        uploadStatus.textContent = '‚úÖ Uploaded';
                        uploadStatus.className = 'upload-status success';
                        
                        // Create image display with text input
                        const imageDiv = document.createElement('div');
                        imageDiv.className = 'uploaded-image-with-text';
                        imageDiv.innerHTML = `
                            <div class="uploaded-image">
                                <img src="${url}" alt="Question Image">
                                <button class="remove-image" onclick="removeImage(${questionNumber}, 'question', this, ${imgIndex})">√ó</button>
                            </div>
                            <input type="text" 
                                   class="image-text-input" 
                                   placeholder="Image description (e.g., diagram of 2px orbital)"
                                   oninput="updateImageText(${questionNumber}, 'question', ${imgIndex}, this.value)"
                                   style="width: 100%; padding: 8px; margin-top: 8px; border: 1px solid #ccc; border-radius: 4px;">
                        `;
                        
                        // Replace progress with image
                        progressContainer.replaceWith(imageDiv);
                        
                        // Store Firebase URL in question object
                        question.questionImages.push(url);
                        
                        // Initialize questionImageTexts array if needed
                        if (!question.questionImageTexts) {
                            question.questionImageTexts = [];
                        }
                        question.questionImageTexts.push('');
                        
                        // Update Live Preview
                        updateLivePreview();
                        
                    }).catch(error => {
                        console.error('Upload failed:', error);
                        uploadStatus.textContent = '‚ùå Upload failed';
                        uploadStatus.className = 'upload-status error';
                    });
                }
            });
            
            // Reset file input
            event.target.value = '';
        }
        
        function handleOptionImageUpload(event, questionNumber, optionIndex) {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const container = document.getElementById(`option-images-${questionNumber}-${optionIndex}`);
                const question = allQuestions.find(q => q.number === questionNumber);
                
                if (!question) {
                    console.error('Question not found:', questionNumber);
                    return;
                }
                
                // Clear existing image for this option
                container.innerHTML = '';
                
                // Create progress container
                const progressContainer = document.createElement('div');
                progressContainer.className = 'upload-progress';
                progressContainer.innerHTML = `
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                    </div>
                    <div class="progress-text">0%</div>
                    <div class="upload-status uploading">Uploading...</div>
                `;
                container.appendChild(progressContainer);
                
                const progressFill = progressContainer.querySelector('.progress-fill');
                const progressText = progressContainer.querySelector('.progress-text');
                const uploadStatus = progressContainer.querySelector('.upload-status');
                
                // Get current subject and year for Firebase path
                const currentSubject = getCurrentSubject();
                const year = '2025';
                const suffix = `_op${optionIndex + 1}`;
                
                // Generate custom filename using tutorial ID format
                const tutorialId = getTutorialIdForUpload(currentSubject);
                const customFileName = `${tutorialId}_Q${questionNumber}_op${optionIndex + 1}`;
                
                // Upload to Firebase with custom filename
                uploadImageToFirebase(file, currentSubject, year, questionNumber - 1, suffix, (percent) => {
                    progressFill.style.width = percent + '%';
                    progressText.textContent = percent + '%';
                }, customFileName).then(url => {
                    // Upload successful
                    uploadStatus.textContent = '‚úÖ Uploaded';
                    uploadStatus.className = 'upload-status success';
                    
                    // Create image display
                    const imageDiv = document.createElement('div');
                    imageDiv.className = 'uploaded-image';
                    imageDiv.innerHTML = `
                        <img src="${url}" alt="Option Image">
                        <button class="remove-image" onclick="removeImage(${questionNumber}, 'option', this, ${optionIndex})">√ó</button>
                    `;
                    
                    // Replace progress with image
                    progressContainer.replaceWith(imageDiv);
                    
                    // Store Firebase URL in question object as array of objects (format: [{image: url, text: ''}])
                    if (!question.optionImages) {
                        question.optionImages = [[], [], [], []];
                    }
                    question.optionImages[optionIndex] = [{ image: url, text: '' }];
                    
                    // Update Live Preview
                    updateLivePreview();
                    
                }).catch(error => {
                    console.error('Upload failed:', error);
                    uploadStatus.textContent = '‚ùå Upload failed';
                    uploadStatus.className = 'upload-status error';
                });
            }
        }
        
        function handleSolutionImageUpload(event, questionNumber) {
            const files = event.target.files;
            const container = document.getElementById(`solution-images-${questionNumber}`);
            const question = allQuestions.find(q => q.number === questionNumber);
            
            if (!question) {
                console.error('Question not found:', questionNumber);
                return;
            }
            
            // Initialize solutionImages array if it doesn't exist
            if (!question.solutionImages) {
                question.solutionImages = [];
            }
            
            Array.from(files).forEach((file, fileIndex) => {
                if (file.type.startsWith('image/')) {
                    const imgIndex = question.solutionImages.length;
                    const suffix = `_S${imgIndex + 1}`;
                    
                    // Create progress container
                    const progressContainer = document.createElement('div');
                    progressContainer.className = 'upload-progress';
                    progressContainer.innerHTML = `
                        <div class="progress-bar">
                            <div class="progress-fill"></div>
                        </div>
                        <div class="progress-text">0%</div>
                        <div class="upload-status uploading">Uploading...</div>
                    `;
                    container.appendChild(progressContainer);
                    
                    const progressFill = progressContainer.querySelector('.progress-fill');
                    const progressText = progressContainer.querySelector('.progress-text');
                    const uploadStatus = progressContainer.querySelector('.upload-status');
                    
                    // Get current subject and year for Firebase path
                    const currentSubject = getCurrentSubject();
                    const year = '2025';
                    
                    // Generate custom filename using tutorial ID format
                    const tutorialId = getTutorialIdForUpload(currentSubject);
                    const customFileName = `${tutorialId}_Q${questionNumber}_sol_${imgIndex + 1}`;
                    
                    // Upload to Firebase with custom filename
                    uploadImageToFirebase(file, currentSubject, year, questionNumber - 1, suffix, (percent) => {
                        progressFill.style.width = percent + '%';
                        progressText.textContent = percent + '%';
                    }, customFileName).then(url => {
                        // Upload successful
                        uploadStatus.textContent = '‚úÖ Uploaded';
                        uploadStatus.className = 'upload-status success';
                        
                        // Create image display with text input
                        const imageDiv = document.createElement('div');
                        imageDiv.className = 'uploaded-image-with-text';
                        imageDiv.innerHTML = `
                            <div class="uploaded-image">
                                <img src="${url}" alt="Solution Image">
                                <button class="remove-image" onclick="removeImage(${questionNumber}, 'solution', this, ${imgIndex})">√ó</button>
                            </div>
                            <input type="text" 
                                   class="image-text-input" 
                                   placeholder="Image description"
                                   oninput="updateImageText(${questionNumber}, 'solution', ${imgIndex}, this.value)"
                                   style="width: 100%; padding: 8px; margin-top: 8px; border: 1px solid #ccc; border-radius: 4px;">
                        `;
                        
                        // Replace progress with image
                        progressContainer.replaceWith(imageDiv);
                        
                        // Store Firebase URL in question object
                        question.solutionImages.push(url);
                        
                        // Initialize solutionImageTexts array if needed
                        if (!question.solutionImageTexts) {
                            question.solutionImageTexts = [];
                        }
                        question.solutionImageTexts.push('');
                        
                        // Update Live Preview
                        updateLivePreview();
                        
                    }).catch(error => {
                        console.error('Upload failed:', error);
                        uploadStatus.textContent = '‚ùå Upload failed';
                        uploadStatus.className = 'upload-status error';
                    });
                }
            });
            
            // Reset file input
            event.target.value = '';
        }
        
        // Prevent default drag and drop behavior on the entire page
        document.addEventListener('dragover', function(e) {
            e.preventDefault();
        });
        
        document.addEventListener('drop', function(e) {
            e.preventDefault();
        });

        function removeImage(questionNumber, type, buttonElement, imageIndex = null) {
            if (!confirm('Are you sure you want to remove this image?')) {
                return;
            }
            
            const imageDiv = buttonElement.parentElement;
            const question = allQuestions.find(q => q.number === questionNumber);
            
            if (!question) {
                console.error('Question not found:', questionNumber);
                return;
            }
            
            // Get the image URL for Firebase deletion
            const imgElement = imageDiv.querySelector('img');
            const imageUrl = imgElement ? imgElement.src : null;
            
            // Remove from Firebase if it's a Firebase URL
            if (imageUrl && imageUrl.includes('firebasestorage.googleapis.com')) {
                const { storage, ref, deleteObject } = window.firebaseStorage;
                if (storage && ref && deleteObject) {
                    // Extract the file path from the URL
                    const urlParts = imageUrl.split('/');
                    const fileName = urlParts[urlParts.length - 1].split('?')[0];
                    const currentSubject = getCurrentSubject();
                    const year = '2025';
                    const storagePath = `questions/${currentSubject}/${year}/${fileName}`;
                    
                    const storageRef = ref(storage, storagePath);
                    deleteObject(storageRef).catch(error => {
                        console.error('Failed to delete from Firebase:', error);
                    });
                }
            }
            
            // Remove from DOM
            imageDiv.remove();
            
            // Remove from question object
            if (type === 'question' && question.questionImages) {
                if (imageIndex !== null && imageIndex >= 0) {
                    question.questionImages.splice(imageIndex, 1);
                } else {
                    // Fallback: find by URL
                    const index = question.questionImages.findIndex(url => url === imageUrl);
                    if (index > -1) {
                        question.questionImages.splice(index, 1);
                    }
                }
            } else if (type === 'option' && question.optionImages && imageIndex !== null) {
                // Clear the option image array (format: array of objects)
                if (!question.optionImages) {
                    question.optionImages = [[], [], [], []];
                }
                question.optionImages[imageIndex] = [];
            } else if (type === 'solution' && question.solutionImages) {
                if (imageIndex !== null && imageIndex >= 0) {
                    question.solutionImages.splice(imageIndex, 1);
                } else {
                    // Fallback: find by URL
                    const index = question.solutionImages.findIndex(url => url === imageUrl);
                    if (index > -1) {
                        question.solutionImages.splice(index, 1);
                    }
                }
            }
            
            // Update Live Preview
            updateLivePreview();
        }
        
        // Remove option image specifically
        function removeOptionImage(questionNumber, optionIndex) {
            if (!confirm('Are you sure you want to remove this option image?')) {
                return;
            }
            
            const question = allQuestions.find(q => q.number === questionNumber);
            
            if (!question) {
                console.error('Question not found:', questionNumber);
                return;
            }
            
            // Initialize optionImages array if it doesn't exist
            if (!question.optionImages) {
                question.optionImages = [[], [], [], []];
            }
            
            // Get the image container
            const imageContainer = document.getElementById(`option-images-${questionNumber}-${optionIndex}`);
            
            // Remove from Firebase if it's a Firebase URL
            if (question.optionImages[optionIndex] && question.optionImages[optionIndex].length > 0) {
                const imgObj = question.optionImages[optionIndex][0];
                const imageUrl = (typeof imgObj === 'object' && imgObj.image) ? imgObj.image : imgObj;
                
                if (imageUrl && imageUrl.includes('firebasestorage.googleapis.com')) {
                    const { storage, ref, deleteObject } = window.firebaseStorage;
                    if (storage && ref && deleteObject) {
                        const urlParts = imageUrl.split('/');
                        const fileName = urlParts[urlParts.length - 1].split('?')[0];
                        const currentSubject = getCurrentSubject();
                        const year = '2025';
                        const storagePath = `questions/${currentSubject}/${year}/${fileName}`;
                        
                        const storageRef = ref(storage, storagePath);
                        deleteObject(storageRef).catch(error => {
                            console.error('Failed to delete from Firebase:', error);
                        });
                    }
                }
            }
            
            // Clear the option image array
            question.optionImages[optionIndex] = [];
            
            // Update the UI - replace with "Add Image" button
            if (imageContainer) {
                const optionImageUpload = imageContainer.closest('.option-image-upload');
                if (optionImageUpload) {
                    optionImageUpload.innerHTML = `
                        <div class="image-upload-area" 
                             data-question="${questionNumber}" 
                             data-option="${optionIndex}"
                             data-type="option"
                             onclick="document.getElementById('option-image-input-${questionNumber}-${optionIndex}').click()"
                             ondrop="handleImageDrop(event, ${questionNumber}, 'option', ${optionIndex})"
                             ondragover="handleDragOver(event)"
                             ondragleave="handleDragLeave(event)">
                            <div class="image-upload-icon">üì∑</div>
                            <div class="image-upload-text">Click or drag image</div>
                            <div class="image-upload-hint">Single image for option</div>
                        </div>
                        <input type="file" id="option-image-input-${questionNumber}-${optionIndex}" 
                               style="display: none;" 
                               accept="image/*"
                               onchange="handleOptionImageUpload(event, ${questionNumber}, ${optionIndex})">
                        <div class="uploaded-images" id="option-images-${questionNumber}-${optionIndex}">
                        </div>
                    `;
                    // Add a collapse button
                    const addBtn = document.createElement('button');
                    addBtn.type = 'button';
                    addBtn.style.cssText = 'margin-top: 10px; background: #10b981; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 16px; align-self: flex-start; width: fit-content;';
                    addBtn.className = `add-image-btn-${questionNumber}-${optionIndex}`;
                    addBtn.textContent = '+ Add Image (Optional)';
                    addBtn.onclick = function() {
                        optionImageUpload.style.display = 'block';
                        this.style.display = 'none';
                    };
                    optionImageUpload.style.display = 'none';
                    optionImageUpload.parentElement.appendChild(addBtn);
                }
            }
            
            // Update Live Preview
            if (typeof updateLivePreview === 'function') {
                updateLivePreview();
            }
            
            // Refresh the display if needed
            if (typeof refreshInlineRender === 'function') {
                refreshInlineRender();
            }
        }
        
        // Initialize metadata editors for all subjects
        function initializeMetadataEditors() {
            const subjects = ['', '-physics', '-chemistry'];
            
            subjects.forEach(suffix => {
                const stateSelect = document.getElementById(`state${suffix}`);
                const boardSelect = document.getElementById(`board${suffix}`);
                const yearSelect = document.getElementById(`year${suffix}`);
                const subjectSelect = document.getElementById(`subject${suffix}`);
                const tutorialTitleInput = document.getElementById(`tutorialTitle${suffix}`);
                const authorityExamIdInput = document.getElementById(`authorityExamId${suffix}`);
                
                if (stateSelect && boardSelect && yearSelect && subjectSelect) {
                    // Function to toggle Day and Shift visibility based on board (available globally)
                    if (typeof window.toggleDayAndShiftVisibility === 'undefined') {
                        window.toggleDayAndShiftVisibility = function(boardValue) {
                            const isJEEMain = boardValue && (
                                boardValue.toLowerCase().includes('jee') && 
                                boardValue.toLowerCase().includes('main')
                            );
                            
                            // Get all Day and Shift fields and their parent field containers
                            const dayShiftFields = [
                                { field: document.getElementById('dayAndShift'), container: document.getElementById('dayAndShift')?.closest('.field') },
                                { field: document.getElementById('dayAndShift-physics'), container: document.getElementById('dayAndShift-physics')?.closest('.field') },
                                { field: document.getElementById('dayAndShift-chemistry'), container: document.getElementById('dayAndShift-chemistry')?.closest('.field') },
                                { field: document.getElementById('dayAndShift-biology'), container: document.getElementById('dayAndShift-biology')?.closest('.field') }
                            ];
                            
                            dayShiftFields.forEach(({ field, container }) => {
                                if (container) {
                                    if (isJEEMain) {
                                        container.classList.remove('day-and-shift-hidden');
                                        container.style.display = '';
                                    } else {
                                        container.classList.add('day-and-shift-hidden');
                                        container.style.display = 'none';
                                    }
                                }
                            });
                        };
                    }
                    
                    // Add event listeners for dropdowns
                    stateSelect.addEventListener('change', () => updateMetadata(suffix));
                    boardSelect.addEventListener('change', () => {
                        updateMetadata(suffix);
                        // Toggle Day and Shift visibility for this subject's board
                        if (window.toggleDayAndShiftVisibility) {
                            window.toggleDayAndShiftVisibility(boardSelect.value);
                        }
                    });
                    yearSelect.addEventListener('change', () => updateMetadata(suffix));
                    subjectSelect.addEventListener('change', () => updateMetadata(suffix));
                    
                    // Sync main field changes to all subject fields
                    if (suffix === '') { // Only for main fields (Mathematics)
                        // Sync board field changes
                        boardSelect.addEventListener('change', function() {
                            const mainBoardValue = this.value;
                            const mainYearField = document.getElementById('year');
                            const mainDayShiftField = document.getElementById('dayAndShift');
                            const year = mainYearField ? mainYearField.value : '2025';
                            const dayAndShift = mainDayShiftField ? mainDayShiftField.value : '';
                            
                            // Toggle Day and Shift visibility based on board
                            if (window.toggleDayAndShiftVisibility) {
                                window.toggleDayAndShiftVisibility(mainBoardValue);
                            }
                            
                            // Sync to Physics board field
                            const physicsBoardField = document.getElementById('board-physics');
                            if (physicsBoardField) {
                                physicsBoardField.value = mainBoardValue;
                            }
                            // Sync to Chemistry board field
                            const chemistryBoardField = document.getElementById('board-chemistry');
                            if (chemistryBoardField) {
                                chemistryBoardField.value = mainBoardValue;
                            }
                            
                            // Sync dayAndShift to Physics
                            const physicsDayShiftField = document.getElementById('dayAndShift-physics');
                            if (physicsDayShiftField && dayAndShift) {
                                physicsDayShiftField.value = dayAndShift;
                            }
                            
                            // Sync dayAndShift to Chemistry
                            const chemistryDayShiftField = document.getElementById('dayAndShift-chemistry');
                            if (chemistryDayShiftField && dayAndShift) {
                                chemistryDayShiftField.value = dayAndShift;
                            }
                            
                            // Update tutorial IDs for all subjects
                            updateTutorialId('Mathematics', mainBoardValue, year);
                            updateTutorialId('Physics', mainBoardValue, year);
                            updateTutorialId('Chemistry', mainBoardValue, year);
                            
                            console.log(`‚úÖ Synced board value "${mainBoardValue}" to all subject fields and updated tutorial IDs`);
                        });
                        
                        // Initialize Day and Shift visibility on page load
                        const initialBoard = boardSelect.value;
                        if (window.toggleDayAndShiftVisibility) {
                            window.toggleDayAndShiftVisibility(initialBoard);
                        }
                        
                        // Sync year field changes
                        yearSelect.addEventListener('change', function() {
                            const mainYearValue = this.value;
                            const mainBoardField = document.getElementById('board');
                            const mainDayShiftField = document.getElementById('dayAndShift');
                            const board = mainBoardField ? mainBoardField.value : 'KCET';
                            const dayAndShift = mainDayShiftField ? mainDayShiftField.value : '';
                            
                            // Sync year to Physics and Chemistry
                            const physicsYearField = document.getElementById('year-physics');
                            if (physicsYearField) {
                                physicsYearField.value = mainYearValue;
                            }
                            const chemistryYearField = document.getElementById('year-chemistry');
                            if (chemistryYearField) {
                                chemistryYearField.value = mainYearValue;
                            }
                            
                            // Update tutorial IDs for all subjects
                            updateTutorialId('Mathematics', board, mainYearValue);
                            updateTutorialId('Physics', board, mainYearValue);
                            updateTutorialId('Chemistry', board, mainYearValue);
                            
                            console.log(`‚úÖ Synced year value "${mainYearValue}" to all subject fields and updated tutorial IDs`);
                        });
                        
                        // Sync dayAndShift field changes
                        const mainDayShiftField = document.getElementById('dayAndShift');
                        if (mainDayShiftField) {
                            mainDayShiftField.addEventListener('change', function() {
                                const mainDayShiftValue = this.value;
                                const mainBoardField = document.getElementById('board');
                                const mainYearField = document.getElementById('year');
                                const board = mainBoardField ? mainBoardField.value : 'KCET';
                                const year = mainYearField ? mainYearField.value : '2025';
                                
                                // Sync dayAndShift to Physics
                                const physicsDayShiftField = document.getElementById('dayAndShift-physics');
                                if (physicsDayShiftField) {
                                    physicsDayShiftField.value = mainDayShiftValue;
                                }
                                
                                // Sync dayAndShift to Chemistry
                                const chemistryDayShiftField = document.getElementById('dayAndShift-chemistry');
                                if (chemistryDayShiftField) {
                                    chemistryDayShiftField.value = mainDayShiftValue;
                                }
                                
                                // Update tutorial IDs for all subjects
                                updateTutorialId('Mathematics', board, year);
                                updateTutorialId('Physics', board, year);
                                updateTutorialId('Chemistry', board, year);
                                
                                console.log(`‚úÖ Synced dayAndShift value "${mainDayShiftValue}" to all subject fields and updated tutorial IDs`);
                            });
                        }
                    }
                    
                    // Add event listeners for manual input fields
                    if (tutorialTitleInput) {
                        tutorialTitleInput.addEventListener('input', () => updateJSONInRealTime(suffix));
                    }
                    if (authorityExamIdInput) {
                        authorityExamIdInput.addEventListener('input', () => updateJSONInRealTime(suffix));
                    }
                    
                    // Initial update
                    updateMetadata(suffix);
                }
            });
            
            // After all metadata editors are initialized, sync tutorial IDs if main fields exist
            const mainBoardField = document.getElementById('board');
            const mainYearField = document.getElementById('year');
            const mainDayShiftField = document.getElementById('dayAndShift');
            if (mainBoardField && mainYearField) {
                const board = mainBoardField.value || 'KCET';
                const year = mainYearField.value || '2025';
                
                // Update tutorial IDs for all subjects on initial load
                updateTutorialId('Mathematics', board, year);
                updateTutorialId('Physics', board, year);
                updateTutorialId('Chemistry', board, year);
                console.log(`üìù Initialized tutorial IDs for all subjects with board="${board}", year="${year}"`);
            }
        }
        
        // Update metadata based on selections
        function updateMetadata(suffix) {
            const state = document.getElementById(`state${suffix}`).value;
            const board = document.getElementById(`board${suffix}`).value;
            const year = document.getElementById(`year${suffix}`).value;
            const subject = document.getElementById(`subject${suffix}`).value;
            
            // Update conducted by based on board
            const conductedByInput = document.getElementById(`conductedBy${suffix}`);
            if (conductedByInput) {
                conductedByInput.value = getConductedBy(board);
            }
            
            // Update authority exam ID
            const authorityExamIdInput = document.getElementById(`authorityExamId${suffix}`);
            if (authorityExamIdInput) {
                authorityExamIdInput.value = getAuthorityExamId(state, board);
            }
            
            // Update tutorial ID
            const tutorialIdInput = document.getElementById(`tutorialId${suffix}`);
            if (tutorialIdInput && board && year && subject) {
                tutorialIdInput.value = `${board}_${year}_${subject}`;
            }
            
            // Update tutorial title
            const tutorialTitleInput = document.getElementById(`tutorialTitle${suffix}`);
            if (tutorialTitleInput && board && year && subject) {
                tutorialTitleInput.value = `${board} ${year} ${subject}`;
            }
            
            // Trigger real-time JSON update
            updateJSONInRealTime(suffix);
        }
        
        // Update JSON in real-time when metadata changes
        function updateJSONInRealTime(suffix) {
            // Determine which subject this corresponds to
            let subject = '';
            if (suffix === '') subject = 'Mathematics';
            else if (suffix === '-physics') subject = 'Physics';
            else if (suffix === '-chemistry') subject = 'Chemistry';
            
            // Check if this subject is currently active and JSON viewer is open
            const jsonPanel = document.getElementById(`jsonViewer-${subject}`);
            if (jsonPanel && jsonPanel.style.display !== 'none') {
                // Regenerate JSON content with updated metadata
                generateJSONContent(subject);
            }
        }
        
        // Get conducted by based on board
        function getConductedBy(board) {
            const conductedByMap = {
                'KCET': 'KEA (Karnataka Examinations Authority)',
                'NEET': 'NTA (National Testing Agency)',
                'JEE Main': 'NTA (National Testing Agency)',
                'JEE Advanced': 'IITs via JAB',
                'MH-CET': 'DTE Maharashtra',
                'TN-Board': 'Tamil Nadu Board of Secondary Education'
            };
            return conductedByMap[board] || '';
        }
        
        // Get authority exam ID based on state and board
        function getAuthorityExamId(state, board) {
            const examIdMap = {
                'Karnataka': {
                    'KCET': 'kar_kect',
                    'NEET': 'nta_neet',
                    'JEE Main': 'nta_jee_main',
                    'JEE Advanced': 'iit_jee_advanced'
                },
                'Maharashtra': {
                    'MH-CET': 'mhcet',
                    'NEET': 'nta_neet',
                    'JEE Main': 'nta_jee_main',
                    'JEE Advanced': 'iit_jee_advanced'
                },
                'Tamil Nadu': {
                    'TN-Board': 'tn_board',
                    'NEET': 'nta_neet',
                    'JEE Main': 'nta_jee_main',
                    'JEE Advanced': 'iit_jee_advanced'
                },
                'Center': {
                    'NEET': 'nta_neet',
                    'JEE Main': 'nta_jee_main',
                    'JEE Advanced': 'iit_jee_advanced'
                }
            };
            return examIdMap[state]?.[board] || '';
        }
        
        // Check if question needs manual editing (tables only - images are handled automatically)
        function needsManualEditing(question) {
            const text = question.text || '';
            const solution = question.solution || '';
            const options = question.options || [];
            
            // Check for table separators (options are always arrays now)
            let hasTableSeparator = text.includes('| :---: |') || solution.includes('| :---: |');
            if (Array.isArray(options)) {
                hasTableSeparator = hasTableSeparator || options.some(opt => opt && opt.includes('| :---: |'));
            }
            
            return hasTableSeparator;
        }
        
        // Update question button styling for all subjects
        function updateQuestionButtonStyling() {
            const subjects = ['Mathematics', 'Physics', 'Chemistry'];
            subjects.forEach(subject => {
                const questionListContainer = document.getElementById(`questionList-${subject}`);
                if (questionListContainer) {
                    const questionItems = questionListContainer.querySelectorAll('.question-item');
                    const subjectQuestions = allQuestions.filter(q => q.subject === subject.toLowerCase());
                    
                    questionItems.forEach((item, index) => {
                        if (index < subjectQuestions.length) {
                            const question = subjectQuestions[index];
                            if (needsManualEditing(question)) {
                                item.classList.add('manual-edit-needed');
                                item.title = 'This question needs manual editing (images or tables)';
                            } else {
                                // Reset to default styling
                                item.classList.remove('manual-edit-needed');
                                item.title = '';
                            }
                        }
                    });
                }
            });
        }
        
        // Update edit area styling for questions that need manual editing
        function updateEditAreaStyling() {
            console.log('=== UPDATE EDIT AREA STYLING ===');
            
            // Use the same logic as forceRedLabels() but for all visible textareas
            const allTextareas = document.querySelectorAll('textarea');
            console.log(`Found ${allTextareas.length} total textareas`);
            
            allTextareas.forEach((textarea, index) => {
                const value = textarea.value || '';
                const hasTable = value.includes('|:---:|') || value.includes('| :---: |');
                // Note: [Image] check removed - images are now handled automatically
                
                // Find the label for this textarea
                let label = null;
                
                // Method 1: Previous sibling
                if (textarea.previousElementSibling && textarea.previousElementSibling.tagName === 'LABEL') {
                    label = textarea.previousElementSibling;
                }
                
                // Method 2: Parent element's label
                if (!label && textarea.parentElement) {
                    label = textarea.parentElement.querySelector('label');
                }
                
                // Method 3: Look for any label in the same container
                if (!label) {
                    const container = textarea.closest('.question-card') || textarea.closest('.edit-field') || textarea.closest('.edit-field-group');
                    if (container) {
                        label = container.querySelector('label');
                    }
                }
                
                if (label) {
                    if (hasTable) {
                        // Make label RED - needs manual editing (only for tables now)
                        label.style.color = '#dc3545';
                        label.style.fontWeight = 'bold';
                        label.style.fontSize = '16px';
                        console.log(`‚úÖ Applied red label to: "${label.textContent}"`);
                        
                        // Also make textarea background RED
                        textarea.style.setProperty('background-color', 'rgba(220, 53, 69, 0.1)', 'important');
                        textarea.style.setProperty('border-color', 'rgba(220, 53, 69, 0.3)', 'important');
                    } else {
                        // Reset label to NORMAL - corrected
                        label.style.color = '';
                        label.style.fontWeight = '';
                        label.style.fontSize = '';
                        console.log(`‚úÖ Reset label to normal: "${label.textContent}"`);
                        
                        // Reset textarea background to NORMAL
                        textarea.style.removeProperty('background-color');
                        textarea.style.removeProperty('border-color');
                    }
                }
            });
            
            console.log('=== END UPDATE EDIT AREA STYLING ===');
        }
        
        // Manual function to test red border styling - call this from console
        function testRedBorders() {
            console.log('=== TESTING RED BORDERS ===');
            updateEditAreaStyling();
            
            // Also check if CSS is loaded
            const testElement = document.createElement('div');
            testElement.className = 'manual-edit-textarea';
            document.body.appendChild(testElement);
            const styles = window.getComputedStyle(testElement);
            console.log('Red border CSS test:', {
                border: styles.border,
                borderColor: styles.borderColor
            });
            document.body.removeChild(testElement);
        }
        
        // Simple direct function to add red labels - call this from console
        function forceRedLabels() {
            console.log('=== FORCING RED LABELS ===');
            const allTextareas = document.querySelectorAll('textarea');
            console.log(`Found ${allTextareas.length} total textareas`);
            
            allTextareas.forEach((textarea, index) => {
                const value = textarea.value || '';
                console.log(`Textarea ${index}:`, {
                    value: value.substring(0, 100),
                    hasTable: value.includes('|:---:|') || value.includes('| :---: |'),
                    // hasImage check removed - images are now handled automatically
                });
                
                if (value.includes('|:---:|') || value.includes('| :---: |')) {
                    console.log(`Adding red styling to textarea ${index}`);
                    
                    // Find the label for this textarea - try multiple methods
                    let label = null;
                    
                    // Method 1: Previous sibling
                    if (textarea.previousElementSibling && textarea.previousElementSibling.tagName === 'LABEL') {
                        label = textarea.previousElementSibling;
                    }
                    
                    // Method 2: Parent element's label
                    if (!label && textarea.parentElement) {
                        label = textarea.parentElement.querySelector('label');
                    }
                    
                    // Method 3: Look for any label in the same container
                    if (!label) {
                        const container = textarea.closest('.question-card') || textarea.closest('.edit-field') || textarea.closest('.edit-field-group');
                        if (container) {
                            label = container.querySelector('label');
                        }
                    }
                    
                    if (label) {
                        label.style.color = '#dc3545';
                        label.style.fontWeight = 'bold';
                        label.style.fontSize = '16px';
                        console.log(`‚úÖ Applied red label to: "${label.textContent}"`);
                    } else {
                        console.log(`‚ùå No label found for textarea ${index}`);
                    }
                    
                    // Apply red background to textarea
                    textarea.style.setProperty('background-color', 'rgba(220, 53, 69, 0.1)', 'important');
                    textarea.style.setProperty('border-color', 'rgba(220, 53, 69, 0.3)', 'important');
                    console.log(`‚úÖ Applied red background to textarea ${index}`);
                }
            });
        }
        
        // Auto-detect question type based on content
        function detectQuestionType(question) {
            const text = question.text || '';
            const options = question.options || [];
            
            // Check for fill in the blank
            if (text.includes('____') || text.includes('______') || text.includes('_ _ _ _') || text.includes('$\_\_\_\_$')) {
                return 'fillblank';
            }
            
            // Check for true/false (only 2 options)
            if (options.length === 2) {
                const optionTexts = options.map(opt => opt.replace(/^\(\d+\)\s*/, '').trim().toLowerCase());
                if (optionTexts.includes('true') && optionTexts.includes('false')) {
                    return 'truefalse';
                }
            }
            
            // Check for MCQ first - if we have proper A, B, C, D options, it's MCQ regardless of keywords
            const hasOptions = options.length >= 4 && 
                              options[0] && options[0].replace(/^\(\d+\)\s*/, '').trim() &&
                              options[1] && options[1].replace(/^\(\d+\)\s*/, '').trim() &&
                              options[2] && options[2].replace(/^\(\d+\)\s*/, '').trim() &&
                              options[3] && options[3].replace(/^\(\d+\)\s*/, '').trim();
            
            if (hasOptions) {
                return 'mcq';
            }
            
            // Only check for integer type if no proper MCQ options exist
            if (text.toLowerCase().includes('integer') || 
                text.toLowerCase().includes('numerical') ||
                text.toLowerCase().includes('number')) {
                return 'integer';
            }
            
            return 'fillblank';
        }
        
        // Update question type when question content changes
        function updateQuestionType(questionNumber) {
            const question = allQuestions.find(q => q.number === questionNumber);
            if (question) {
                const detectedType = detectQuestionType(question);
                // Always update the type to ensure correct detection
                question.type = detectedType;
            }
        }
        
        // Prevent accidental page refresh/close when work is in progress
        let hasUnsavedWork = false;
        
        // Mark work as unsaved when file is uploaded or any changes are made
        function markWorkAsUnsaved() {
            hasUnsavedWork = true;
        }
        
        // Clear unsaved work flag (e.g., after successful download)
        function markWorkAsSaved() {
            hasUnsavedWork = false;
        }
        
        // Warn user before leaving page
        window.addEventListener('beforeunload', function(e) {
            if (hasUnsavedWork && allQuestions.length > 0) {
                const message = 'Are you sure you want to leave? All your work (uploaded questions, edits, and AI analyses) will be lost!';
                e.preventDefault();
                e.returnValue = message; // Standard for most browsers
                return message; // For some older browsers
            }
        });
        
        // Initialize when page loads
        window.addEventListener('load', function() {
            initializeMetadataEditors();
        });
        // Generate JSON for a specific subject (similar to generateJSONContent but returns object)
        function generateJSONForSubject(subject) {
            const subjectQuestions = allQuestions.filter(q => q.subject === subject.toLowerCase());
            
            if (subjectQuestions.length === 0) {
                throw new Error(`No questions found for ${subject}`);
            }
            
            // Get metadata values from form inputs
            const getFormValue = (id) => {
                const element = document.getElementById(id);
                return element ? element.value : '';
            };
            
            const suffix = subject === 'Mathematics' ? '' : subject === 'Physics' ? '-physics' : subject === 'Chemistry' ? '-chemistry' : '-biology';
            const tutorialId = getFormValue(`tutorialId${suffix}`);
            const tutorialTitle = getFormValue(`tutorialTitle${suffix}`);
            const tutorialDescription = getFormValue(`tutorialDescription${suffix}`);
            const authorityExamId = getFormValue(`authorityExamId${suffix}`);
            const state = getFormValue(`state${suffix}`);
            const board = getFormValue(`board${suffix}`);
            const conductedBy = getFormValue(`conductedBy${suffix}`);
            const year = getFormValue(`year${suffix}`);
            const subjectValue = getFormValue(`subject${suffix}`);
            const dayAndShift = getFormValue(`dayAndShift${suffix}`);
            
            // Create JSON in the specified format
            const jsonData = [
                {
                    "tutorialId": tutorialId || `${board || 'KCET'}_${year || '2025'}_${subject}`,
                    "tutorialTitle": tutorialTitle || `${board || 'KCET'} ${year || '2025'} ${subject}`,
                    "tutorialDescription": tutorialDescription || "",
                    "authorityExamId": authorityExamId || "kar_kect",
                    "state": state || "Karnataka",
                    "board": board || "KCET",
                    "conductedBy": conductedBy || "KEA (Karnataka Examinations Authority)",
                    "year": year || "2025",
                    "subject": subjectValue || subject,
                    "dayAndShift": dayAndShift || "2 April 2025 Shift - 2",
                    "questions": subjectQuestions.map((question, index) => {
                        // Clean [Image] text from textImages array
                        const cleanedTextImages = (question.textImages || []).map(item => {
                            if (typeof item === 'string') {
                                return item;
                            } else if (item && typeof item === 'object') {
                                return {
                                    ...item,
                                    text: item.text ? removeImageTextFromPreview(item.text) : item.text
                                };
                            }
                            return item;
                        });
                        
                        // Clean [Image] text from solutionTextImages array
                        const cleanedSolutionTextImages = (question.solutionTextImages || []).map(item => {
                            if (typeof item === 'string') {
                                return item;
                            } else if (item && typeof item === 'object') {
                                return {
                                    ...item,
                                    text: item.text ? removeImageTextFromPreview(item.text) : item.text
                                };
                            }
                            return item;
                        });
                        
                        // Handle option images - convert array format to object format if needed
                        const getOptionImage = (optIndex) => {
                            if (!question.optionImages) return null;
                            const optImg = question.optionImages[optIndex];
                            if (Array.isArray(optImg) && optImg.length > 0) {
                                return typeof optImg[0] === 'string' ? optImg[0] : (optImg[0].image || null);
                            }
                            return typeof optImg === 'string' ? optImg : (optImg?.image || null);
                        };
                        
                        return {
                            "questionIndex": question.number.toString(),
                            "questionId": `2025${subject.charAt(0)}Q${question.number}`,
                            "questionDetails": [
                                {
                                    "text": removeImageTextFromPreview(question.text || ''),
                                    "textImages": cleanedTextImages,
                                    "possibleAnswers": {
                                        "A": {
                                            "text": removeImageTextFromPreview(question.options && question.options[0] ? question.options[0].replace(/^\(\d+\)\s*/, '').trim() : ''),
                                            "image": getOptionImage(0)
                                        },
                                        "B": {
                                            "text": removeImageTextFromPreview(question.options && question.options[1] ? question.options[1].replace(/^\(\d+\)\s*/, '').trim() : ''),
                                            "image": getOptionImage(1)
                                        },
                                        "C": {
                                            "text": removeImageTextFromPreview(question.options && question.options[2] ? question.options[2].replace(/^\(\d+\)\s*/, '').trim() : ''),
                                            "image": getOptionImage(2)
                                        },
                                        "D": {
                                            "text": removeImageTextFromPreview(question.options && question.options[3] ? question.options[3].replace(/^\(\d+\)\s*/, '').trim() : ''),
                                            "image": getOptionImage(3)
                                        }
                                    },
                                    "correctAnswer": question.answer || '',
                                    "correctAnswerText": removeImageTextFromPreview(question.options && question.answer && question.options[parseInt(question.answer) - 1] ? 
                                        question.options[parseInt(question.answer) - 1].replace(/^\(\d+\)\s*/, '').trim() : ''),
                                    "solution": removeImageTextFromPreview(question.solution || ''),
                                    "solutionTextImages": cleanedSolutionTextImages,
                                    "type": question.type || "mcq",
                                    "metadata": {
                                        "subject": subject.toLowerCase(),
                                        "number": question.number || (index + 1)
                                    }
                                }
                            ]
                        };
                    })
                }
            ];
            
            return jsonData;
        }
        
        // Upload Dialog Functions
        let currentUploadSubject = null;
        
        function openUploadDialog(subject) {
            console.log('Opening upload dialog for subject:', subject);
            currentUploadSubject = subject;
            const dialog = document.getElementById('uploadDialogOverlay');
            const jsonPreview = document.getElementById('uploadJsonPreview');
            
            if (!dialog) {
                console.error('Upload dialog overlay not found!');
                alert('Upload dialog not found. Please refresh the page.');
                return;
            }
            
            if (!jsonPreview) {
                console.error('JSON preview element not found!');
                alert('JSON preview element not found. Please refresh the page.');
                return;
            }
            
            try {
                const jsonData = generateJSONForSubject(subject);
                const jsonString = JSON.stringify(jsonData, null, 2);
                jsonPreview.textContent = jsonString;
            } catch (error) {
                console.error('Error generating JSON:', error);
                jsonPreview.textContent = `Error generating JSON: ${error.message}`;
                alert(`Error: ${error.message}`);
                return;
            }
            
            // Load available boards and years
            loadBoardsForUpload();
            dialog.classList.add('show');
            console.log('Dialog should now be visible');
        }
        
        function closeUploadDialog() {
            const dialog = document.getElementById('uploadDialogOverlay');
            dialog.classList.remove('show');
            currentUploadSubject = null;
            // Reset form
            document.getElementById('uploadBoardSelect').value = '';
            document.getElementById('uploadBoardCustom').value = '';
            document.getElementById('uploadYearSelect').value = '';
            document.getElementById('uploadYearCustom').value = '';
            document.getElementById('uploadYearSelect').innerHTML = '<option value="">-- Select Year --</option>';
            document.getElementById('uploadShiftOrDay').value = '';
            // Reset button state
            document.querySelectorAll('.upload-dialog-btn-primary').forEach(btn => {
                btn.disabled = false;
                if (btn.textContent.includes('Upload')) {
                    btn.textContent = 'Upload as new file';
                }
                if (btn.textContent.includes('Update')) {
                    btn.textContent = 'Update existing file';
                }
            });
        }
        
        async function loadBoardsForUpload() {
            // Load boards from Firebase directories
            const { storage, ref, listAll } = window.firebaseStorage;
            try {
                const rootRef = ref(storage, '');
                const result = await listAll(rootRef);
                
                const boardSelect = document.getElementById('uploadBoardSelect');
                const existingBoards = Array.from(boardSelect.options).map(opt => opt.value);
                
                result.prefixes.forEach(prefix => {
                    const boardName = prefix.name;
                    if (boardName && !existingBoards.includes(boardName)) {
                        const option = document.createElement('option');
                        option.value = boardName;
                        option.textContent = boardName;
                        boardSelect.appendChild(option);
                    }
                });
            } catch (error) {
                console.error('Error loading boards:', error);
            }
        }
        
        async function handleBoardSelectChange() {
            const boardSelect = document.getElementById('uploadBoardSelect');
            const boardCustom = document.getElementById('uploadBoardCustom');
            const yearSelect = document.getElementById('uploadYearSelect');
            
            if (boardSelect.value) {
                // Clear custom input when selecting from dropdown
                boardCustom.value = '';
                // Load years for selected board
                await loadYearsForBoard(boardSelect.value);
            } else {
                // Clear year dropdown when board is deselected
                yearSelect.innerHTML = '<option value="">-- Select Year --</option>';
            }
        }
        
        function handleCustomBoardInput() {
            const boardCustom = document.getElementById('uploadBoardCustom');
            const boardSelect = document.getElementById('uploadBoardSelect');
            
            if (boardCustom.value && boardCustom.value.trim()) {
                const customValue = boardCustom.value.trim();
                // Check if already exists in dropdown
                const existingOption = Array.from(boardSelect.options).find(opt => opt.value === customValue);
                
                if (!existingOption) {
                    // Add custom board to dropdown
                    const option = document.createElement('option');
                    option.value = customValue;
                    option.textContent = customValue + ' (custom)';
                    boardSelect.appendChild(option);
                }
                
                // Select the custom board
                boardSelect.value = customValue;
                // Load years for the custom board
                loadYearsForBoard(customValue);
            }
        }

        // Map board to conducted by
        function getConductedByForBoard(boardValue) {
            // Normalize board string to catch underscores / dashes / spaces
            const normalized = (boardValue || '')
                .toLowerCase()
                .replace(/[_-]+/g, ' ')
                .trim();

            const map = {
                'kcet': 'KCET ‚Äî Karnataka Examinations Authority (KEA)',
                'neet': 'NEET ‚Äî National Testing Agency (NTA)',
                'jee main': 'JEE Main ‚Äî National Testing Agency (NTA)',
                'jee advanced': 'JEE Advanced ‚Äî Indian Institutes of Technology (IITs)',
            };

            // Exact match first
            if (map[normalized]) return map[normalized];

            // Fallback includes
            if (normalized.includes('kcet')) return map['kcet'];
            if (normalized.includes('neet')) return map['neet'];
            if (normalized.includes('jee main')) return map['jee main'];
            if (normalized.includes('jee advanced')) return map['jee advanced'];

            return '';
        }

        // Set Conducted By based on board selection
        function setConductedByFromBoard(boardValue, conductedBySelectId) {
            const conductedByValue = getConductedByForBoard(boardValue);
            const conductedBySelect = document.getElementById(conductedBySelectId);
            if (!conductedBySelect) return;

            if (conductedByValue) {
                // Try direct value match first
                conductedBySelect.value = conductedByValue;
                if (conductedBySelect.value === conductedByValue) return;

                // Fallback: find option by text match (case-insensitive, ignoring dashes)
                const target = conductedByValue.toLowerCase().replace(/[-‚Äì‚Äî]/g, '').trim();
                const match = Array.from(conductedBySelect.options).find(opt =>
                    opt.textContent.toLowerCase().replace(/[-‚Äì‚Äî]/g, '').trim() === target
                );
                if (match) {
                    conductedBySelect.value = match.value;
                    return;
                }
            }

            // If nothing matched, default to first option
            if (conductedBySelect.options.length > 0) {
                conductedBySelect.selectedIndex = 0;
            }
        }

        // Sync all Conducted By fields from their boards
        function syncConductedByAll() {
            const pairs = [
                { boardId: 'board', conductedById: 'conductedBy' },
                { boardId: 'board-physics', conductedById: 'conductedBy-physics' },
                { boardId: 'board-chemistry', conductedById: 'conductedBy-chemistry' },
                { boardId: 'board-biology', conductedById: 'conductedBy-biology' },
            ];
            pairs.forEach(({ boardId, conductedById }) => {
                const b = document.getElementById(boardId);
                if (b) setConductedByFromBoard(b.value, conductedById);
            });
        }

        // Auto-sync Conducted By on load for existing board selections
        window.addEventListener('DOMContentLoaded', () => {
            syncConductedByAll();
        });

        // Update existing JSON in the same Firebase path it was loaded from
        async function updateExistingJSON() {
            if (!currentFirebaseJsonPath) {
                alert('‚ùå No loaded Firebase JSON path found. Please load a JSON file from Firebase first.');
                return;
            }

            const subject = currentUploadSubject || getCurrentSubject() || 'Mathematics';

            try {
                // Show loading state
                const buttons = document.querySelectorAll('.upload-dialog-btn-primary');
                buttons.forEach(btn => {
                    if (btn.textContent.includes('Update')) {
                        btn.disabled = true;
                        btn.textContent = 'Updating...';
                    }
                });

                // Generate JSON
                const jsonData = generateJSONForSubject(subject);
                const jsonString = JSON.stringify(jsonData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });

                // Upload to the exact same path
                const { storage, ref, uploadBytesResumable } = window.firebaseStorage;
                const storageRef = ref(storage, currentFirebaseJsonPath);

                console.log(`üì§ Updating JSON to Firebase at existing path: ${currentFirebaseJsonPath}`);

                await uploadBytesResumable(storageRef, blob);

                alert(`‚úÖ Successfully updated existing JSON file!\n\nPath: ${currentFirebaseJsonPath}`);
                closeUploadDialog();
            } catch (error) {
                console.error('Upload error:', error);
                alert(`‚ùå Error updating JSON: ${error.message}`);
            } finally {
                // Restore button state
                const buttons = document.querySelectorAll('.upload-dialog-btn-primary');
                buttons.forEach(btn => {
                    btn.disabled = false;
                    if (btn.textContent.includes('Upload')) btn.textContent = 'Upload as new file';
                    if (btn.textContent.includes('Update')) btn.textContent = 'Update existing file';
                });
            }
        }
        
        async function loadYearsForBoard(boardName) {
            const { storage, ref, listAll } = window.firebaseStorage;
            const yearSelect = document.getElementById('uploadYearSelect');
            yearSelect.innerHTML = '<option value="">-- Select Year --</option>';
            
            try {
                const boardRef = ref(storage, boardName);
                const result = await listAll(boardRef);
                
                const years = [];
                result.prefixes.forEach(prefix => {
                    const name = prefix.name;
                    const yearMatch = name.match(/(\d{4})/);
                    if (yearMatch) {
                        years.push({
                            year: yearMatch[1],
                            folderName: name
                        });
                    }
                });
                
                // Sort years descending
                years.sort((a, b) => parseInt(b.year) - parseInt(a.year));
                
                years.forEach(yearData => {
                    const option = document.createElement('option');
                    option.value = yearData.folderName;
                    option.textContent = yearData.year;
                    yearSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading years:', error);
            }
        }
        
        function handleYearSelectChange() {
            const yearSelect = document.getElementById('uploadYearSelect');
            const yearCustom = document.getElementById('uploadYearCustom');
            
            if (yearSelect.value) {
                // Clear custom input when selecting from dropdown
                yearCustom.value = '';
            }
        }
        
        // Helper function to generate correct folder name format based on board
        function generateYearFolderName(boardName, year) {
            // Extract base board name (remove any existing suffixes)
            let baseBoard = boardName;
            
            // Remove common suffixes if present
            baseBoard = baseBoard.replace(/_JSON_question_papers.*$/i, '');
            baseBoard = baseBoard.replace(/_question_papers.*$/i, '');
            baseBoard = baseBoard.replace(/_papers.*$/i, '');
            baseBoard = baseBoard.replace(/_JSON.*$/i, '');
            
            // Normalize board name
            const normalizedBoard = baseBoard.trim().toUpperCase();
            
            // Generate folder name based on board type
            if (normalizedBoard === 'KCET' || normalizedBoard.startsWith('KCET')) {
                return `KCET_question_papers_${year}`;
            } else if (normalizedBoard === 'JEE_MAIN' || normalizedBoard === 'JEE MAIN' || normalizedBoard.startsWith('JEE_MAIN') || normalizedBoard.startsWith('JEE MAIN')) {
                return `JEE_Main_papers_${year}`;
            } else {
                // Default format for other boards
                return `${baseBoard}_question_papers_${year}`;
            }
        }
        
        function handleCustomYearInput() {
            const yearCustom = document.getElementById('uploadYearCustom');
            const yearSelect = document.getElementById('uploadYearSelect');
            const boardSelect = document.getElementById('uploadBoardSelect');
            
            if (yearCustom.value && yearCustom.value.trim()) {
                const inputValue = yearCustom.value.trim();
                // Extract year from input (look for 4-digit year)
                const yearMatch = inputValue.match(/(\d{4})/);
                const year = yearMatch ? yearMatch[1] : inputValue;
                
                // Validate year is numeric
                if (!/^\d{4}$/.test(year)) {
                    return; // Don't add invalid year
                }
                
                const boardName = boardSelect.value || 'questions';
                
                // Create folder name format using helper function
                const folderName = generateYearFolderName(boardName, year);
                
                // Check if already exists in dropdown
                const existingOption = Array.from(yearSelect.options).find(opt => opt.value === folderName);
                
                if (!existingOption) {
                    // Add custom year to dropdown
                    const option = document.createElement('option');
                    option.value = folderName;
                    option.textContent = year + ' (custom)';
                    yearSelect.appendChild(option);
                }
                
                // Select the custom year
                yearSelect.value = folderName;
            }
        }
        
        async function uploadJSONToFirebase() {
            if (!currentUploadSubject) {
                alert('‚ùå No subject selected');
                return;
            }
            
            const boardSelect = document.getElementById('uploadBoardSelect');
            const yearSelect = document.getElementById('uploadYearSelect');
            
            // Validate required fields
            if (!boardSelect.value || !boardSelect.value.trim()) {
                alert('‚ùå Please select or enter a Board directory');
                return;
            }
            
            if (!yearSelect.value || !yearSelect.value.trim()) {
                alert('‚ùå Please select or enter a Year');
                return;
            }
            
            try {
                // Show loading state
                const uploadBtn = document.querySelector('.upload-dialog-btn-primary');
                const originalText = uploadBtn.textContent;
                uploadBtn.disabled = true;
                uploadBtn.textContent = 'Uploading...';
                
                // Generate JSON
                const jsonData = generateJSONForSubject(currentUploadSubject);
                const jsonString = JSON.stringify(jsonData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                
                // Create file name
                const subjectLower = currentUploadSubject.toLowerCase();
                const yearMatch = yearSelect.value.match(/(\d{4})/);
                const year = yearMatch ? yearMatch[1] : new Date().getFullYear().toString();
                
                // Get board name for file naming (extract base board name)
                let boardNameForFile = boardSelect.value;
                // Remove common suffixes to get base board name
                boardNameForFile = boardNameForFile.replace(/_JSON.*$/i, '');
                boardNameForFile = boardNameForFile.replace(/_question_papers.*$/i, '');
                boardNameForFile = boardNameForFile.replace(/_papers.*$/i, '');
                boardNameForFile = boardNameForFile.toLowerCase();
                
                // Get Shift or Day from upload dialog (optional) - this takes precedence
                const shiftOrDayInput = document.getElementById('uploadShiftOrDay');
                let shiftOrDayValue = shiftOrDayInput ? shiftOrDayInput.value.trim() : '';
                
                // Format shift/day value: "2 april shift2" -> "2_april_shift2" for folder
                // For filename: "2 april shift2" -> "_2_april_shift_2" (with shift number separated)
                let shiftOrDayFolder = '';
                let shiftOrDayFileNamePart = '';
                if (shiftOrDayValue) {
                    // Parse shift/day value to extract components
                    // Example: "2 april shift2" -> day=2, month=april, shift=2
                    const shiftDayMatch = shiftOrDayValue.match(/(\d{1,2})\s+(january|february|march|april|may|june|july|august|september|october|november|december)\s+shift\s*(\d+)/i);
                    
                    if (shiftDayMatch) {
                        const day = shiftDayMatch[1];
                        const month = shiftDayMatch[2].toLowerCase();
                        const shift = shiftDayMatch[3];
                        
                        // Folder format: "2_april_shift2"
                        shiftOrDayFolder = `${day}_${month}_shift${shift}`;
                        
                        // Filename format: "_2_april_shift_2" (shift number separated with underscore)
                        shiftOrDayFileNamePart = `_${day}_${month}_shift_${shift}`;
                    } else {
                        // If format doesn't match, just convert to lowercase with underscores
                        shiftOrDayFolder = shiftOrDayValue.toLowerCase().replace(/\s+/g, '_');
                        shiftOrDayFileNamePart = `_${shiftOrDayFolder}`;
                    }
                }
                
                // Fallback: Get Day and Shift field value from form (only if upload dialog shift/day is not provided)
                let dayShiftFileNamePart = '';
                if (!shiftOrDayValue) {
                    const dayShiftSuffix = currentUploadSubject === 'Mathematics' ? '' : 
                                          currentUploadSubject === 'Physics' ? '-physics' : 
                                          currentUploadSubject === 'Chemistry' ? '-chemistry' : 
                                          '-biology';
                    const dayShiftField = document.getElementById(`dayAndShift${dayShiftSuffix}`);
                    const dayShiftFieldContainer = dayShiftField ? dayShiftField.closest('.field') : null;
                    
                    // Check if Day and Shift field is visible (only for JEE Main)
                    const isDayShiftVisible = dayShiftFieldContainer && 
                                             !dayShiftFieldContainer.classList.contains('day-and-shift-hidden') &&
                                             dayShiftFieldContainer.style.display !== 'none';
                    
                    // Parse day and shift from dayAndShift field ONLY if it's visible
                    if (isDayShiftVisible && dayShiftField && dayShiftField.value && dayShiftField.value.trim()) {
                        const dayAndShiftValue = dayShiftField.value.trim();
                        // Parse format: "2 April 2025 Shift - 1" or "3 April 2025 Shift - 1"
                        const dayShiftMatch = dayAndShiftValue.match(/(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})\s+Shift\s*-\s*(\d+)/i);
                        if (dayShiftMatch) {
                            const day = dayShiftMatch[1];
                            const month = dayShiftMatch[2].toLowerCase();
                            const shift = dayShiftMatch[4];
                            dayShiftFileNamePart = `_${day}_${month}_shift_${shift}`;
                        }
                    }
                }
                
                // Use shift/day from upload dialog first, then fallback to form field, then A1
                const fileNameSuffix = shiftOrDayFileNamePart || dayShiftFileNamePart || '_A1';
                const fileName = `${year}_${boardNameForFile}_${subjectLower}${fileNameSuffix}.json`;
                
                // Extract base board name for constructing year folder
                let baseBoardName = boardSelect.value;
                // Remove common suffixes to get base board name
                baseBoardName = baseBoardName.replace(/_JSON.*$/i, '');
                baseBoardName = baseBoardName.replace(/_question_papers.*$/i, '');
                baseBoardName = baseBoardName.replace(/_papers.*$/i, '');
                
                // Construct year folder name using helper function (ensures correct format)
                let yearFolder = yearSelect.value;
                // If year folder doesn't match expected format, reconstruct it
                if (!yearFolder.includes('_question_papers_') && !yearFolder.includes('_papers_')) {
                    // Reconstruct year folder name using helper function
                    yearFolder = generateYearFolderName(baseBoardName, year);
                } else {
                    // Even if it has the pattern, ensure it uses the correct format
                    yearFolder = generateYearFolderName(baseBoardName, year);
                }
                
                // Create Firebase path: BoardDirectory/YearFolder/ShiftOrDay/FileName (if shift/day provided)
                // Or: BoardDirectory/YearFolder/FileName (if no shift/day)
                // Use original board directory as selected (e.g., KCET_JSON)
                let firebasePath;
                if (shiftOrDayFolder) {
                    // Include shift/day folder in path
                    firebasePath = `${boardSelect.value}/${yearFolder}/${shiftOrDayFolder}/${fileName}`;
                } else {
                    // No shift/day folder
                    firebasePath = `${boardSelect.value}/${yearFolder}/${fileName}`;
                }
                
                // Upload to Firebase
                const { storage, ref, uploadBytesResumable } = window.firebaseStorage;
                const storageRef = ref(storage, firebasePath);
                
                console.log(`üì§ Uploading JSON to Firebase: ${firebasePath}`);
                console.log(`üìÑ File name: ${fileName}`);
                
                // Upload the file
                await uploadBytesResumable(storageRef, blob);
                
                // Save subject before closing dialog (closeUploadDialog sets currentUploadSubject to null)
                const uploadedSubject = currentUploadSubject;
                
                alert(`‚úÖ Successfully uploaded JSON file!\n\nPath: ${firebasePath}\nFile: ${fileName}`);
                closeUploadDialog();
                
                // Switch to Edit view after successful upload (with delay to ensure DOM is ready)
                if (uploadedSubject) {
                    // Set flag to prevent automatic preview switch
                    window.skipAutoPreviewSwitch = true;
                    
                    // First, ensure Edit button is active BEFORE showSubject runs
                    const viewerToggle = document.getElementById(`viewerToggle-${uploadedSubject}`);
                    if (viewerToggle) {
                        viewerToggle.style.display = 'flex';
                        const toggleButtons = viewerToggle.querySelectorAll('.viewer-toggle-btn');
                        if (toggleButtons.length > 0) {
                            // Remove active from all buttons and set Edit as active
                            toggleButtons.forEach(btn => btn.classList.remove('active'));
                            toggleButtons[0].classList.add('active');
                        }
                    }
                    
                    // Check if subject view is already shown
                    const subjectViewElement = document.getElementById(`subjectView-${uploadedSubject}`);
                    const isSubjectAlreadyShown = subjectViewElement && subjectViewElement.style.display === 'block';
                    
                    if (!isSubjectAlreadyShown) {
                        // Only call showSubject if subject is not already shown
                        showSubject(uploadedSubject);
                    }
                    
                    // Switch to Edit view with longer delay to ensure all showSubject timeouts complete
                    setTimeout(() => {
                        // Directly manipulate buttons to ensure Edit is selected
                        const toggleButtons = document.querySelectorAll(`#viewerToggle-${uploadedSubject} .viewer-toggle-btn`);
                        if (toggleButtons.length > 0) {
                            // Remove active from all buttons
                            toggleButtons.forEach(btn => btn.classList.remove('active'));
                            // Add active to Edit button (first button)
                            toggleButtons[0].classList.add('active');
                        }
                        
                        // Now call switchViewer to update panels
                        switchViewer(uploadedSubject, 'editor');
                        console.log(`‚úÖ Switched to Edit view for ${uploadedSubject} after upload`);
                        
                        // Force it again after a bit more delay to override any other switches
                        setTimeout(() => {
                            // Directly set Edit button as active again
                            const toggleButtons = document.querySelectorAll(`#viewerToggle-${uploadedSubject} .viewer-toggle-btn`);
                            if (toggleButtons.length > 0) {
                                toggleButtons.forEach(btn => btn.classList.remove('active'));
                                toggleButtons[0].classList.add('active');
                            }
                            switchViewer(uploadedSubject, 'editor');
                        }, 400);
                    }, 800);
                }
            } catch (error) {
                console.error('Upload error:', error);
                alert(`‚ùå Error uploading JSON: ${error.message}\n\nPlease check:\n1. Firebase connection\n2. File path is correct\n3. You have upload permissions`);
            } finally {
                // Restore button state
                document.querySelectorAll('.upload-dialog-btn-primary').forEach(btn => {
                    btn.disabled = false;
                    if (btn.textContent.includes('Upload')) btn.textContent = 'Upload as new file';
                    if (btn.textContent.includes('Update')) btn.textContent = 'Update existing file';
                });
            }
        }
        
        // Close dialog on overlay click
        document.addEventListener('DOMContentLoaded', function() {
            const overlay = document.getElementById('uploadDialogOverlay');
            if (overlay) {
                overlay.addEventListener('click', function(e) {
                    if (e.target === overlay) {
                        closeUploadDialog();
                    }
                });
            }
        });
    </script>
        </div> <!-- Close main-content -->
    </div> <!-- Close container -->
    
    <!-- Upload Dialog Modal -->
    <div class="upload-dialog-overlay" id="uploadDialogOverlay">
        <div class="upload-dialog">
            <div class="upload-dialog-content">
                <!-- 1. JSON File Preview (shown first) -->
                <div class="upload-dialog-field">
                    <label>JSON File Preview:</label>
                    <div class="upload-dialog-json-preview" id="uploadJsonPreview"></div>
                </div>
                
                <!-- 2. Board Directory Selection -->
                <div class="upload-dialog-field">
                    <label>Board Directory: <span style="color: red;">*</span></label>
                    <select id="uploadBoardSelect" onchange="handleBoardSelectChange()">
                        <option value="">-- Select Board --</option>
                        <option value="KCET_JSON">KCET_JSON</option>
                        <option value="JEE_MAIN">JEE_MAIN</option>
                        <option value="questions">questions</option>
                    </select>
                    <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                        <span>Or type custom board name:</span>
                        <input type="text" id="uploadBoardCustom" placeholder="Enter custom board name" style="width: 100%; margin-top: 4px;" onkeyup="handleCustomBoardInput()">
                    </div>
                </div>
                
                <!-- 3. Year Selection -->
                <div class="upload-dialog-field">
                    <label>Year: <span style="color: red;">*</span></label>
                    <select id="uploadYearSelect" onchange="handleYearSelectChange()">
                        <option value="">-- Select Year --</option>
                    </select>
                    <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                        <span>Or type custom year:</span>
                        <input type="text" id="uploadYearCustom" placeholder="Enter custom year (e.g., 2025)" style="width: 100%; margin-top: 4px;" onkeyup="handleCustomYearInput()">
                    </div>
                </div>
                
                <!-- 4. Shift or Day (Optional) -->
                <div class="upload-dialog-field">
                    <label>Shift or Day: <span style="color: #6c757d; font-size: 12px;">(Optional)</span></label>
                    <input type="text" id="uploadShiftOrDay" placeholder="e.g., 2 april shift2" style="width: 100%; margin-top: 4px;">
                    <div style="margin-top: 4px; font-size: 11px; color: var(--text-secondary);">
                        If provided, creates a subdirectory. Format: "2 april shift2" ‚Üí folder: "2_april_shift2", filename includes "_2_april_shift_2"
                    </div>
                </div>
            </div>
            <div class="upload-dialog-actions">
                <button class="upload-dialog-btn upload-dialog-btn-secondary" onclick="closeUploadDialog()">Cancel</button>
                <button class="upload-dialog-btn upload-dialog-btn-primary" onclick="updateExistingJSON()">Update existing file</button>
                <button class="upload-dialog-btn upload-dialog-btn-primary" onclick="uploadJSONToFirebase()">Upload as new file</button>
            </div>
        </div>
    </div>
</body>
</html>
